namespace std {
    inline namespace __1 {
    }
}
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;
typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
typedef int __darwin_ct_rune_t;
union {
    char __mbstate8[128];
    long long _mbstateL;
} typedef __mbstate_t;
typedef __mbstate_t __darwin_mbstate_t;
typedef long __darwin_ptrdiff_t;
typedef unsigned long __darwin_size_t;
typedef __builtin_va_list __darwin_va_list;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
typedef int __darwin_wint_t;
typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;
typedef __darwin_ino64_t __darwin_ino_t;
typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
struct __darwin_pthread_handler_rec {
    void (*__routine)(void *);
    void *__arg;
    struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t {
    long __sig;
    char __opaque[56];
};
struct _opaque_pthread_cond_t {
    long __sig;
    char __opaque[40];
};
struct _opaque_pthread_condattr_t {
    long __sig;
    char __opaque[8];
};
struct _opaque_pthread_mutex_t {
    long __sig;
    char __opaque[56];
};
struct _opaque_pthread_mutexattr_t {
    long __sig;
    char __opaque[8];
};
struct _opaque_pthread_once_t {
    long __sig;
    char __opaque[8];
};
struct _opaque_pthread_rwlock_t {
    long __sig;
    char __opaque[192];
};
struct _opaque_pthread_rwlockattr_t {
    long __sig;
    char __opaque[16];
};
struct _opaque_pthread_t {
    long __sig;
    struct __darwin_pthread_handler_rec *__cleanup_stack;
    char __opaque[8176];
};
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;
typedef __uint32_t __darwin_wctype_t;
typedef __darwin_size_t size_t;
typedef __darwin_mbstate_t mbstate_t;
typedef __darwin_ct_rune_t ct_rune_t;
typedef __darwin_rune_t rune_t;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef __darwin_va_list va_list;
extern "C" {
    int renameat(int, const char *, int, const char *) __attribute__((availability(macos, introduced=10.10)));
}
typedef __darwin_off_t fpos_t;
struct __sbuf {
    unsigned char *_base;
    int _size;
};
struct __sFILEX;
struct __sFILE {
    unsigned char *_p;
    int _r;
    int _w;
    short _flags;
    short _file;
    struct __sbuf _bf;
    int _lbfsize;
    void *_cookie;
    int (*_close)(void *);
    int (*_read)(void *, char *, int);
    fpos_t (*_seek)(void *, fpos_t, int);
    int (*_write)(void *, const char *, int);
    struct __sbuf _ub;
    struct __sFILEX *_extra;
    int _ur;
    unsigned char _ubuf[3];
    unsigned char _nbuf[1];
    struct __sbuf _lb;
    int _blksize;
    fpos_t _offset;
};
typedef struct __sFILE FILE;
extern "C" {
    extern FILE *__stdinp;
    extern FILE *__stdoutp;
    extern FILE *__stderrp;
}
extern "C" {
    void clearerr(FILE *);
    int fclose(FILE *);
    int feof(FILE *);
    int ferror(FILE *);
    int fflush(FILE *);
    int fgetc(FILE *);
    int fgetpos(FILE *, fpos_t *);
    char *fgets(char *, int, FILE *);
    FILE *fopen(const char *, const char *) asm("_fopen");
    int fprintf(FILE *, const char *, ...) __attribute__((format(printf, 2, 3)));
    int fputc(int, FILE *);
    int fputs(const char *, FILE *) asm("_fputs");
    size_t fread(void *, size_t, size_t, FILE *);
    FILE *freopen(const char *, const char *, FILE *) asm("_freopen");
    int fscanf(FILE *, const char *, ...) __attribute__((format(scanf, 2, 3)));
    int fseek(FILE *, long, int);
    int fsetpos(FILE *, const fpos_t *);
    long ftell(FILE *);
    size_t fwrite(const void *, size_t, size_t, FILE *) asm("_fwrite");
    int getc(FILE *);
    int getchar();
    char *gets(char *);
    void perror(const char *);
    int printf(const char *, ...) __attribute__((format(printf, 1, 2)));
    int putc(int, FILE *);
    int putchar(int);
    int puts(const char *);
    int remove(const char *);
    int rename(const char *, const char *);
    void rewind(FILE *);
    int scanf(const char *, ...) __attribute__((format(scanf, 1, 2)));
    void setbuf(FILE *, char *);
    int setvbuf(FILE *, char *, int, size_t);
    int sprintf(char *, const char *, ...) __attribute__((format(printf, 2, 3)));
    int sscanf(const char *, const char *, ...) __attribute__((format(scanf, 2, 3)));
    FILE *tmpfile();
    char *tmpnam(char *) __attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")));
    int ungetc(int, FILE *);
    int vfprintf(FILE *, const char *, va_list) __attribute__((format(printf, 2, 0)));
    int vprintf(const char *, va_list) __attribute__((format(printf, 1, 0)));
    int vsprintf(char *, const char *, va_list) __attribute__((format(printf, 2, 0)));
}
extern "C" {
    char *ctermid(char *);
    FILE *fdopen(int, const char *) asm("_fdopen");
    int fileno(FILE *);
}
extern "C" {
    int pclose(FILE *);
    FILE *popen(const char *, const char *) asm("_popen");
}
extern "C" {
    int __srget(FILE *);
    int __svfscanf(FILE *, const char *, va_list) __attribute__((format(scanf, 2, 0)));
    int __swbuf(int, FILE *);
}
inline int __sputc(int _c, FILE *_p) __attribute__((always_inline)) {
    if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
        return (*_p->_p++ = _c);
    else
        return (__swbuf(_c, _p));
}


extern "C" {
    void flockfile(FILE *);
    int ftrylockfile(FILE *);
    void funlockfile(FILE *);
    int getc_unlocked(FILE *);
    int getchar_unlocked();
    int putc_unlocked(int, FILE *);
    int putchar_unlocked(int);
    int getw(FILE *);
    int putw(int, FILE *);
    char *tempnam(const char *, const char *) asm("_tempnam") __attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")));
}
typedef __darwin_off_t off_t;
extern "C" {
    int fseeko(FILE *, off_t, int);
    off_t ftello(FILE *);
}
extern "C" {
    int snprintf(char *, size_t, const char *, ...) __attribute__((format(printf, 3, 4)));
    int vfscanf(FILE *, const char *, va_list) __attribute__((format(scanf, 2, 0)));
    int vscanf(const char *, va_list) __attribute__((format(scanf, 1, 0)));
    int vsnprintf(char *, size_t, const char *, va_list) __attribute__((format(printf, 3, 0)));
    int vsscanf(const char *, const char *, va_list) __attribute__((format(scanf, 2, 0)));
}
typedef __darwin_ssize_t ssize_t;
extern "C" {
    int dprintf(int, const char *, ...) __attribute__((availability(macos, introduced=10.7))) __attribute__((format(printf, 2, 3)));
    int vdprintf(int, const char *, va_list) __attribute__((availability(macos, introduced=10.7))) __attribute__((format(printf, 2, 0)));
    ssize_t getdelim(char **, size_t *, int, FILE *) __attribute__((availability(macos, introduced=10.7)));
    ssize_t getline(char **, size_t *, FILE *) __attribute__((availability(macos, introduced=10.7)));
}
extern "C" {
    extern const int sys_nerr;
    extern const char *const sys_errlist[];
    int asprintf(char **, const char *, ...) __attribute__((format(printf, 2, 3)));
    char *ctermid_r(char *);
    char *fgetln(FILE *, size_t *);
    const char *fmtcheck(const char *, const char *);
    int fpurge(FILE *);
    void setbuffer(FILE *, char *, int);
    int setlinebuf(FILE *);
    int vasprintf(char **, const char *, va_list) __attribute__((format(printf, 2, 0)));
    FILE *zopen(const char *, const char *, int);
    FILE *funopen(const void *, int (*)(void *, char *, int), int (*)(void *, const char *, int), fpos_t (*)(void *, fpos_t, int), int (*)(void *));
}
typedef __darwin_clock_t clock_t;
typedef __darwin_time_t time_t;
struct timespec {
    __darwin_time_t tv_sec;
    long tv_nsec;
};
struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char *tm_zone;
};
extern char *tzname[];
extern int getdate_err;
extern long timezone asm("_timezone");
extern int daylight;
extern "C" {
    char *asctime(const struct tm *);
    clock_t clock() asm("_clock");
    char *ctime(const time_t *);
    double difftime(time_t, time_t);
    struct tm *getdate(const char *);
    struct tm *gmtime(const time_t *);
    struct tm *localtime(const time_t *);
    time_t mktime(struct tm *) asm("_mktime");
    size_t strftime(char *, size_t, const char *, const struct tm *) asm("_strftime");
    char *strptime(const char *, const char *, struct tm *) asm("_strptime");
    time_t time(time_t *);
    void tzset();
    char *asctime_r(const struct tm *, char *);
    char *ctime_r(const time_t *, char *);
    struct tm *gmtime_r(const time_t *, struct tm *);
    struct tm *localtime_r(const time_t *, struct tm *);
    time_t posix2time(time_t);
    void tzsetwall();
    time_t time2posix(time_t);
    time_t timelocal(struct tm *const);
    time_t timegm(struct tm *const);
    int nanosleep(const struct timespec *, struct timespec *) asm("_nanosleep");
}
typedef __darwin_wint_t wint_t;
typedef __darwin_wctype_t wctype_t;
struct {
    __darwin_rune_t __min;
    __darwin_rune_t __max;
    __darwin_rune_t __map;
    __uint32_t *__types;
} typedef _RuneEntry;
struct {
    int __nranges;
    _RuneEntry *__ranges;
} typedef _RuneRange;
struct {
    char __name[14];
    __uint32_t __mask;
} typedef _RuneCharClass;
struct {
    char __magic[8];
    char __encoding[32];
    __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, const char **);
    int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
    __darwin_rune_t __invalid_rune;
    __uint32_t __runetype[256];
    __darwin_rune_t __maplower[256];
    __darwin_rune_t __mapupper[256];
    _RuneRange __runetype_ext;
    _RuneRange __maplower_ext;
    _RuneRange __mapupper_ext;
    void *__variable;
    int __variable_len;
    int __ncharclasses;
    _RuneCharClass *__charclasses;
} typedef _RuneLocale;
extern "C" {
    extern _RuneLocale _DefaultRuneLocale;
    extern _RuneLocale *_CurrentRuneLocale;
}
extern "C" {
    unsigned long ___runetype(__darwin_ct_rune_t);
    __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
    __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}
inline int isascii(int _c) {
    return ((_c & ~127) == 0);
}


extern "C" {
    int __maskrune(__darwin_ct_rune_t, unsigned long);
}
inline int __istype(__darwin_ct_rune_t _c, unsigned long _f) {
    return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f) : !!__maskrune(_c, _f));
}


inline __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c, unsigned long _f) {
    return (_c < 0 || _c >= (1 << 8)) ? 0 : !!(_DefaultRuneLocale.__runetype[_c] & _f);
}


extern "C" {
    __darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
    __darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}
inline int __wcwidth(__darwin_ct_rune_t _c) {
    unsigned int _x;
    if (_c == 0)
        return (0);
    _x = (unsigned int)__maskrune(_c, 3758096384L | 262144L);
    if ((_x & 3758096384L) != 0)
        return ((_x & 3758096384L) >> 30);
    return ((_x & 262144L) != 0 ? 1 : -1);
}


inline int isalnum(int _c) {
    return (__istype(_c, 256L | 1024L));
}


inline int isalpha(int _c) {
    return (__istype(_c, 256L));
}


inline int isblank(int _c) {
    return (__istype(_c, 131072L));
}


inline int iscntrl(int _c) {
    return (__istype(_c, 512L));
}


inline int isdigit(int _c) {
    return (__isctype(_c, 1024L));
}


inline int isgraph(int _c) {
    return (__istype(_c, 2048L));
}


inline int islower(int _c) {
    return (__istype(_c, 4096L));
}


inline int isprint(int _c) {
    return (__istype(_c, 262144L));
}


inline int ispunct(int _c) {
    return (__istype(_c, 8192L));
}


inline int isspace(int _c) {
    return (__istype(_c, 16384L));
}


inline int isupper(int _c) {
    return (__istype(_c, 32768L));
}


inline int isxdigit(int _c) {
    return (__isctype(_c, 65536L));
}


inline int toascii(int _c) {
    return (_c & 127);
}


inline int tolower(int _c) {
    return (__tolower(_c));
}


inline int toupper(int _c) {
    return (__toupper(_c));
}


inline int digittoint(int _c) {
    return (__maskrune(_c, 15));
}


inline int ishexnumber(int _c) {
    return (__istype(_c, 65536L));
}


inline int isideogram(int _c) {
    return (__istype(_c, 524288L));
}


inline int isnumber(int _c) {
    return (__istype(_c, 1024L));
}


inline int isphonogram(int _c) {
    return (__istype(_c, 2097152L));
}


inline int isrune(int _c) {
    return (__istype(_c, 4294967280L));
}


inline int isspecial(int _c) {
    return (__istype(_c, 1048576L));
}


inline int iswalnum(wint_t _wc) {
    return (__istype(_wc, 256L | 1024L));
}


inline int iswalpha(wint_t _wc) {
    return (__istype(_wc, 256L));
}


inline int iswcntrl(wint_t _wc) {
    return (__istype(_wc, 512L));
}


inline int iswctype(wint_t _wc, wctype_t _charclass) {
    return (__istype(_wc, _charclass));
}


inline int iswdigit(wint_t _wc) {
    return (__isctype(_wc, 1024L));
}


inline int iswgraph(wint_t _wc) {
    return (__istype(_wc, 2048L));
}


inline int iswlower(wint_t _wc) {
    return (__istype(_wc, 4096L));
}


inline int iswprint(wint_t _wc) {
    return (__istype(_wc, 262144L));
}


inline int iswpunct(wint_t _wc) {
    return (__istype(_wc, 8192L));
}


inline int iswspace(wint_t _wc) {
    return (__istype(_wc, 16384L));
}


inline int iswupper(wint_t _wc) {
    return (__istype(_wc, 32768L));
}


inline int iswxdigit(wint_t _wc) {
    return (__isctype(_wc, 65536L));
}


inline wint_t towlower(wint_t _wc) {
    return (__tolower(_wc));
}


inline wint_t towupper(wint_t _wc) {
    return (__toupper(_wc));
}


extern "C" {
    wctype_t wctype(const char *);
}
extern "C" {
    wint_t btowc(int);
    wint_t fgetwc(FILE *);
    wchar_t *fgetws(wchar_t *, int, FILE *);
    wint_t fputwc(wchar_t, FILE *);
    int fputws(const wchar_t *, FILE *);
    int fwide(FILE *, int);
    int fwprintf(FILE *, const wchar_t *, ...);
    int fwscanf(FILE *, const wchar_t *, ...);
    wint_t getwc(FILE *);
    wint_t getwchar();
    size_t mbrlen(const char *, size_t, mbstate_t *);
    size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
    int mbsinit(const mbstate_t *);
    size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
    wint_t putwc(wchar_t, FILE *);
    wint_t putwchar(wchar_t);
    int swprintf(wchar_t *, size_t, const wchar_t *, ...);
    int swscanf(const wchar_t *, const wchar_t *, ...);
    wint_t ungetwc(wint_t, FILE *);
    int vfwprintf(FILE *, const wchar_t *, __darwin_va_list);
    int vswprintf(wchar_t *, size_t, const wchar_t *, __darwin_va_list);
    int vwprintf(const wchar_t *, __darwin_va_list);
    size_t wcrtomb(char *, wchar_t, mbstate_t *);
    wchar_t *wcscat(wchar_t *, const wchar_t *);
    wchar_t *wcschr(const wchar_t *, wchar_t);
    int wcscmp(const wchar_t *, const wchar_t *);
    int wcscoll(const wchar_t *, const wchar_t *);
    wchar_t *wcscpy(wchar_t *, const wchar_t *);
    size_t wcscspn(const wchar_t *, const wchar_t *);
    size_t wcsftime(wchar_t *, size_t, const wchar_t *, const struct tm *) asm("_wcsftime");
    size_t wcslen(const wchar_t *);
    wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t);
    int wcsncmp(const wchar_t *, const wchar_t *, size_t);
    wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
    wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
    wchar_t *wcsrchr(const wchar_t *, wchar_t);
    size_t wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
    size_t wcsspn(const wchar_t *, const wchar_t *);
    wchar_t *wcsstr(const wchar_t *, const wchar_t *);
    size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
    int wctob(wint_t);
    double wcstod(const wchar_t *, wchar_t **);
    wchar_t *wcstok(wchar_t *, const wchar_t *, wchar_t **);
    long wcstol(const wchar_t *, wchar_t **, int);
    unsigned long wcstoul(const wchar_t *, wchar_t **, int);
    wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
    int wmemcmp(const wchar_t *, const wchar_t *, size_t);
    wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t);
    wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
    wchar_t *wmemset(wchar_t *, wchar_t, size_t);
    int wprintf(const wchar_t *, ...);
    int wscanf(const wchar_t *, ...);
    int wcswidth(const wchar_t *, size_t);
    int wcwidth(wchar_t);
}
extern "C" {
    int vfwscanf(FILE *, const wchar_t *, __darwin_va_list);
    int vswscanf(const wchar_t *, const wchar_t *, __darwin_va_list);
    int vwscanf(const wchar_t *, __darwin_va_list);
    float wcstof(const wchar_t *, wchar_t **);
    long double wcstold(const wchar_t *, wchar_t **);
    long long wcstoll(const wchar_t *, wchar_t **, int);
    unsigned long long wcstoull(const wchar_t *, wchar_t **, int);
}
extern "C" {
    size_t mbsnrtowcs(wchar_t *, const char **, size_t, size_t, mbstate_t *);
    wchar_t *wcpcpy(wchar_t *, const wchar_t *) __attribute__((availability(macos, introduced=10.7)));
    wchar_t *wcpncpy(wchar_t *, const wchar_t *, size_t) __attribute__((availability(macos, introduced=10.7)));
    wchar_t *wcsdup(const wchar_t *) __attribute__((availability(macos, introduced=10.7)));
    int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((availability(macos, introduced=10.7)));
    int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((availability(macos, introduced=10.7)));
    size_t wcsnlen(const wchar_t *, size_t) __attribute__((availability(macos, introduced=10.7)));
    size_t wcsnrtombs(char *, const wchar_t **, size_t, size_t, mbstate_t *);
}
extern "C" {
    wchar_t *fgetwln(FILE *, size_t *) __attribute__((availability(macos, introduced=10.7)));
    size_t wcslcat(wchar_t *, const wchar_t *, size_t);
    size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
namespace std {
    inline namespace __1 {
        class __attribute__((type_visibility("default"))) ios_base;
        template <class _CharT = char> struct __attribute__((type_visibility("default"))) char_traits {
            typedef char char_type;
            typedef int int_type;
            typedef streamoff off_type;
            typedef streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return (unsigned char)__c1 < (unsigned char)__c2;
            }


            static inline int compare(const char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? 0 : memcmp(__s1, __s2, __n);
            }


            static inline size_t length(const char_type *__s)             {
                return strlen(__s);
            }


            static inline const char_type *find(const char_type *__s, size_t __n, const char_type &__a)             {
                return __n == 0 ? __null : (const char_type *)memchr(__s, to_int_type(__a), __n);
            }


            static inline char_type *move(char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? __s1 : (char_type *)memmove(__s1, __s2, __n);
            }


            static inline char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)             {
                ((void)0);
                return __n == 0 ? __s1 : (char_type *)memcpy(__s1, __s2, __n);
            }


            static inline char_type *assign(char_type *__s, size_t __n, char_type __a)             {
                return __n == 0 ? __s : (char_type *)memset(__s, to_int_type(__a), __n);
            }


            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type((unsigned char)__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type((-1));
            }


        }
template <class _CharT = wchar_t> struct __attribute__((type_visibility("default"))) char_traits {
            typedef wchar_t char_type;
            typedef wint_t int_type;
            typedef streamoff off_type;
            typedef streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static inline int compare(const char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? 0 : wmemcmp(__s1, __s2, __n);
            }


            static inline size_t length(const char_type *__s)             {
                return wcslen(__s);
            }


            static inline const char_type *find(const char_type *__s, size_t __n, const char_type &__a)             {
                return __n == 0 ? __null : (const char_type *)wmemchr(__s, __a, __n);
            }


            static inline char_type *move(char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? __s1 : (char_type *)wmemmove(__s1, __s2, __n);
            }


            static inline char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)             {
                ((void)0);
                return __n == 0 ? __s1 : (char_type *)wmemcpy(__s1, __s2, __n);
            }


            static inline char_type *assign(char_type *__s, size_t __n, char_type __a)             {
                return __n == 0 ? __s : (char_type *)wmemset(__s, __a, __n);
            }


            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type(((__darwin_wint_t)-1));
            }


        }
template <class _CharT = char16_t> struct __attribute__((type_visibility("default"))) char_traits {
            typedef char16_t char_type;
            typedef uint_least16_t int_type;
            typedef streamoff off_type;
            typedef u16streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static int compare(const char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type(65535);
            }


        }
template <class _CharT = char32_t> struct __attribute__((type_visibility("default"))) char_traits {
            typedef char32_t char_type;
            typedef uint_least32_t int_type;
            typedef streamoff off_type;
            typedef u32streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static int compare(const char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type(4294967295U);
            }


        }
template <class _CharT> struct __attribute__((type_visibility("default"))) char_traits;
        template <class _Tp = char> class allocator {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef char *pointer;
            typedef const char *const_pointer;
            typedef char &reference;
            typedef const char &const_reference;
            typedef char value_type;
            typedef true_type propagate_on_container_move_assignment;
            typedef true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() noexcept __attribute__((always_inline))             {
            }


            template <class _Up = char> allocator(const allocator<char> &) noexcept __attribute__((always_inline))template <class _Up> allocator(const allocator<_Up> &) noexcept __attribute__((always_inline));
            pointer address(reference __x) const noexcept __attribute__((always_inline));
            const_pointer address(const_reference __x) const noexcept __attribute__((always_inline));
            pointer allocate(size_type __n, allocator<void>::const_pointer) __attribute__((always_inline));
            void deallocate(pointer __p, size_type) noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            template <class _Up, class ..._Args> void construct(_Up *__p, _Args &&...__args) __attribute__((always_inline));
            void destroy(pointer __p) __attribute__((always_inline));
        }
template <class _Tp = wchar_t> class allocator {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef wchar_t *pointer;
            typedef const wchar_t *const_pointer;
            typedef wchar_t &reference;
            typedef const wchar_t &const_reference;
            typedef wchar_t value_type;
            typedef true_type propagate_on_container_move_assignment;
            typedef true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() noexcept __attribute__((always_inline));
            template <class _Up = wchar_t> allocator(const allocator<wchar_t> &) noexcept __attribute__((always_inline))template <class _Up> allocator(const allocator<_Up> &) noexcept __attribute__((always_inline));
            pointer address(reference __x) const noexcept __attribute__((always_inline));
            const_pointer address(const_reference __x) const noexcept __attribute__((always_inline));
            pointer allocate(size_type __n, allocator<void>::const_pointer) __attribute__((always_inline));
            void deallocate(pointer __p, size_type) noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            template <class _Up, class ..._Args> void construct(_Up *__p, _Args &&...__args) __attribute__((always_inline));
            void destroy(pointer __p) __attribute__((always_inline));
        }
template <class _Tp = void> class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef void *pointer;
            typedef const void *const_pointer;
            typedef void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        }
template <class _Tp = const void> class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef const void *pointer;
            typedef const void *const_pointer;
            typedef const void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        }
template <class _Tp = char16_t> class allocator
template <class _Tp = char32_t> class allocator
template <class _Tp> class __attribute__((type_visibility("default"))) allocator;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_ios : public std::__1::ios_base {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit operator bool() const __attribute__((always_inline));
            bool operator!() const __attribute__((always_inline));
            iostate rdstate() const __attribute__((always_inline));
            void clear(iostate __state) __attribute__((always_inline));
            void setstate(iostate __state) __attribute__((always_inline))             {
                this->ios_base::setstate(__state);
            }


            bool good() const __attribute__((always_inline));
            bool eof() const __attribute__((always_inline));
            bool fail() const __attribute__((always_inline));
            bool bad() const __attribute__((always_inline));
            iostate exceptions() const __attribute__((always_inline));
            void exceptions(iostate __iostate) __attribute__((always_inline));
            explicit basic_ios(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ios<char>() noexcept;
            basic_ostream<char_type, traits_type> *tie() const __attribute__((always_inline));
            basic_ostream<char_type, traits_type> *tie(basic_ostream<char_type, traits_type> *__tiestr) __attribute__((always_inline));
            basic_streambuf<char_type, traits_type> *rdbuf() const __attribute__((always_inline))             {
                return static_cast<basic_streambuf<char_type, traits_type> *>(this->ios_base::rdbuf());
            }


            basic_streambuf<char_type, traits_type> *rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            std::__1::basic_ios<char> &copyfmt(const std::__1::basic_ios<char> &__rhs);
            char_type fill() const __attribute__((always_inline))             {
                if (traits_type::eq_int_type(traits_type::eof(), this->__fill_))
                    this->__fill_ = this->widen(' ');
                return this->__fill_;
            }


            char_type fill(char_type __ch) __attribute__((always_inline));
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((always_inline));
            char narrow(char_type __c, char __dfault) const __attribute__((always_inline));
            char_type widen(char __c) const __attribute__((always_inline))             {
                return use_facet<ctype<char_type> >(this->getloc()).widen(__c);
            }


        protected:
            basic_ios() __attribute__((always_inline));
            void init(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            void move(std::__1::basic_ios<char> &__rhs) __attribute__((always_inline));
            void move(std::__1::basic_ios<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ios<char> &__rhs) noexcept __attribute__((always_inline));
            void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
        private:
            basic_ostream<char_type, traits_type> *__tie_;
            mutable int_type __fill_;
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class __attribute__((type_visibility("default"))) basic_ios : public std::__1::ios_base {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit operator bool() const __attribute__((always_inline));
            bool operator!() const __attribute__((always_inline));
            iostate rdstate() const __attribute__((always_inline));
            void clear(iostate __state) __attribute__((always_inline));
            void setstate(iostate __state) __attribute__((always_inline));
            bool good() const __attribute__((always_inline));
            bool eof() const __attribute__((always_inline));
            bool fail() const __attribute__((always_inline));
            bool bad() const __attribute__((always_inline));
            iostate exceptions() const __attribute__((always_inline));
            void exceptions(iostate __iostate) __attribute__((always_inline));
            explicit basic_ios(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ios<wchar_t>() noexcept;
            basic_ostream<char_type, traits_type> *tie() const __attribute__((always_inline));
            basic_ostream<char_type, traits_type> *tie(basic_ostream<char_type, traits_type> *__tiestr) __attribute__((always_inline));
            basic_streambuf<char_type, traits_type> *rdbuf() const __attribute__((always_inline));
            basic_streambuf<char_type, traits_type> *rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            std::__1::basic_ios<wchar_t> &copyfmt(const std::__1::basic_ios<wchar_t> &__rhs);
            char_type fill() const __attribute__((always_inline));
            char_type fill(char_type __ch) __attribute__((always_inline));
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((always_inline));
            char narrow(char_type __c, char __dfault) const __attribute__((always_inline));
            char_type widen(char __c) const __attribute__((always_inline));
        protected:
            basic_ios() __attribute__((always_inline));
            void init(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            void move(std::__1::basic_ios<wchar_t> &__rhs) __attribute__((always_inline));
            void move(std::__1::basic_ios<wchar_t> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ios<wchar_t> &__rhs) noexcept __attribute__((always_inline));
            void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
        private:
            basic_ostream<char_type, traits_type> *__tie_;
            mutable int_type __fill_;
        }
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ios;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_streambuf {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            virtual ~std::__1::basic_streambuf<char>();
            std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((always_inline));
            std::__1::locale getloc() const __attribute__((always_inline));
            std::__1::basic_streambuf<char> *pubsetbuf(char_type *__s, streamsize __n) __attribute__((always_inline));
            pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which) __attribute__((always_inline));
            pos_type pubseekpos(pos_type __sp, ios_base::openmode __which) __attribute__((always_inline));
            int pubsync() __attribute__((always_inline));
            streamsize in_avail() __attribute__((always_inline));
            int_type snextc() __attribute__((always_inline));
            int_type sbumpc() __attribute__((always_inline));
            int_type sgetc() __attribute__((always_inline));
            streamsize sgetn(char_type *__s, streamsize __n) __attribute__((always_inline));
            int_type sputbackc(char_type __c) __attribute__((always_inline));
            int_type sungetc() __attribute__((always_inline));
            int_type sputc(char_type __c) __attribute__((always_inline));
            streamsize sputn(const char_type *__s, streamsize __n) __attribute__((always_inline))             {
                return this->xsputn(__s, __n);
            }


        protected:
            basic_streambuf();
            basic_streambuf(const std::__1::basic_streambuf<char> &__rhs);
            std::__1::basic_streambuf<char> &operator=(const std::__1::basic_streambuf<char> &__rhs);
            void swap(std::__1::basic_streambuf<char> &__rhs);
            char_type *eback() const __attribute__((always_inline));
            char_type *gptr() const __attribute__((always_inline));
            char_type *egptr() const __attribute__((always_inline));
            void gbump(int __n) __attribute__((always_inline));
            void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) __attribute__((always_inline));
            char_type *pbase() const __attribute__((always_inline));
            char_type *pptr() const __attribute__((always_inline));
            char_type *epptr() const __attribute__((always_inline));
            void pbump(int __n) __attribute__((always_inline));
            void setp(char_type *__pbeg, char_type *__pend) __attribute__((always_inline));
            virtual void imbue(const std::__1::locale &__loc);
            virtual std::__1::basic_streambuf<char> *setbuf(char_type *__s, streamsize __n);
            virtual pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which);
            virtual pos_type seekpos(pos_type __sp, ios_base::openmode __which);
            virtual int sync();
            virtual streamsize showmanyc();
            virtual streamsize xsgetn(char_type *__s, streamsize __n);
            virtual int_type underflow();
            virtual int_type uflow();
            virtual int_type pbackfail(int_type __c);
            virtual streamsize xsputn(const char_type *__s, streamsize __n);
            virtual int_type overflow(int_type __c);
        private:
            std::__1::locale __loc_;
            char_type *__binp_;
            char_type *__ninp_;
            char_type *__einp_;
            char_type *__bout_;
            char_type *__nout_;
            char_type *__eout_;
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class __attribute__((type_visibility("default"))) basic_streambuf {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            virtual ~std::__1::basic_streambuf<wchar_t>();
            std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((always_inline));
            std::__1::locale getloc() const __attribute__((always_inline));
            std::__1::basic_streambuf<wchar_t> *pubsetbuf(char_type *__s, streamsize __n) __attribute__((always_inline));
            pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which) __attribute__((always_inline));
            pos_type pubseekpos(pos_type __sp, ios_base::openmode __which) __attribute__((always_inline));
            int pubsync() __attribute__((always_inline));
            streamsize in_avail() __attribute__((always_inline));
            int_type snextc() __attribute__((always_inline));
            int_type sbumpc() __attribute__((always_inline));
            int_type sgetc() __attribute__((always_inline));
            streamsize sgetn(char_type *__s, streamsize __n) __attribute__((always_inline));
            int_type sputbackc(char_type __c) __attribute__((always_inline));
            int_type sungetc() __attribute__((always_inline));
            int_type sputc(char_type __c) __attribute__((always_inline));
            streamsize sputn(const char_type *__s, streamsize __n) __attribute__((always_inline));
        protected:
            basic_streambuf();
            basic_streambuf(const std::__1::basic_streambuf<wchar_t> &__rhs);
            std::__1::basic_streambuf<wchar_t> &operator=(const std::__1::basic_streambuf<wchar_t> &__rhs);
            void swap(std::__1::basic_streambuf<wchar_t> &__rhs);
            char_type *eback() const __attribute__((always_inline));
            char_type *gptr() const __attribute__((always_inline));
            char_type *egptr() const __attribute__((always_inline));
            void gbump(int __n) __attribute__((always_inline));
            void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) __attribute__((always_inline));
            char_type *pbase() const __attribute__((always_inline));
            char_type *pptr() const __attribute__((always_inline));
            char_type *epptr() const __attribute__((always_inline));
            void pbump(int __n) __attribute__((always_inline));
            void setp(char_type *__pbeg, char_type *__pend) __attribute__((always_inline));
            virtual void imbue(const std::__1::locale &__loc);
            virtual std::__1::basic_streambuf<wchar_t> *setbuf(char_type *__s, streamsize __n);
            virtual pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which);
            virtual pos_type seekpos(pos_type __sp, ios_base::openmode __which);
            virtual int sync();
            virtual streamsize showmanyc();
            virtual streamsize xsgetn(char_type *__s, streamsize __n);
            virtual int_type underflow();
            virtual int_type uflow();
            virtual int_type pbackfail(int_type __c);
            virtual streamsize xsputn(const char_type *__s, streamsize __n);
            virtual int_type overflow(int_type __c);
        private:
            std::__1::locale __loc_;
            char_type *__binp_;
            char_type *__ninp_;
            char_type *__einp_;
            char_type *__bout_;
            char_type *__nout_;
            char_type *__eout_;
        }
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_streambuf;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_istream : virtual public basic_ios<char, std::__1::char_traits<char> > {
            streamsize __gc_;
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_istream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_istream<char>() noexcept;
        protected:
            basic_istream(std::__1::basic_istream<char> &&__rhs) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator=(std::__1::basic_istream<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_istream<char> &__rhs) __attribute__((always_inline));
        public:
            class sentry {
                bool __ok_;
                sentry(const std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &);
                std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &operator=(const std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &);
            public:
                explicit sentry(basic_istream<char, std::__1::char_traits<char> > &__is, bool __noskipws);
                explicit operator bool() const __attribute__((always_inline));
            };
            std::__1::basic_istream<char> &operator>>(std::__1::basic_istream<char> &(*__pf)(std::__1::basic_istream<char> &)) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator>>(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator>>(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_istream<char> &operator>>(bool &__n);
            std::__1::basic_istream<char> &operator>>(short &__n);
            std::__1::basic_istream<char> &operator>>(unsigned short &__n);
            std::__1::basic_istream<char> &operator>>(int &__n);
            std::__1::basic_istream<char> &operator>>(unsigned int &__n);
            std::__1::basic_istream<char> &operator>>(long &__n);
            std::__1::basic_istream<char> &operator>>(unsigned long &__n);
            std::__1::basic_istream<char> &operator>>(long long &__n);
            std::__1::basic_istream<char> &operator>>(unsigned long long &__n);
            std::__1::basic_istream<char> &operator>>(float &__f);
            std::__1::basic_istream<char> &operator>>(double &__f);
            std::__1::basic_istream<char> &operator>>(long double &__f);
            std::__1::basic_istream<char> &operator>>(void *&__p);
            streamsize gcount() const __attribute__((always_inline));
            int_type get();
            std::__1::basic_istream<char> &get(char_type &__c) __attribute__((always_inline));
            std::__1::basic_istream<char> &get(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<char> &get(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<char> &get(basic_streambuf<char_type, traits_type> &__sb) __attribute__((always_inline));
            std::__1::basic_istream<char> &get(basic_streambuf<char_type, traits_type> &__sb, char_type __dlm);
            std::__1::basic_istream<char> &getline(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<char> &getline(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<char> &ignore(streamsize __n, int_type __dlm);
            int_type peek();
            std::__1::basic_istream<char> &read(char_type *__s, streamsize __n);
            streamsize readsome(char_type *__s, streamsize __n);
            std::__1::basic_istream<char> &putback(char_type __c);
            std::__1::basic_istream<char> &unget();
            int sync();
            pos_type tellg();
            std::__1::basic_istream<char> &seekg(pos_type __pos);
            std::__1::basic_istream<char> &seekg(off_type __off, ios_base::seekdir __dir);
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class __attribute__((type_visibility("default"))) basic_istream : virtual public basic_ios<wchar_t, std::__1::char_traits<wchar_t> > {
            streamsize __gc_;
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_istream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_istream<wchar_t>() noexcept;
        protected:
            basic_istream(std::__1::basic_istream<wchar_t> &&__rhs) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator=(std::__1::basic_istream<wchar_t> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_istream<wchar_t> &__rhs) __attribute__((always_inline));
        public:
            class sentry {
                bool __ok_;
                sentry(const std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
                std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &operator=(const std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
            public:
                explicit sentry(basic_istream<wchar_t, std::__1::char_traits<wchar_t> > &__is, bool __noskipws);
                explicit operator bool() const __attribute__((always_inline));
            };
            std::__1::basic_istream<wchar_t> &operator>>(std::__1::basic_istream<wchar_t> &(*__pf)(std::__1::basic_istream<wchar_t> &)) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator>>(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator>>(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_istream<wchar_t> &operator>>(bool &__n);
            std::__1::basic_istream<wchar_t> &operator>>(short &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned short &__n);
            std::__1::basic_istream<wchar_t> &operator>>(int &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned int &__n);
            std::__1::basic_istream<wchar_t> &operator>>(long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(long long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned long long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(float &__f);
            std::__1::basic_istream<wchar_t> &operator>>(double &__f);
            std::__1::basic_istream<wchar_t> &operator>>(long double &__f);
            std::__1::basic_istream<wchar_t> &operator>>(void *&__p);
            streamsize gcount() const __attribute__((always_inline));
            int_type get();
            std::__1::basic_istream<wchar_t> &get(char_type &__c) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &get(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &get(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<wchar_t> &get(basic_streambuf<char_type, traits_type> &__sb) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &get(basic_streambuf<char_type, traits_type> &__sb, char_type __dlm);
            std::__1::basic_istream<wchar_t> &getline(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &getline(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<wchar_t> &ignore(streamsize __n, int_type __dlm);
            int_type peek();
            std::__1::basic_istream<wchar_t> &read(char_type *__s, streamsize __n);
            streamsize readsome(char_type *__s, streamsize __n);
            std::__1::basic_istream<wchar_t> &putback(char_type __c);
            std::__1::basic_istream<wchar_t> &unget();
            int sync();
            pos_type tellg();
            std::__1::basic_istream<wchar_t> &seekg(pos_type __pos);
            std::__1::basic_istream<wchar_t> &seekg(off_type __off, ios_base::seekdir __dir);
        }
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_istream;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_ostream : virtual public basic_ios<char, std::__1::char_traits<char> > {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_ostream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ostream<char>() noexcept;
        protected:
            basic_ostream(std::__1::basic_ostream<char> &&__rhs) __attribute__((always_inline));
            std::__1::basic_ostream<char> &operator=(std::__1::basic_ostream<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ostream<char> &__rhs) __attribute__((always_inline));
            basic_ostream(const std::__1::basic_ostream<char> &__rhs) = delete
            std::__1::basic_ostream<char> &operator=(const std::__1::basic_ostream<char> &__rhs) = delete
        public:
            class sentry {
                bool __ok_;
                basic_ostream<char, std::__1::char_traits<char> > &__os_;
                sentry(const std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &);
                std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &operator=(const std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &);
            public:
                explicit sentry(basic_ostream<char, std::__1::char_traits<char> > &__os);
                ~std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry() noexcept;
                explicit operator bool() const __attribute__((always_inline))                 {
                    return this->__ok_;
                }


            };
            std::__1::basic_ostream<char> &operator<<(std::__1::basic_ostream<char> &(*__pf)(std::__1::basic_ostream<char> &)) __attribute__((always_inline))             {
                return __pf(*this);
            }


            std::__1::basic_ostream<char> &operator<<(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_ostream<char> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline))             {
                __pf(*this);
                return *this;
            }


            std::__1::basic_ostream<char> &operator<<(bool __n);
            std::__1::basic_ostream<char> &operator<<(short __n);
            std::__1::basic_ostream<char> &operator<<(unsigned short __n);
            std::__1::basic_ostream<char> &operator<<(int __n);
            std::__1::basic_ostream<char> &operator<<(unsigned int __n);
            std::__1::basic_ostream<char> &operator<<(long __n);
            std::__1::basic_ostream<char> &operator<<(unsigned long __n);
            std::__1::basic_ostream<char> &operator<<(long long __n);
            std::__1::basic_ostream<char> &operator<<(unsigned long long __n);
            std::__1::basic_ostream<char> &operator<<(float __f);
            std::__1::basic_ostream<char> &operator<<(double __f);
            std::__1::basic_ostream<char> &operator<<(long double __f);
            std::__1::basic_ostream<char> &operator<<(const void *__p);
            std::__1::basic_ostream<char> &operator<<(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_ostream<char> &put(char_type __c);
            std::__1::basic_ostream<char> &write(const char_type *__s, streamsize __n);
            std::__1::basic_ostream<char> &flush();
            pos_type tellp() __attribute__((always_inline));
            std::__1::basic_ostream<char> &seekp(pos_type __pos) __attribute__((always_inline));
            std::__1::basic_ostream<char> &seekp(off_type __off, ios_base::seekdir __dir) __attribute__((always_inline));
        protected:
            basic_ostream() __attribute__((always_inline));
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class __attribute__((type_visibility("default"))) basic_ostream : virtual public basic_ios<wchar_t, std::__1::char_traits<wchar_t> > {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_ostream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ostream<wchar_t>() noexcept;
        protected:
            basic_ostream(std::__1::basic_ostream<wchar_t> &&__rhs) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator=(std::__1::basic_ostream<wchar_t> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ostream<wchar_t> &__rhs) __attribute__((always_inline));
            basic_ostream(const std::__1::basic_ostream<wchar_t> &__rhs) = delete
            std::__1::basic_ostream<wchar_t> &operator=(const std::__1::basic_ostream<wchar_t> &__rhs) = delete
        public:
            class sentry {
                bool __ok_;
                basic_ostream<wchar_t, std::__1::char_traits<wchar_t> > &__os_;
                sentry(const std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
                std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &operator=(const std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
            public:
                explicit sentry(basic_ostream<wchar_t, std::__1::char_traits<wchar_t> > &__os);
                ~std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry();
                explicit operator bool() const __attribute__((always_inline));
            };
            std::__1::basic_ostream<wchar_t> &operator<<(std::__1::basic_ostream<wchar_t> &(*__pf)(std::__1::basic_ostream<wchar_t> &)) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator<<(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator<<(bool __n);
            std::__1::basic_ostream<wchar_t> &operator<<(short __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned short __n);
            std::__1::basic_ostream<wchar_t> &operator<<(int __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned int __n);
            std::__1::basic_ostream<wchar_t> &operator<<(long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(long long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned long long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(float __f);
            std::__1::basic_ostream<wchar_t> &operator<<(double __f);
            std::__1::basic_ostream<wchar_t> &operator<<(long double __f);
            std::__1::basic_ostream<wchar_t> &operator<<(const void *__p);
            std::__1::basic_ostream<wchar_t> &operator<<(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_ostream<wchar_t> &put(char_type __c);
            std::__1::basic_ostream<wchar_t> &write(const char_type *__s, streamsize __n);
            std::__1::basic_ostream<wchar_t> &flush();
            pos_type tellp() __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &seekp(pos_type __pos) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &seekp(off_type __off, ios_base::seekdir __dir) __attribute__((always_inline));
        protected:
            basic_ostream() __attribute__((always_inline));
        }
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ostream;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_iostream : public basic_istream<char, std::__1::char_traits<char> >, public basic_ostream<char, std::__1::char_traits<char> > {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_iostream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_iostream<char>() noexcept;
        protected:
            basic_iostream(std::__1::basic_iostream<char> &&__rhs) __attribute__((always_inline));
            std::__1::basic_iostream<char> &operator=(std::__1::basic_iostream<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_iostream<char> &__rhs) __attribute__((always_inline));
        public:
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class basic_iostream
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_iostream;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> class basic_stringbuf
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> class basic_stringbuf
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_stringbuf;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> class basic_istringstream
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> class basic_istringstream
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_istringstream;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> class basic_ostringstream
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> class basic_ostringstream
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_ostringstream;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> class basic_stringstream
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> class basic_stringstream
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_stringstream;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class basic_filebuf
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class basic_filebuf
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_filebuf;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class basic_ifstream
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class basic_ifstream
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ifstream;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class basic_ofstream
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class basic_ofstream
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ofstream;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class basic_fstream
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class basic_fstream
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_fstream;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class istreambuf_iterator
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class istreambuf_iterator
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) istreambuf_iterator;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class ostreambuf_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::__1::char_traits<char> > streambuf_type;
            typedef basic_ostream<char, std::__1::char_traits<char> > ostream_type;
        private:
            streambuf_type *__sbuf_;
        public:
            ostreambuf_iterator(ostream_type &__s) noexcept : iterator<std::__1::output_iterator_tag, void, void, void, void>(), __sbuf_(__s.rdbuf()) __attribute__((always_inline))             {
            }


            ostreambuf_iterator(streambuf_type *__s) noexcept __attribute__((always_inline));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator=(char __c) __attribute__((always_inline));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator*() __attribute__((always_inline));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator++() __attribute__((always_inline));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator++(int) __attribute__((always_inline));
            bool failed() const noexcept __attribute__((always_inline))             {
                return this->__sbuf_ == 0;
            }


            friend template <class _Ch = char, class _Tr = std::__1::char_traits<char>> ostreambuf_iterator<char, std::__1::char_traits<char> > __pad_and_output(ostreambuf_iterator<char, std::__1::char_traits<char> > __s, const char *__ob, const char *__op, const char *__oe, std::__1::ios_base &__iob, char __fl)             {
                if (__s.__sbuf_ == nullptr)
                    return __s;
                streamsize __sz = __oe - __ob;
                streamsize __ns = __iob.width();
                if (__ns > __sz)
                    __ns -= __sz;
                else
                    __ns = 0;
                streamsize __np = __op - __ob;
                if (__np > 0) {
                    if (__s.__sbuf_->sputn(__ob, __np) != __np) {
                        __s.__sbuf_ = nullptr;
                        return __s;
                    }
                }
                if (__ns > 0) {
                    basic_string<char, std::__1::char_traits<char> > __sp(__ns, __fl);
                    if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns) {
                        __s.__sbuf_ = nullptr;
                        return __s;
                    }
                }
                __np = __oe - __op;
                if (__np > 0) {
                    if (__s.__sbuf_->sputn(__op, __np) != __np) {
                        __s.__sbuf_ = nullptr;
                        return __s;
                    }
                }
                __iob.width(0);
                return __s;
            }

template <class _Ch, class _Tr> ostreambuf_iterator<_Ch, _Tr> __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s, const _Ch *__ob, const _Ch *__op, const _Ch *__oe, std::__1::ios_base &__iob, _Ch __fl) __attribute__((visibility("hidden")));
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class ostreambuf_iterator
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) ostreambuf_iterator;
        typedef basic_ios<char> ios;
        typedef basic_ios<wchar_t> wios;
        typedef basic_streambuf<char> streambuf;
        typedef basic_istream<char> istream;
        typedef basic_ostream<char> ostream;
        typedef basic_iostream<char> iostream;
        typedef basic_stringbuf<char> stringbuf;
        typedef basic_istringstream<char> istringstream;
        typedef basic_ostringstream<char> ostringstream;
        typedef basic_stringstream<char> stringstream;
        typedef basic_filebuf<char> filebuf;
        typedef basic_ifstream<char> ifstream;
        typedef basic_ofstream<char> ofstream;
        typedef basic_fstream<char> fstream;
        typedef basic_streambuf<wchar_t> wstreambuf;
        typedef basic_istream<wchar_t> wistream;
        typedef basic_ostream<wchar_t> wostream;
        typedef basic_iostream<wchar_t> wiostream;
        typedef basic_stringbuf<wchar_t> wstringbuf;
        typedef basic_istringstream<wchar_t> wistringstream;
        typedef basic_ostringstream<wchar_t> wostringstream;
        typedef basic_stringstream<wchar_t> wstringstream;
        typedef basic_filebuf<wchar_t> wfilebuf;
        typedef basic_ifstream<wchar_t> wifstream;
        typedef basic_ofstream<wchar_t> wofstream;
        typedef basic_fstream<wchar_t> wfstream;
        template <class _State = __mbstate_t> class fpos
template <class _State> class __attribute__((type_visibility("default"))) fpos;
        typedef fpos<mbstate_t> streampos;
        typedef fpos<mbstate_t> wstreampos;
        typedef fpos<mbstate_t> u16streampos;
        typedef fpos<mbstate_t> u32streampos;
        typedef long long streamoff;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> class __attribute__((type_visibility("default"))) basic_string : private __basic_string_common<true> {
        public:
            typedef std::__1::basic_string<char> __self;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::char_type value_type;
            typedef std::__1::allocator<char> allocator_type;
            typedef allocator_traits<allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef value_type &reference;
            typedef const value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
            static_assert((is_same<char, value_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<pointer> iterator;
            typedef __wrap_iter<const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                size_type __cap_;
                size_type __size_;
                pointer __data_;
            };
            enum  {
                __short_mask = 1
            };
            enum  {
                __long_mask = 1UL
            };
            enum  {
                __min_cap = (sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long) - 1) / sizeof(value_type) > 2 ? (sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long) - 1) / sizeof(value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    value_type __lx;
                };
                value_type __data_[23];
            };
            union __ulx {
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long __lx;
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__ulx) / sizeof(size_type)
            };
            struct __raw {
                size_type __words[3];
            };
            struct __rep {
                union {
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long __l;
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__short __s;
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, allocator_type> __r_;
        public:
            static const size_type npos = -1;
            basic_string() __attribute__((always_inline));
            explicit basic_string(const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<char> &__str);
            basic_string(const std::__1::basic_string<char> &__str, const allocator_type &__a);
            basic_string(std::__1::basic_string<char> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::valuebasic_string(std::__1::basic_string<char> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::value) : __basic_string_common<true>(), __r_(std::__1::move(__str.__r_)) __attribute__((always_inline))             {
                __str.__zero();
            }


            basic_string(std::__1::basic_string<char> &&__str, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s) __attribute__((always_inline));
            basic_string(const value_type *__s, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n, const allocator_type &__a) __attribute__((always_inline));
            basic_string(size_type __n, value_type __c) : __basic_string_common<true>(), __r_() __attribute__((always_inline))             {
                this->__init(__n, __c);
            }


            basic_string(size_type __n, value_type __c, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<char> &__str, size_type __pos, size_type __n, const allocator_type &__a);
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last) __attribute__((always_inline));
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last, const allocator_type &__a) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il, const allocator_type &__a) __attribute__((always_inline));
            ~std::__1::basic_string<char>() noexcept;
            std::__1::basic_string<char> &operator=(const std::__1::basic_string<char> &__str);
            std::__1::basic_string<char> &operator=(std::__1::basic_string<char> &&__str) __attribute__((always_inline));
            std::__1::basic_string<char> &operator=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<char> &operator=(value_type __c);
            std::__1::basic_string<char> &operator=(initializer_list<value_type> __il) __attribute__((always_inline));
            iterator begin() noexcept __attribute__((always_inline));
            const_iterator begin() const noexcept __attribute__((always_inline));
            iterator end() noexcept __attribute__((always_inline));
            const_iterator end() const noexcept __attribute__((always_inline));
            reverse_iterator rbegin() noexcept __attribute__((always_inline));
            const_reverse_iterator rbegin() const noexcept __attribute__((always_inline));
            reverse_iterator rend() noexcept __attribute__((always_inline));
            const_reverse_iterator rend() const noexcept __attribute__((always_inline));
            const_iterator cbegin() const noexcept __attribute__((always_inline));
            const_iterator cend() const noexcept __attribute__((always_inline));
            const_reverse_iterator crbegin() const noexcept __attribute__((always_inline));
            const_reverse_iterator crend() const noexcept __attribute__((always_inline));
            size_type size() const noexcept __attribute__((always_inline));
            size_type length() const noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            size_type capacity() const noexcept __attribute__((always_inline));
            void resize(size_type __n, value_type __c);
            void resize(size_type __n) __attribute__((always_inline));
            void reserve(size_type res_arg);
            void shrink_to_fit() noexcept __attribute__((always_inline));
            void clear() noexcept __attribute__((always_inline));
            bool empty() const noexcept __attribute__((always_inline));
            const_reference operator[](size_type __pos) const __attribute__((always_inline));
            reference operator[](size_type __pos) __attribute__((always_inline));
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__1::basic_string<char> &operator+=(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &operator+=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<char> &operator+=(value_type __c) __attribute__((always_inline));
            std::__1::basic_string<char> &operator+=(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<char> &append(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &append(const std::__1::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<char> &append(const value_type *__s, size_type __n);
            std::__1::basic_string<char> &append(const value_type *__s);
            std::__1::basic_string<char> &append(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<char> &>::type append(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<char> &>::type append(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<char> &append(initializer_list<value_type> __il) __attribute__((always_inline));
            void push_back(value_type __c);
            void pop_back() __attribute__((always_inline));
            reference front() __attribute__((always_inline));
            const_reference front() const __attribute__((always_inline));
            reference back() __attribute__((always_inline));
            const_reference back() const __attribute__((always_inline));
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &assign(std::__1::basic_string<char> &&str) __attribute__((always_inline));
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<char> &assign(const value_type *__s, size_type __n);
            std::__1::basic_string<char> &assign(const value_type *__s);
            std::__1::basic_string<char> &assign(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<char> &>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<char> &>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<char> &assign(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<char> &insert(size_type __pos1, const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &insert(size_type __pos1, const std::__1::basic_string<char> &__str, size_type __pos2, size_type __n);
            std::__1::basic_string<char> &insert(size_type __pos, const value_type *__s, size_type __n);
            std::__1::basic_string<char> &insert(size_type __pos, const value_type *__s);
            std::__1::basic_string<char> &insert(size_type __pos, size_type __n, value_type __c);
            iterator insert(const_iterator __pos, value_type __c);
            iterator insert(const_iterator __pos, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, iterator>::type insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, iterator>::type insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
            iterator insert(const_iterator __pos, initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<char> &erase(size_type __pos, size_type __n);
            iterator erase(const_iterator __pos) __attribute__((always_inline));
            iterator erase(const_iterator __first, const_iterator __last) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str, size_type __pos2, size_type __n2);
            std::__1::basic_string<char> &replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2);
            std::__1::basic_string<char> &replace(size_type __pos, size_type __n1, const value_type *__s);
            std::__1::basic_string<char> &replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value, basic_string<char> &>::type replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il) __attribute__((always_inline));
            size_type copy(value_type *__s, size_type __n, size_type __pos) const;
            std::__1::basic_string<char> substr(size_type __pos, size_type __n) const __attribute__((always_inline));
            void swap(std::__1::basic_string<char> &__str) __attribute__((always_inline));
            const value_type *c_str() const noexcept __attribute__((always_inline));
            const value_type *data() const noexcept __attribute__((always_inline))             {
                return std::__1::__to_raw_pointer(this->__get_pointer());
            }


            allocator_type get_allocator() const noexcept __attribute__((always_inline));
            size_type find(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(value_type __c, size_type __pos) const noexcept;
            size_type rfind(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type rfind(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(value_type __c, size_type __pos) const noexcept;
            size_type find_first_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            int compare(const std::__1::basic_string<char> &__str) const noexcept __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str) const __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str, size_type __pos2, size_type __n2) const;
            int compare(const value_type *__s) const noexcept;
            int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
            int compare(size_type __pos1, size_type __n1, const value_type *__s, size_type __n2) const;
            bool __invariants() const __attribute__((always_inline));
            bool __is_long() const noexcept __attribute__((always_inline))             {
                return bool(this->__r_.first().__s.__size_ & __short_mask);
            }


        private:
            allocator_type &__alloc() noexcept __attribute__((always_inline));
            const allocator_type &__alloc() const noexcept __attribute__((always_inline));
            void __set_short_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_short_size() const noexcept __attribute__((always_inline));
            void __set_long_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_size() const noexcept __attribute__((always_inline));
            void __set_size(size_type __s) noexcept __attribute__((always_inline));
            void __set_long_cap(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_cap() const noexcept __attribute__((always_inline));
            void __set_long_pointer(pointer __p) noexcept __attribute__((always_inline));
            pointer __get_long_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_long_pointer() const noexcept __attribute__((always_inline))             {
                return this->__r_.first().__l.__data_;
            }


            pointer __get_short_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_short_pointer() const noexcept __attribute__((always_inline))             {
                return pointer_traits<const_pointer>::pointer_to(this->__r_.first().__s.__data_[0]);
            }


            pointer __get_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_pointer() const noexcept __attribute__((always_inline))             {
                return this->__is_long() ? this->__get_long_pointer() : this->__get_short_pointer();
            }


            void __zero() noexcept __attribute__((always_inline))             {
                size_type (&__a)[3] = this->__r_.first().__r.__words;
                for (unsigned int __i = 0; __i < __n_words; ++__i) 
                    __a[__i] = 0;
            }


            template <size_type __a> static size_type __align_it(size_type __s) noexcept __attribute__((always_inline));
            enum  {
                __alignment = 16
            };
            static size_type __recommend(size_type __s) noexcept __attribute__((always_inline));
            void __init(const value_type *__s, size_type __sz, size_type __reserve);
            void __init(const value_type *__s, size_type __sz);
            void __init(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add);
            void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add, const value_type *__p_new_stuff);
            void __erase_to_end(size_type __pos) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<char> &__str, true_type) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<char> &, false_type) noexcept __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<char> &__str, false_type) __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<char> &__str, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<char> &__str) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<char> &__c, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<char> &, false_type) noexcept __attribute__((always_inline));
            void __invalidate_all_iterators() __attribute__((always_inline));
            void __invalidate_iterators_past(size_type) __attribute__((always_inline));
            friend std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const std::__1::basic_string<char> &);
            friend std::__1::basic_string<char> operator+(const value_type *, const std::__1::basic_string<char> &);
            friend std::__1::basic_string<char> operator+(value_type, const std::__1::basic_string<char> &);
            friend std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const value_type *);
            friend std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, value_type);
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> class __attribute__((type_visibility("default"))) basic_string : private __basic_string_common<true> {
        public:
            typedef std::__1::basic_string<wchar_t> __self;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::char_type value_type;
            typedef std::__1::allocator<wchar_t> allocator_type;
            typedef allocator_traits<allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef value_type &reference;
            typedef const value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
            static_assert((is_same<wchar_t, value_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<pointer> iterator;
            typedef __wrap_iter<const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                size_type __cap_;
                size_type __size_;
                pointer __data_;
            };
            enum  {
                __short_mask = 1
            };
            enum  {
                __long_mask = 1UL
            };
            enum  {
                __min_cap = (sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long) - 1) / sizeof(value_type) > 2 ? (sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long) - 1) / sizeof(value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    value_type __lx;
                };
                value_type __data_[5];
            };
            union __ulx {
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long __lx;
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__ulx) / sizeof(size_type)
            };
            struct __raw {
                size_type __words[3];
            };
            struct __rep {
                union {
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long __l;
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__short __s;
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, allocator_type> __r_;
        public:
            static const size_type npos = -1;
            basic_string() __attribute__((always_inline));
            explicit basic_string(const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<wchar_t> &__str);
            basic_string(const std::__1::basic_string<wchar_t> &__str, const allocator_type &__a);
            basic_string(std::__1::basic_string<wchar_t> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::valuebasic_string(std::__1::basic_string<wchar_t> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::value) : __basic_string_common<true>(), __r_(std::__1::move(__str.__r_)) __attribute__((always_inline))             {
                __str.__zero();
            }


            basic_string(std::__1::basic_string<wchar_t> &&__str, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s) __attribute__((always_inline));
            basic_string(const value_type *__s, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n, const allocator_type &__a) __attribute__((always_inline));
            basic_string(size_type __n, value_type __c) __attribute__((always_inline));
            basic_string(size_type __n, value_type __c, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<wchar_t> &__str, size_type __pos, size_type __n, const allocator_type &__a);
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last) __attribute__((always_inline));
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last, const allocator_type &__a) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il, const allocator_type &__a) __attribute__((always_inline));
            ~std::__1::basic_string<wchar_t>() noexcept;
            std::__1::basic_string<wchar_t> &operator=(const std::__1::basic_string<wchar_t> &__str);
            std::__1::basic_string<wchar_t> &operator=(std::__1::basic_string<wchar_t> &&__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator=(value_type __c);
            std::__1::basic_string<wchar_t> &operator=(initializer_list<value_type> __il) __attribute__((always_inline));
            iterator begin() noexcept __attribute__((always_inline));
            const_iterator begin() const noexcept __attribute__((always_inline));
            iterator end() noexcept __attribute__((always_inline));
            const_iterator end() const noexcept __attribute__((always_inline));
            reverse_iterator rbegin() noexcept __attribute__((always_inline));
            const_reverse_iterator rbegin() const noexcept __attribute__((always_inline));
            reverse_iterator rend() noexcept __attribute__((always_inline));
            const_reverse_iterator rend() const noexcept __attribute__((always_inline));
            const_iterator cbegin() const noexcept __attribute__((always_inline));
            const_iterator cend() const noexcept __attribute__((always_inline));
            const_reverse_iterator crbegin() const noexcept __attribute__((always_inline));
            const_reverse_iterator crend() const noexcept __attribute__((always_inline));
            size_type size() const noexcept __attribute__((always_inline));
            size_type length() const noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            size_type capacity() const noexcept __attribute__((always_inline));
            void resize(size_type __n, value_type __c);
            void resize(size_type __n) __attribute__((always_inline));
            void reserve(size_type res_arg);
            void shrink_to_fit() noexcept __attribute__((always_inline));
            void clear() noexcept __attribute__((always_inline));
            bool empty() const noexcept __attribute__((always_inline));
            const_reference operator[](size_type __pos) const __attribute__((always_inline));
            reference operator[](size_type __pos) __attribute__((always_inline));
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__1::basic_string<wchar_t> &operator+=(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator+=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator+=(value_type __c) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator+=(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<wchar_t> &append(const value_type *__s, size_type __n);
            std::__1::basic_string<wchar_t> &append(const value_type *__s);
            std::__1::basic_string<wchar_t> &append(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type append(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<wchar_t> &>::type append(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<wchar_t> &append(initializer_list<value_type> __il) __attribute__((always_inline));
            void push_back(value_type __c);
            void pop_back() __attribute__((always_inline));
            reference front() __attribute__((always_inline));
            const_reference front() const __attribute__((always_inline));
            reference back() __attribute__((always_inline));
            const_reference back() const __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &assign(std::__1::basic_string<wchar_t> &&str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<wchar_t> &assign(const value_type *__s, size_type __n);
            std::__1::basic_string<wchar_t> &assign(const value_type *__s);
            std::__1::basic_string<wchar_t> &assign(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<wchar_t> &>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<wchar_t> &assign(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &insert(size_type __pos1, const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &insert(size_type __pos1, const std::__1::basic_string<wchar_t> &__str, size_type __pos2, size_type __n);
            std::__1::basic_string<wchar_t> &insert(size_type __pos, const value_type *__s, size_type __n);
            std::__1::basic_string<wchar_t> &insert(size_type __pos, const value_type *__s);
            std::__1::basic_string<wchar_t> &insert(size_type __pos, size_type __n, value_type __c);
            iterator insert(const_iterator __pos, value_type __c);
            iterator insert(const_iterator __pos, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, iterator>::type insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, iterator>::type insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
            iterator insert(const_iterator __pos, initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &erase(size_type __pos, size_type __n);
            iterator erase(const_iterator __pos) __attribute__((always_inline));
            iterator erase(const_iterator __first, const_iterator __last) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2);
            std::__1::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2);
            std::__1::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const value_type *__s);
            std::__1::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il) __attribute__((always_inline));
            size_type copy(value_type *__s, size_type __n, size_type __pos) const;
            std::__1::basic_string<wchar_t> substr(size_type __pos, size_type __n) const __attribute__((always_inline));
            void swap(std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            const value_type *c_str() const noexcept __attribute__((always_inline));
            const value_type *data() const noexcept __attribute__((always_inline));
            allocator_type get_allocator() const noexcept __attribute__((always_inline));
            size_type find(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(value_type __c, size_type __pos) const noexcept;
            size_type rfind(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type rfind(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(value_type __c, size_type __pos) const noexcept;
            size_type find_first_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            int compare(const std::__1::basic_string<wchar_t> &__str) const noexcept __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str) const __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2) const;
            int compare(const value_type *__s) const noexcept;
            int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
            int compare(size_type __pos1, size_type __n1, const value_type *__s, size_type __n2) const;
            bool __invariants() const __attribute__((always_inline));
            bool __is_long() const noexcept __attribute__((always_inline));
        private:
            allocator_type &__alloc() noexcept __attribute__((always_inline));
            const allocator_type &__alloc() const noexcept __attribute__((always_inline));
            void __set_short_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_short_size() const noexcept __attribute__((always_inline));
            void __set_long_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_size() const noexcept __attribute__((always_inline));
            void __set_size(size_type __s) noexcept __attribute__((always_inline));
            void __set_long_cap(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_cap() const noexcept __attribute__((always_inline));
            void __set_long_pointer(pointer __p) noexcept __attribute__((always_inline));
            pointer __get_long_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_long_pointer() const noexcept __attribute__((always_inline));
            pointer __get_short_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_short_pointer() const noexcept __attribute__((always_inline));
            pointer __get_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_pointer() const noexcept __attribute__((always_inline));
            void __zero() noexcept __attribute__((always_inline))             {
                size_type (&__a)[3] = this->__r_.first().__r.__words;
                for (unsigned int __i = 0; __i < __n_words; ++__i) 
                    __a[__i] = 0;
            }


            template <size_type __a> static size_type __align_it(size_type __s) noexcept __attribute__((always_inline));
            enum  {
                __alignment = 16
            };
            static size_type __recommend(size_type __s) noexcept __attribute__((always_inline));
            void __init(const value_type *__s, size_type __sz, size_type __reserve);
            void __init(const value_type *__s, size_type __sz);
            void __init(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add);
            void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add, const value_type *__p_new_stuff);
            void __erase_to_end(size_type __pos) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &__str, true_type) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &, false_type) noexcept __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<wchar_t> &__str, false_type) __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<wchar_t> &__str, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &__c, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &, false_type) noexcept __attribute__((always_inline));
            void __invalidate_all_iterators() __attribute__((always_inline));
            void __invalidate_iterators_past(size_type) __attribute__((always_inline));
            friend std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const std::__1::basic_string<wchar_t> &);
            friend std::__1::basic_string<wchar_t> operator+(const value_type *, const std::__1::basic_string<wchar_t> &);
            friend std::__1::basic_string<wchar_t> operator+(value_type, const std::__1::basic_string<wchar_t> &);
            friend std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const value_type *);
            friend std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, value_type);
        }
template <class _CharT = char16_t, class _Traits = std::__1::char_traits<char16_t>, class _Allocator = std::__1::allocator<char16_t>> class basic_string
template <class _CharT = char32_t, class _Traits = std::__1::char_traits<char32_t>, class _Allocator = std::__1::allocator<char32_t>> class basic_string
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_string;
        typedef basic_string<char, char_traits<char>, allocator<char> > string;
        typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;
    }
}
extern "C" {
    void *memchr(const void *, int, size_t);
    int memcmp(const void *, const void *, size_t);
    void *memcpy(void *, const void *, size_t);
    void *memmove(void *, const void *, size_t);
    void *memset(void *, int, size_t);
    char *strcat(char *, const char *);
    char *strchr(const char *, int);
    int strcmp(const char *, const char *);
    int strcoll(const char *, const char *);
    char *strcpy(char *, const char *);
    size_t strcspn(const char *, const char *);
    char *strerror(int) asm("_strerror");
    size_t strlen(const char *);
    char *strncat(char *, const char *, size_t);
    int strncmp(const char *, const char *, size_t);
    char *strncpy(char *, const char *, size_t);
    char *strpbrk(const char *, const char *);
    char *strrchr(const char *, int);
    size_t strspn(const char *, const char *);
    char *strstr(const char *, const char *);
    char *strtok(char *, const char *);
    size_t strxfrm(char *, const char *, size_t);
}
extern "C" {
    char *strtok_r(char *, const char *, char **);
}
extern "C" {
    int strerror_r(int, char *, size_t);
    char *strdup(const char *);
    void *memccpy(void *, const void *, int, size_t);
}
extern "C" {
    char *stpcpy(char *, const char *);
    char *stpncpy(char *, const char *, size_t) __attribute__((availability(macos, introduced=10.7)));
    char *strndup(const char *, size_t) __attribute__((availability(macos, introduced=10.7)));
    size_t strnlen(const char *, size_t) __attribute__((availability(macos, introduced=10.7)));
    char *strsignal(int sig);
}
extern "C" {
    void *memmem(const void *, size_t, const void *, size_t) __attribute__((availability(macos, introduced=10.7)));
    void memset_pattern4(void *, const void *, size_t) __attribute__((availability(macos, introduced=10.5)));
    void memset_pattern8(void *, const void *, size_t) __attribute__((availability(macos, introduced=10.5)));
    void memset_pattern16(void *, const void *, size_t) __attribute__((availability(macos, introduced=10.5)));
    char *strcasestr(const char *, const char *);
    char *strnstr(const char *, const char *, size_t);
    size_t strlcat(char *, const char *, size_t);
    size_t strlcpy(char *, const char *, size_t);
    void strmode(int, char *);
    char *strsep(char **, const char *);
    void swab(const void *, void *, ssize_t);
}
extern "C" {
    int bcmp(const void *, const void *, size_t);
    void bcopy(const void *, void *, size_t);
    void bzero(void *, size_t);
    char *index(const char *, int);
    char *rindex(const char *, int);
    int ffs(int);
    int strcasecmp(const char *, const char *);
    int strncasecmp(const char *, const char *, size_t);
}
extern "C" {
    int ffsl(long) __attribute__((availability(macos, introduced=10.5)));
    int ffsll(long long) __attribute__((availability(macos, introduced=10.9)));
    int fls(int) __attribute__((availability(macos, introduced=10.5)));
    int flsl(long) __attribute__((availability(macos, introduced=10.5)));
    int flsll(long long) __attribute__((availability(macos, introduced=10.9)));
}
namespace std {
    inline namespace __1 {
        using ::size_t;
        using ::memcpy;
        using ::memmove;
        using ::strcpy;
        using ::strncpy;
        using ::strcat;
        using ::strncat;
        using ::memcmp;
        using ::strcmp;
        using ::strncmp;
        using ::strcoll;
        using ::strxfrm;
        using ::memchr;
        using ::strchr;
        using ::strcspn;
        using ::strpbrk;
        using ::strrchr;
        using ::strspn;
        using ::strstr;
        inline char *strchr(char *__s, int __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::strchr(__s, __c);
        }


        inline char *strpbrk(char *__s1, const char *__s2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::strpbrk(__s1, __s2);
        }


        inline char *strrchr(char *__s, int __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::strrchr(__s, __c);
        }


        inline void *memchr(void *__s, int __c, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::memchr(__s, __c, __n);
        }


        inline char *strstr(char *__s1, const char *__s2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::strstr(__s1, __s2);
        }


        using ::strtok;
        using ::memset;
        using ::strerror;
        using ::strlen;
    }
}
namespace std {
    inline namespace __1 {
        using ::FILE;
        using ::fpos_t;
        using ::size_t;
        using ::fclose;
        using ::fflush;
        using ::setbuf;
        using ::setvbuf;
        using ::fprintf;
        using ::fscanf;
        using ::snprintf;
        using ::sprintf;
        using ::sscanf;
        using ::vfprintf;
        using ::vfscanf;
        using ::vsscanf;
        using ::vsnprintf;
        using ::vsprintf;
        using ::fgetc;
        using ::fgets;
        using ::fputc;
        using ::fputs;
        using ::getc;
        using ::putc;
        using ::ungetc;
        using ::fread;
        using ::fwrite;
        using ::fgetpos;
        using ::fseek;
        using ::fsetpos;
        using ::ftell;
        using ::rewind;
        using ::clearerr;
        using ::feof;
        using ::ferror;
        using ::perror;
        using ::fopen;
        using ::freopen;
        using ::remove;
        using ::rename;
        using ::tmpfile;
        using ::tmpnam;
        using ::getchar;
        using ::gets;
        using ::scanf;
        using ::vscanf;
        using ::printf;
        using ::putchar;
        using ::puts;
        using ::vprintf;
    }
}
namespace std {
    inline namespace __1 {
        using ::isalnum;
        using ::isalpha;
        using ::isblank;
        using ::iscntrl;
        using ::isdigit;
        using ::isgraph;
        using ::islower;
        using ::isprint;
        using ::ispunct;
        using ::isspace;
        using ::isupper;
        using ::isxdigit;
        using ::tolower;
        using ::toupper;
    }
}
typedef __darwin_wctrans_t wctrans_t;
inline int iswblank(wint_t _wc) {
    return (__istype(_wc, 131072L));
}


inline int iswascii(wint_t _wc) {
    return ((_wc & ~127) == 0);
}


inline int iswhexnumber(wint_t _wc) {
    return (__istype(_wc, 65536L));
}


inline int iswideogram(wint_t _wc) {
    return (__istype(_wc, 524288L));
}


inline int iswnumber(wint_t _wc) {
    return (__istype(_wc, 1024L));
}


inline int iswphonogram(wint_t _wc) {
    return (__istype(_wc, 2097152L));
}


inline int iswrune(wint_t _wc) {
    return (__istype(_wc, 4294967280L));
}


inline int iswspecial(wint_t _wc) {
    return (__istype(_wc, 1048576L));
}


extern "C" {
    wint_t nextwctype(wint_t, wctype_t);
    wint_t towctrans(wint_t, wctrans_t);
    wctrans_t wctrans(const char *);
}
namespace std {
    inline namespace __1 {
        using ::wint_t;
        using ::wctrans_t;
        using ::wctype_t;
        using ::iswalnum;
        using ::iswalpha;
        using ::iswblank;
        using ::iswcntrl;
        using ::iswdigit;
        using ::iswgraph;
        using ::iswlower;
        using ::iswprint;
        using ::iswpunct;
        using ::iswspace;
        using ::iswupper;
        using ::iswxdigit;
        using ::iswctype;
        using ::wctype;
        using ::towlower;
        using ::towupper;
        using ::towctrans;
        using ::wctrans;
    }
}
namespace std {
    inline namespace __1 {
        using ::mbstate_t;
        using ::size_t;
        using ::tm;
        using ::wint_t;
        using ::FILE;
        using ::fwprintf;
        using ::fwscanf;
        using ::swprintf;
        using ::vfwprintf;
        using ::vswprintf;
        using ::swscanf;
        using ::vfwscanf;
        using ::vswscanf;
        using ::fgetwc;
        using ::fgetws;
        using ::fputwc;
        using ::fputws;
        using ::fwide;
        using ::getwc;
        using ::putwc;
        using ::ungetwc;
        using ::wcstod;
        using ::wcstof;
        using ::wcstold;
        using ::wcstol;
        using ::wcstoll;
        using ::wcstoul;
        using ::wcstoull;
        using ::wcscpy;
        using ::wcsncpy;
        using ::wcscat;
        using ::wcsncat;
        using ::wcscmp;
        using ::wcscoll;
        using ::wcsncmp;
        using ::wcsxfrm;
        inline const wchar_t *wcschr(const wchar_t *__s, wchar_t __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wcschr(__s, __c);
        }


        inline wchar_t *wcschr(wchar_t *__s, wchar_t __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wcschr(__s, __c);
        }


        inline const wchar_t *wcspbrk(const wchar_t *__s1, const wchar_t *__s2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wcspbrk(__s1, __s2);
        }


        inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wcspbrk(__s1, __s2);
        }


        inline const wchar_t *wcsrchr(const wchar_t *__s, wchar_t __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wcsrchr(__s, __c);
        }


        inline wchar_t *wcsrchr(wchar_t *__s, wchar_t __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wcsrchr(__s, __c);
        }


        inline const wchar_t *wcsstr(const wchar_t *__s1, const wchar_t *__s2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wcsstr(__s1, __s2);
        }


        inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wcsstr(__s1, __s2);
        }


        inline const wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wmemchr(__s, __c, __n);
        }


        inline wchar_t *wmemchr(wchar_t *__s, wchar_t __c, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ::wmemchr(__s, __c, __n);
        }


        using ::wcscspn;
        using ::wcslen;
        using ::wcsspn;
        using ::wcstok;
        using ::wmemcmp;
        using ::wmemcpy;
        using ::wmemmove;
        using ::wmemset;
        using ::wcsftime;
        using ::btowc;
        using ::wctob;
        using ::mbsinit;
        using ::mbrlen;
        using ::mbrtowc;
        using ::wcrtomb;
        using ::mbsrtowcs;
        using ::wcsrtombs;
        using ::getwchar;
        using ::vwscanf;
        using ::wscanf;
        using ::putwchar;
        using ::vwprintf;
        using ::wprintf;
    }
}
typedef long ptrdiff_t;
typedef long double max_align_t;
namespace std {
    inline namespace __1 {
        using ::ptrdiff_t;
        using ::size_t;
        using ::max_align_t;
    }
}
namespace std {
    typedef decltype(nullptr) nullptr_t;
}
namespace std {
    template <class _Ep = char> class initializer_list {
        const char *__begin_;
        size_t __size_;
        initializer_list(const char *__b, size_t __s) noexcept __attribute__((always_inline));
    public:
        typedef char value_type;
        typedef const char &reference;
        typedef const char &const_reference;
        typedef size_t size_type;
        typedef const char *iterator;
        typedef const char *const_iterator;
        initializer_list() noexcept __attribute__((always_inline));
        size_t size() const noexcept __attribute__((always_inline));
        const char *begin() const noexcept __attribute__((always_inline));
        const char *end() const noexcept __attribute__((always_inline));
    }
template <class _Ep = wchar_t> class initializer_list {
        const wchar_t *__begin_;
        size_t __size_;
        initializer_list(const wchar_t *__b, size_t __s) noexcept __attribute__((always_inline));
    public:
        typedef wchar_t value_type;
        typedef const wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef size_t size_type;
        typedef const wchar_t *iterator;
        typedef const wchar_t *const_iterator;
        initializer_list() noexcept __attribute__((always_inline));
        size_t size() const noexcept __attribute__((always_inline));
        const wchar_t *begin() const noexcept __attribute__((always_inline));
        const wchar_t *end() const noexcept __attribute__((always_inline));
    }
template <class _Ep = long> class initializer_list {
        const long *__begin_;
        size_t __size_;
        initializer_list(const long *__b, size_t __s) noexcept __attribute__((always_inline));
    public:
        typedef long value_type;
        typedef const long &reference;
        typedef const long &const_reference;
        typedef size_t size_type;
        typedef const long *iterator;
        typedef const long *const_iterator;
        initializer_list() noexcept __attribute__((always_inline));
        size_t size() const noexcept __attribute__((always_inline));
        const long *begin() const noexcept __attribute__((always_inline));
        const long *end() const noexcept __attribute__((always_inline));
    }
template <class _Ep> class __attribute__((type_visibility("default"))) initializer_list {
        const _Ep *__begin_;
        size_t __size_;
        initializer_list<_Ep>(const _Ep *__b, size_t __s) noexcept : __begin_(__b), __size_(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


    public:
        typedef _Ep value_type;
        typedef const _Ep &reference;
        typedef const _Ep &const_reference;
        typedef size_t size_type;
        typedef const _Ep *iterator;
        typedef const _Ep *const_iterator;
        initializer_list<_Ep>() noexcept : __begin_(nullptr), __size_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        size_t size() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__size_;
        }


        const _Ep *begin() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__begin_;
        }


        const _Ep *end() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__begin_ + this->__size_;
        }


    };
    template <class _Ep> inline const _Ep *begin(initializer_list<_Ep> __il) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))     {
        return __il.begin();
    }

;
    template <class _Ep> inline const _Ep *end(initializer_list<_Ep> __il) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))     {
        return __il.end();
    }

;
}
namespace std {
    inline namespace __1 {
        template <class > struct __void_t {
            typedef void type;
        };
        template <class _Tp> struct __identity {
            typedef _Tp type;
        };
        template <class _Tp, bool> struct __attribute__((type_visibility("default"))) __dependent_type : public _Tp {
        };
        template <bool _Bp = false, class _If = std::__1::pointer_traits<char *>::__nat, class _Then = char> struct conditional {
            typedef char type;
        }
template <bool _Bp = false, class _If = std::__1::pointer_traits<wchar_t *>::__nat, class _Then = wchar_t> struct conditional {
            typedef wchar_t type;
        }
template <bool _Bp = false, class _If = long long *, class _Then = long long> struct conditional {
            typedef long long type;
        }
template <bool _Bp = false, class _If = void (*)(void *), class _Then = void (*const &)(void *)> struct conditional {
            typedef void (*const &type)(void *);
        }
template <bool _Bp = false, class _If = std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >, class _Then = std::__1::__bit_reference<std::__1::__bitset<0, 0>, true>> struct conditional {
            typedef std::__1::__bit_reference<std::__1::__bitset<0, 0>, true> type;
        }
template <bool _Bp = false, class _If = const unsigned long *, class _Then = unsigned long *> struct conditional {
            typedef unsigned long *type;
        }
template <bool _Bp = true, class _If = std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >, class _Then = std::__1::__bit_reference<std::__1::__bitset<0, 0>, true>> struct conditional {
            typedef std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > type;
        }
template <bool _Bp = true, class _If = const unsigned long *, class _Then = unsigned long *> struct conditional {
            typedef const unsigned long *type;
        }
template <bool _Bp = false, class _If = std::__1::pointer_traits<const char *>::__nat, class _Then = const char> struct conditional {
            typedef const char type;
        }
template <bool _Bp, class _If, class _Then> struct __attribute__((type_visibility("default"))) conditional {
            typedef _If type;
        };
        struct __attribute__((type_visibility("default"))) conditional {
            typedef _Then type;
        };
        template <bool, class _Tp> struct __attribute__((type_visibility("default"))) __lazy_enable_if {
        };
        struct __attribute__((type_visibility("default"))) __lazy_enable_if {
            typedef typename _Tp::type type;
        };
        template <bool = false, class _Tp = void> struct enable_if {
        }
template <bool = false, class _Tp = std::__1::error_code &> struct enable_if {
        }
template <bool = true, class _Tp = void> struct enable_if {
            typedef void type;
        }
template <bool = true, class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct enable_if {
            typedef std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > type;
        }
template <bool = false, class _Tp = std::__1::basic_ostream<char> &> struct enable_if {
        }
template <bool = true, class _Tp = bool> struct enable_if {
            typedef bool type;
        }
template <bool, class _Tp = void> struct __attribute__((type_visibility("default"))) enable_if {
        };
        struct __attribute__((type_visibility("default"))) enable_if {
            typedef _Tp type;
        };
        struct __two {
            char __lx[2];
        };
        template <class _Tp = bool, _Tp __v = true> struct integral_constant {
            static const bool value = true;
            typedef bool value_type;
            typedef std::__1::integral_constant<bool, true> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = bool, _Tp __v = false> struct integral_constant {
            static const bool value = false;
            typedef bool value_type;
            typedef std::__1::integral_constant<bool, false> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = unsigned long, _Tp __v = 0> struct integral_constant {
            static const unsigned long value = 0UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 0> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = unsigned long, _Tp __v = 2> struct integral_constant {
            static const unsigned long value = 2UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 2> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = int, _Tp __v = 0> struct integral_constant {
            static const int value = 0;
            typedef int value_type;
            typedef std::__1::integral_constant<int, 0> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = int, _Tp __v = 1> struct integral_constant {
            static const int value = 1;
            typedef int value_type;
            typedef std::__1::integral_constant<int, 1> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = int, _Tp __v = 2> struct integral_constant {
            static const int value = 2;
            typedef int value_type;
            typedef std::__1::integral_constant<int, 2> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = unsigned long, _Tp __v = 1> struct integral_constant {
            static const unsigned long value = 1UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 1> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = unsigned long, _Tp __v = 4> struct integral_constant {
            static const unsigned long value = 4UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 4> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = unsigned long, _Tp __v = 8> struct integral_constant {
            static const unsigned long value = 8UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 8> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp = unsigned long, _Tp __v = 16> struct integral_constant {
            static const unsigned long value = 16UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 16> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline));
        }
template <class _Tp, _Tp __v> struct __attribute__((type_visibility("default"))) integral_constant {
            static const _Tp value = __v;
            typedef _Tp value_type;
            typedef integral_constant<_Tp, __v> type;
            constexpr operator value_type() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return value;
            }


        };
        const _Tp value;
        typedef integral_constant<bool, (true)> true_type;
        typedef integral_constant<bool, (false)> false_type;
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_const : public false_type {
        };
        struct __attribute__((type_visibility("default"))) is_const : public true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_volatile : public false_type {
        };
        struct __attribute__((type_visibility("default"))) is_volatile : public true_type {
        };
        template <class _Tp = long> struct remove_const {
            typedef long type;
        }
template <class _Tp = char> struct remove_const {
            typedef char type;
        }
template <class _Tp = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep> struct remove_const {
            typedef std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep type;
        }
template <class _Tp = std::__1::allocator<char>> struct remove_const {
            typedef std::__1::allocator<char> type;
        }
template <class _Tp = wchar_t> struct remove_const {
            typedef wchar_t type;
        }
template <class _Tp = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep> struct remove_const {
            typedef std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep type;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct remove_const {
            typedef std::__1::allocator<wchar_t> type;
        }
template <class _Tp = long long> struct remove_const {
            typedef long long type;
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct remove_const {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > type;
        }
template <class _Tp = long double> struct remove_const {
            typedef long double type;
        }
template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct remove_const {
            typedef std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > type;
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct remove_const {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > type;
        }
template <class _Tp = unsigned long> struct remove_const {
            typedef unsigned long type;
        }
template <class _Tp = unsigned char *> struct remove_const {
            typedef unsigned char *type;
        }
template <class _Tp = void (*)(void *)> struct remove_const {
            typedef void (*type)(void *);
        }
template <class _Tp = unsigned long long> struct remove_const {
            typedef unsigned long long type;
        }
template <class _Tp = char *> struct remove_const {
            typedef char *type;
        }
template <class _Tp = unsigned int *> struct remove_const {
            typedef unsigned int *type;
        }
template <class _Tp = unsigned int> struct remove_const {
            typedef unsigned int type;
        }
template <class _Tp = short> struct remove_const {
            typedef short type;
        }
template <class _Tp = int> struct remove_const {
            typedef int type;
        }
template <class _Tp = const char> struct remove_const {
            typedef char type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) remove_const {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_const {
            typedef _Tp type;
        };
        template <class _Tp = long> struct remove_volatile {
            typedef long type;
        }
template <class _Tp = char> struct remove_volatile {
            typedef char type;
        }
template <class _Tp = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep> struct remove_volatile {
            typedef std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep type;
        }
template <class _Tp = std::__1::allocator<char>> struct remove_volatile {
            typedef std::__1::allocator<char> type;
        }
template <class _Tp = wchar_t> struct remove_volatile {
            typedef wchar_t type;
        }
template <class _Tp = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep> struct remove_volatile {
            typedef std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep type;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct remove_volatile {
            typedef std::__1::allocator<wchar_t> type;
        }
template <class _Tp = long long> struct remove_volatile {
            typedef long long type;
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct remove_volatile {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > type;
        }
template <class _Tp = long double> struct remove_volatile {
            typedef long double type;
        }
template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct remove_volatile {
            typedef std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > type;
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct remove_volatile {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > type;
        }
template <class _Tp = unsigned long> struct remove_volatile {
            typedef unsigned long type;
        }
template <class _Tp = unsigned char *> struct remove_volatile {
            typedef unsigned char *type;
        }
template <class _Tp = void (*)(void *)> struct remove_volatile {
            typedef void (*type)(void *);
        }
template <class _Tp = unsigned long long> struct remove_volatile {
            typedef unsigned long long type;
        }
template <class _Tp = char *> struct remove_volatile {
            typedef char *type;
        }
template <class _Tp = unsigned int *> struct remove_volatile {
            typedef unsigned int *type;
        }
template <class _Tp = unsigned int> struct remove_volatile {
            typedef unsigned int type;
        }
template <class _Tp = short> struct remove_volatile {
            typedef short type;
        }
template <class _Tp = int> struct remove_volatile {
            typedef int type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) remove_volatile {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_volatile {
            typedef _Tp type;
        };
        template <class _Tp = long> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<long>::type>::type type;
        }
template <class _Tp = char> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<char>::type>::type type;
        }
template <class _Tp = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<__rep>::type>::type type;
        }
template <class _Tp = std::__1::allocator<char>> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<allocator<char> >::type>::type type;
        }
template <class _Tp = wchar_t> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<wchar_t>::type>::type type;
        }
template <class _Tp = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<__rep>::type>::type type;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<allocator<wchar_t> >::type>::type type;
        }
template <class _Tp = long long> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<long long>::type>::type type;
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<duration<long long, ratio<1, 1000000000> > >::type>::type type;
        }
template <class _Tp = long double> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<long double>::type>::type type;
        }
template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<duration<long double, ratio<1, 1000000000> > >::type>::type type;
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<duration<long long, ratio<1, 1000000> > >::type>::type type;
        }
template <class _Tp = unsigned long> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<unsigned long>::type>::type type;
        }
template <class _Tp = unsigned char *> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<unsigned char *>::type>::type type;
        }
template <class _Tp = void (*)(void *)> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<void (*)(void *)>::type>::type type;
        }
template <class _Tp = unsigned long long> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<unsigned long long>::type>::type type;
        }
template <class _Tp = char *> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<char *>::type>::type type;
        }
template <class _Tp = unsigned int *> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<unsigned int *>::type>::type type;
        }
template <class _Tp = unsigned int> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<unsigned int>::type>::type type;
        }
template <class _Tp = short> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<short>::type>::type type;
        }
template <class _Tp = int> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<int>::type>::type type;
        }
template <class _Tp = const char> struct remove_cv {
            typedef typename remove_volatile<typename remove_const<const char>::type>::type type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) remove_cv {
            typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;
        };
        template <class _Tp = void> struct __libcpp_is_void : public true_type {
        }
template <class _Tp = char> struct __libcpp_is_void : public false_type {
        }
template <class _Tp = wchar_t> struct __libcpp_is_void : public false_type {
        }
template <class _Tp = long long> struct __libcpp_is_void : public false_type {
        }
template <class _Tp> struct __libcpp_is_void : public false_type {
        };
        struct __libcpp_is_void : public true_type {
        };
        template <class _Tp = char> struct is_void : public __libcpp_is_void<typename remove_cv<char>::type> {
        }
template <class _Tp = wchar_t> struct is_void : public __libcpp_is_void<typename remove_cv<wchar_t>::type> {
        }
template <class _Tp = long long> struct is_void : public __libcpp_is_void<typename remove_cv<long long>::type> {
        }
template <class _Tp = const char> struct is_void : public __libcpp_is_void<typename remove_cv<const char>::type> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_void : public __libcpp_is_void<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp = nullptr_t> struct __is_nullptr_t_impl : public true_type {
        }
template <class _Tp = long long> struct __is_nullptr_t_impl : public false_type {
        }
template <class _Tp> struct __is_nullptr_t_impl : public false_type {
        };
        struct __is_nullptr_t_impl : public true_type {
        };
        template <class _Tp = long long> struct __is_nullptr_t : public __is_nullptr_t_impl<typename remove_cv<long long>::type> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) __is_nullptr_t : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp = bool> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = char> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = signed char> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = unsigned char> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = wchar_t> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = char16_t> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = char32_t> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = short> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = unsigned short> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = int> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = unsigned int> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = long> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = unsigned long> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = long long> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = unsigned long long> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = __int128> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp = unsigned __int128> struct __libcpp_is_integral : public true_type {
        }
template <class _Tp> struct __libcpp_is_integral : public false_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        struct __libcpp_is_integral : public true_type {
        };
        template <class _Tp = long> struct is_integral : public __libcpp_is_integral<typename remove_cv<long>::type> {
        }
template <class _Tp = long long> struct is_integral : public __libcpp_is_integral<typename remove_cv<long long>::type> {
        }
template <class _Tp = unsigned long> struct is_integral : public __libcpp_is_integral<typename remove_cv<unsigned long>::type> {
        }
template <class _Tp = unsigned long long> struct is_integral : public __libcpp_is_integral<typename remove_cv<unsigned long long>::type> {
        }
template <class _Tp = unsigned int> struct is_integral : public __libcpp_is_integral<typename remove_cv<unsigned int>::type> {
        }
template <class _Tp = char> struct is_integral : public __libcpp_is_integral<typename remove_cv<char>::type> {
        }
template <class _Tp = short> struct is_integral : public __libcpp_is_integral<typename remove_cv<short>::type> {
        }
template <class _Tp = int> struct is_integral : public __libcpp_is_integral<typename remove_cv<int>::type> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_integral : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp = float> struct __libcpp_is_floating_point : public true_type {
        }
template <class _Tp = double> struct __libcpp_is_floating_point : public true_type {
        }
template <class _Tp = long double> struct __libcpp_is_floating_point : public true_type {
        }
template <class _Tp = long> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = long long> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = unsigned long> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = unsigned long long> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = unsigned int> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = char> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = short> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp = int> struct __libcpp_is_floating_point : public false_type {
        }
template <class _Tp> struct __libcpp_is_floating_point : public false_type {
        };
        struct __libcpp_is_floating_point : public true_type {
        };
        struct __libcpp_is_floating_point : public true_type {
        };
        struct __libcpp_is_floating_point : public true_type {
        };
        template <class _Tp = long> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<long>::type> {
        }
template <class _Tp = long long> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<long long>::type> {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<duration<long long, ratio<1, 1000000000> > >::type> {
        }
template <class _Tp = long double> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<long double>::type> {
        }
template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<duration<long double, ratio<1, 1000000000> > >::type> {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<duration<long long, ratio<1, 1000000> > >::type> {
        }
template <class _Tp = unsigned long> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<unsigned long>::type> {
        }
template <class _Tp = unsigned long long> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<unsigned long long>::type> {
        }
template <class _Tp = unsigned int> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<unsigned int>::type> {
        }
template <class _Tp = char> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<char>::type> {
        }
template <class _Tp = short> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<short>::type> {
        }
template <class _Tp = int> struct is_floating_point : public __libcpp_is_floating_point<typename remove_cv<int>::type> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_floating_point : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp = long long> struct is_array : public false_type {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_array : public false_type {
        };
        struct __attribute__((type_visibility("default"))) is_array : public true_type {
        };
        struct __attribute__((type_visibility("default"))) is_array : public true_type {
        };
        template <class _Tp> struct __libcpp_is_pointer : public false_type {
        };
        struct __libcpp_is_pointer : public true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_pointer : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp = std::__1::basic_ostream<char> &> struct is_lvalue_reference : public true_type {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_lvalue_reference : public false_type {
        };
        struct __attribute__((type_visibility("default"))) is_lvalue_reference : public true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_rvalue_reference : public false_type {
        };
        struct __attribute__((type_visibility("default"))) is_rvalue_reference : public true_type {
        };
        template <class _Tp = long long> struct is_reference : public false_type {
        }
template <class _Tp = std::__1::allocator<char>> struct is_reference : public false_type {
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct is_reference : public false_type {
        }
template <class _Tp = void (*)(void *)> struct is_reference : public false_type {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_reference : public false_type {
        };
        struct __attribute__((type_visibility("default"))) is_reference : public true_type {
        };
        struct __attribute__((type_visibility("default"))) is_reference : public true_type {
        };
        template <class _Tp = long long> struct is_union : public integral_constant<bool, __is_union(long long)> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_union : public integral_constant<bool, __is_union(_Tp)> {
        };
        template <class _Tp = long long> struct is_class : public integral_constant<bool, __is_class(long long)> {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct is_class : public integral_constant<bool, __is_class(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >)> {
        }
template <class _Tp = long double> struct is_class : public integral_constant<bool, __is_class(long double)> {
        }
template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct is_class : public integral_constant<bool, __is_class(std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >)> {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct is_class : public integral_constant<bool, __is_class(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >)> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_class : public integral_constant<bool, __is_class(_Tp)> {
        };
        template <class _Tp = char, class _Up = char> struct is_same : public true_type {
        }
template <class _Tp = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, class _Up = std::__1::allocator<char>> struct is_same : public false_type {
        }
template <class _Tp = wchar_t, class _Up = wchar_t> struct is_same : public true_type {
        }
template <class _Tp = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, class _Up = std::__1::allocator<wchar_t>> struct is_same : public false_type {
        }
template <class _Tp = unsigned char *, class _Up = void (*)(void *)> struct is_same : public false_type {
        }
template <class _Tp = void (*)(void *), class _Up = std::__1::default_delete<unsigned char>> struct is_same : public false_type {
        }
template <class _Tp = char *, class _Up = void (*)(void *)> struct is_same : public false_type {
        }
template <class _Tp = void (*)(void *), class _Up = std::__1::default_delete<char>> struct is_same : public false_type {
        }
template <class _Tp = unsigned int *, class _Up = void (*)(void *)> struct is_same : public false_type {
        }
template <class _Tp = void (*)(void *), class _Up = std::__1::default_delete<unsigned int>> struct is_same : public false_type {
        }
template <class _Tp, class _Up> struct __attribute__((type_visibility("default"))) is_same : public false_type {
        };
        struct __attribute__((type_visibility("default"))) is_same : public true_type {
        };
        namespace __libcpp_is_function_imp {
            struct __dummy_type {
            };
            template <class _Tp = long long> char __test(long long *)template <class _Tp> char __test(_Tp *);
            template <class _Tp = long long> char __test(std::__1::__libcpp_is_function_imp::__dummy_type)template <class _Tp> char __test(std::__1::__libcpp_is_function_imp::__dummy_type);
            template <class _Tp = long long> std::__1::__two __test(...)template <class _Tp> std::__1::__two __test(...);
            template <class _Tp = long long> long long &__source(int)template <class _Tp> _Tp &__source(int);
            template <class _Tp = long long> std::__1::__libcpp_is_function_imp::__dummy_type __source(...)template <class _Tp> std::__1::__libcpp_is_function_imp::__dummy_type __source(...);
        }
        template <class _Tp = long long, bool = false> struct __libcpp_is_function : public integral_constant<bool, sizeof (__libcpp_is_function_imp::__test<long long>(__libcpp_is_function_imp::__source<long long>(0))) == 1> {
        }
template <class _Tp, bool = is_class<_Tp>::value || is_union<_Tp>::value || is_void<_Tp>::value || is_reference<_Tp>::value || __is_nullptr_t<_Tp>::value> struct __libcpp_is_function : public integral_constant<bool, sizeof (__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1> {
        };
        struct __libcpp_is_function : public false_type {
        };
        template <class _Tp = long long> struct is_function : public __libcpp_is_function<long long> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_function : public __libcpp_is_function<_Tp> {
        };
        template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr> struct __member_pointer_traits_imp {
        };
        template <class _Tp> struct __libcpp_is_member_function_pointer : public false_type {
        };
        struct __libcpp_is_member_function_pointer : public is_function<_Ret> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_member_function_pointer : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {
        };
        template <class _Tp> struct __libcpp_is_member_pointer : public false_type {
        };
        struct __libcpp_is_member_pointer : public true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_member_pointer : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_member_object_pointer : public integral_constant<bool, is_member_pointer<_Tp>::value && !is_member_function_pointer<_Tp>::value> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_enum : public integral_constant<bool, __is_enum(_Tp)> {
        };
        template <class _Tp = long> struct is_arithmetic : public integral_constant<bool, is_integral<long>::value || is_floating_point<long>::value> {
        }
template <class _Tp = long long> struct is_arithmetic : public integral_constant<bool, is_integral<long long>::value || is_floating_point<long long>::value> {
        }
template <class _Tp = unsigned long> struct is_arithmetic : public integral_constant<bool, is_integral<unsigned long>::value || is_floating_point<unsigned long>::value> {
        }
template <class _Tp = unsigned long long> struct is_arithmetic : public integral_constant<bool, is_integral<unsigned long long>::value || is_floating_point<unsigned long long>::value> {
        }
template <class _Tp = unsigned int> struct is_arithmetic : public integral_constant<bool, is_integral<unsigned int>::value || is_floating_point<unsigned int>::value> {
        }
template <class _Tp = char> struct is_arithmetic : public integral_constant<bool, is_integral<char>::value || is_floating_point<char>::value> {
        }
template <class _Tp = short> struct is_arithmetic : public integral_constant<bool, is_integral<short>::value || is_floating_point<short>::value> {
        }
template <class _Tp = int> struct is_arithmetic : public integral_constant<bool, is_integral<int>::value || is_floating_point<int>::value> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_arithmetic : public integral_constant<bool, is_integral<_Tp>::value || is_floating_point<_Tp>::value> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_fundamental : public integral_constant<bool, is_void<_Tp>::value || __is_nullptr_t<_Tp>::value || is_arithmetic<_Tp>::value> {
        };
        template <class _Tp = nullptr_t> struct __attribute__((type_visibility("default"))) is_scalar : public true_type {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_scalar : public integral_constant<bool, is_arithmetic<_Tp>::value || is_member_pointer<_Tp>::value || is_pointer<_Tp>::value || __is_nullptr_t<_Tp>::value || is_enum<_Tp>::value> {
        };
        struct __attribute__((type_visibility("default"))) is_scalar : public true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_object : public integral_constant<bool, is_scalar<_Tp>::value || is_array<_Tp>::value || is_union<_Tp>::value || is_class<_Tp>::value> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_compound : public integral_constant<bool, !is_fundamental<_Tp>::value> {
        };
        template <class _Tp, bool = is_reference<_Tp>::value || is_function<_Tp>::value || is_const<_Tp>::value> struct __add_const {
            typedef _Tp type;
        };
        struct __add_const {
            typedef const _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) add_const {
            typedef typename __add_const<_Tp>::type type;
        };
        template <class _Tp, bool = is_reference<_Tp>::value || is_function<_Tp>::value || is_volatile<_Tp>::value> struct __add_volatile {
            typedef _Tp type;
        };
        struct __add_volatile {
            typedef volatile _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) add_volatile {
            typedef typename __add_volatile<_Tp>::type type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) add_cv {
            typedef typename add_const<typename add_volatile<_Tp>::type>::type type;
        };
        template <class _Tp = std::__1::allocator<char>> struct remove_reference {
            typedef std::__1::allocator<char> type;
        }
template <class _Tp = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep> struct remove_reference {
            typedef std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep type;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct remove_reference {
            typedef std::__1::allocator<wchar_t> type;
        }
template <class _Tp = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep> struct remove_reference {
            typedef std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep type;
        }
template <class _Tp = long long &&> struct remove_reference {
            typedef long long type;
        }
template <class _Tp = long long> struct remove_reference {
            typedef long long type;
        }
template <class _Tp = void (*)(void *)> struct remove_reference {
            typedef void (*type)(void *);
        }
template <class _Tp = unsigned char *> struct remove_reference {
            typedef unsigned char *type;
        }
template <class _Tp = int &> struct remove_reference {
            typedef int type;
        }
template <class _Tp = char *> struct remove_reference {
            typedef char *type;
        }
template <class _Tp = unsigned int *> struct remove_reference {
            typedef unsigned int *type;
        }
template <class _Tp = std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > &> struct remove_reference {
            typedef std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > type;
        }
template <class _Tp = std::__1::__compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> > &> struct remove_reference {
            typedef std::__1::__compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> > type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) remove_reference {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_reference {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_reference {
            typedef _Tp type;
        };
        template <class _Tp = void> struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef void type;
        }
template <class _Tp = const void> struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef const void type;
        }
template <class _Tp = volatile void> struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef volatile void type;
        }
template <class _Tp = const volatile void> struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef const volatile void type;
        }
template <class _Tp = void (*const)(void *)> struct add_lvalue_reference {
            typedef void (*const &type)(void *);
        }
template <class _Tp = unsigned char> struct add_lvalue_reference {
            typedef unsigned char &type;
        }
template <class _Tp = char> struct add_lvalue_reference {
            typedef char &type;
        }
template <class _Tp = unsigned int> struct add_lvalue_reference {
            typedef unsigned int &type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef _Tp &type;
        };
        struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef _Tp &type;
        };
        struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef void type;
        };
        struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef const void type;
        };
        struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef volatile void type;
        };
        struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef const volatile void type;
        };
        template <class _Tp = void> struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef void type;
        }
template <class _Tp = const void> struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef const void type;
        }
template <class _Tp = volatile void> struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef volatile void type;
        }
template <class _Tp = const volatile void> struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef const volatile void type;
        }
template <class _Tp = std::__1::allocator<char>> struct add_rvalue_reference {
            typedef std::__1::allocator<char> &&type;
        }
template <class _Tp = std::__1::allocator<char> &&> struct add_rvalue_reference {
            typedef std::__1::allocator<char> &&&&type;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct add_rvalue_reference {
            typedef std::__1::allocator<wchar_t> &&type;
        }
template <class _Tp = std::__1::allocator<wchar_t> &&> struct add_rvalue_reference {
            typedef std::__1::allocator<wchar_t> &&&&type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef _Tp &&type;
        };
        struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef void type;
        };
        struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef const void type;
        };
        struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef volatile void type;
        };
        struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef const volatile void type;
        };
        template <class _Tp = std::__1::allocator<char> &&> typename add_rvalue_reference<allocator<char> &&>::type declval() noexcepttemplate <class _Tp = std::__1::allocator<wchar_t> &&> typename add_rvalue_reference<allocator<wchar_t> &&>::type declval() noexcepttemplate <class _Tp> typename add_rvalue_reference<_Tp>::type declval() noexcept;
        template <class _Tp> struct __uncvref {
            typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
        };
        template <class _Tp> struct __unconstref {
            typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
        };
        template <class _Tp, class _Up> struct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type, typename __uncvref<_Up>::type> {
        };
        struct __any {
            __any(...);
        };
        template <class _Tp = _xlocale *> struct remove_pointer {
            typedef _xlocale type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) remove_pointer {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_pointer {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_pointer {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_pointer {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_pointer {
            typedef _Tp type;
        };
        template <class _Tp = long long> struct add_pointer {
            typedef typename remove_reference<long long>::type *type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) add_pointer {
            typedef typename remove_reference<_Tp>::type *type;
        };
        template <class _Tp = long, bool = true> struct __libcpp_is_signed_impl : public integral_constant<bool, (long(-1) < long(0))> {
        }
template <class _Tp = long long, bool = true> struct __libcpp_is_signed_impl : public integral_constant<bool, (long long(-1) < long long(0))> {
        }
template <class _Tp = unsigned long, bool = true> struct __libcpp_is_signed_impl : public integral_constant<bool, (unsigned long(-1) < unsigned long(0))> {
        }
template <class _Tp = unsigned long long, bool = true> struct __libcpp_is_signed_impl : public integral_constant<bool, (unsigned long long(-1) < unsigned long long(0))> {
        }
template <class _Tp = unsigned int, bool = true> struct __libcpp_is_signed_impl : public integral_constant<bool, (unsigned int(-1) < unsigned int(0))> {
        }
template <class _Tp = char, bool = true> struct __libcpp_is_signed_impl : public integral_constant<bool, (char(-1) < char(0))> {
        }
template <class _Tp = short, bool = true> struct __libcpp_is_signed_impl : public integral_constant<bool, (short(-1) < short(0))> {
        }
template <class _Tp = int, bool = true> struct __libcpp_is_signed_impl : public integral_constant<bool, (int(-1) < int(0))> {
        }
template <class _Tp, bool = is_integral<_Tp>::value> struct __libcpp_is_signed_impl : public integral_constant<bool, (_Tp(-1) < _Tp(0))> {
        };
        struct __libcpp_is_signed_impl : public true_type {
        };
        template <class _Tp = long, bool = true> struct __libcpp_is_signed : public __libcpp_is_signed_impl<long> {
        }
template <class _Tp = long long, bool = true> struct __libcpp_is_signed : public __libcpp_is_signed_impl<long long> {
        }
template <class _Tp = unsigned long, bool = true> struct __libcpp_is_signed : public __libcpp_is_signed_impl<unsigned long> {
        }
template <class _Tp = unsigned long long, bool = true> struct __libcpp_is_signed : public __libcpp_is_signed_impl<unsigned long long> {
        }
template <class _Tp = unsigned int, bool = true> struct __libcpp_is_signed : public __libcpp_is_signed_impl<unsigned int> {
        }
template <class _Tp = char, bool = true> struct __libcpp_is_signed : public __libcpp_is_signed_impl<char> {
        }
template <class _Tp = short, bool = true> struct __libcpp_is_signed : public __libcpp_is_signed_impl<short> {
        }
template <class _Tp = int, bool = true> struct __libcpp_is_signed : public __libcpp_is_signed_impl<int> {
        }
template <class _Tp, bool = is_arithmetic<_Tp>::value> struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {
        };
        struct __libcpp_is_signed : public false_type {
        };
        template <class _Tp = long> struct is_signed : public __libcpp_is_signed<long> {
        }
template <class _Tp = long long> struct is_signed : public __libcpp_is_signed<long long> {
        }
template <class _Tp = unsigned long> struct is_signed : public __libcpp_is_signed<unsigned long> {
        }
template <class _Tp = unsigned long long> struct is_signed : public __libcpp_is_signed<unsigned long long> {
        }
template <class _Tp = unsigned int> struct is_signed : public __libcpp_is_signed<unsigned int> {
        }
template <class _Tp = char> struct is_signed : public __libcpp_is_signed<char> {
        }
template <class _Tp = short> struct is_signed : public __libcpp_is_signed<short> {
        }
template <class _Tp = int> struct is_signed : public __libcpp_is_signed<int> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_signed : public __libcpp_is_signed<_Tp> {
        };
        template <class _Tp, bool = is_integral<_Tp>::value> struct __libcpp_is_unsigned_impl : public integral_constant<bool, (_Tp(0) < _Tp(-1))> {
        };
        struct __libcpp_is_unsigned_impl : public false_type {
        };
        template <class _Tp, bool = is_arithmetic<_Tp>::value> struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {
        };
        struct __libcpp_is_unsigned : public false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) rank : public integral_constant<size_t, 0> {
        };
        struct __attribute__((type_visibility("default"))) rank : public integral_constant<size_t, rank<_Tp>::value + 1> {
        };
        struct __attribute__((type_visibility("default"))) rank : public integral_constant<size_t, rank<_Tp>::value + 1> {
        };
        template <class _Tp, unsigned int _Ip = 0> struct __attribute__((type_visibility("default"))) extent : public integral_constant<size_t, 0> {
        };
        struct __attribute__((type_visibility("default"))) extent : public integral_constant<size_t, 0> {
        };
        struct __attribute__((type_visibility("default"))) extent : public integral_constant<size_t, extent<_Tp, _Ip - 1>::value> {
        };
        struct __attribute__((type_visibility("default"))) extent : public integral_constant<size_t, _Np> {
        };
        struct __attribute__((type_visibility("default"))) extent : public integral_constant<size_t, extent<_Tp, _Ip - 1>::value> {
        };
        template <class _Tp = long long> struct remove_extent {
            typedef long long type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) remove_extent {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_extent {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_extent {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_all_extents {
            typedef _Tp type;
        };
        struct __attribute__((type_visibility("default"))) remove_all_extents {
            typedef typename remove_all_extents<_Tp>::type type;
        };
        struct __attribute__((type_visibility("default"))) remove_all_extents {
            typedef typename remove_all_extents<_Tp>::type type;
        };
        template <class _Tp = long long &&> struct decay {
        private:
            typedef typename remove_reference<long long &&>::type _Up;
        public:
            typedef typename conditional<is_array<_Up>::value, typename remove_extent<_Up>::type *, typename conditional<is_function<_Up>::value, typename add_pointer<_Up>::type, typename remove_cv<_Up>::type>::type>::type type;
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) decay {
        private:
            typedef typename remove_reference<_Tp>::type _Up;
        public:
            typedef typename conditional<is_array<_Up>::value, typename remove_extent<_Up>::type *, typename conditional<is_function<_Up>::value, typename add_pointer<_Up>::type, typename remove_cv<_Up>::type>::type>::type type;
        };
        namespace __is_abstract_imp {
            template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> char __test(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > (*)[1])template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> char __test(std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > (*)[1])template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> char __test(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > (*)[1])template <class _Tp> char __test(_Tp (*)[1]);
            template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> std::__1::__two __test(...)template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> std::__1::__two __test(...)template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> std::__1::__two __test(...)template <class _Tp> std::__1::__two __test(...);
        }
        template <class _Tp = long long, bool = false> struct __libcpp_abstract : public false_type {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, bool = true> struct __libcpp_abstract : public integral_constant<bool, sizeof (__is_abstract_imp::__test<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >(0)) != 1> {
        }
template <class _Tp = long double, bool = false> struct __libcpp_abstract : public false_type {
        }
template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >, bool = true> struct __libcpp_abstract : public integral_constant<bool, sizeof (__is_abstract_imp::__test<std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > >(0)) != 1> {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >, bool = true> struct __libcpp_abstract : public integral_constant<bool, sizeof (__is_abstract_imp::__test<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > >(0)) != 1> {
        }
template <class _Tp, bool = is_class<_Tp>::value> struct __libcpp_abstract : public integral_constant<bool, sizeof (__is_abstract_imp::__test<_Tp>(0)) != 1> {
        };
        struct __libcpp_abstract : public false_type {
        };
        template <class _Tp = long long> struct is_abstract : public __libcpp_abstract<long long> {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct is_abstract : public __libcpp_abstract<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > {
        }
template <class _Tp = long double> struct is_abstract : public __libcpp_abstract<long double> {
        }
template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct is_abstract : public __libcpp_abstract<std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > > {
        }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct is_abstract : public __libcpp_abstract<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_abstract : public __libcpp_abstract<_Tp> {
        };
        template <class _Tp = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep> struct __libcpp_is_final : public integral_constant<bool, __is_final(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep)> {
        }
template <class _Tp = std::__1::allocator<char>> struct __libcpp_is_final : public integral_constant<bool, __is_final(std::__1::allocator<char>)> {
        }
template <class _Tp = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep> struct __libcpp_is_final : public integral_constant<bool, __is_final(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep)> {
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __libcpp_is_final : public integral_constant<bool, __is_final(std::__1::allocator<wchar_t>)> {
        }
template <class _Tp = unsigned char *> struct __libcpp_is_final : public integral_constant<bool, __is_final(unsigned char *)> {
        }
template <class _Tp = void (*)(void *)> struct __libcpp_is_final : public integral_constant<bool, __is_final(void (*)(void *))> {
        }
template <class _Tp = char *> struct __libcpp_is_final : public integral_constant<bool, __is_final(char *)> {
        }
template <class _Tp = unsigned int *> struct __libcpp_is_final : public integral_constant<bool, __is_final(unsigned int *)> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) __libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {
        };
        template <class _Bp = std::__1::ios_base, class _Dp = std::__1::basic_ostream<char> &> struct is_base_of : public integral_constant<bool, __is_base_of(std::__1::ios_base, std::__1::basic_ostream<char> &)> {
        }
template <class _Bp, class _Dp> struct __attribute__((type_visibility("default"))) is_base_of : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {
        };
        template <class _T1 = long long, class _T2 = long long> struct is_convertible : public integral_constant<bool, __is_convertible_to(long long, long long) && !is_abstract<long long>::value> {
        }
template <class _T1 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, class _T2 = long long> struct is_convertible : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, long long) && !is_abstract<long long>::value> {
        }
template <class _T1 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, class _T2 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct is_convertible : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >) && !is_abstract<duration<long long, ratio<1, 1000000000> > >::value> {
        }
template <class _T1 = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >, class _T2 = long double> struct is_convertible : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >, long double) && !is_abstract<long double>::value> {
        }
template <class _T1 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, class _T2 = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct is_convertible : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >) && !is_abstract<duration<long double, ratio<1, 1000000000> > >::value> {
        }
template <class _T1 = long double, class _T2 = long double> struct is_convertible : public integral_constant<bool, __is_convertible_to(long double, long double) && !is_abstract<long double>::value> {
        }
template <class _T1 = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >, class _T2 = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct is_convertible : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >) && !is_abstract<duration<long double, ratio<1, 1000000000> > >::value> {
        }
template <class _T1 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >, class _T2 = long long> struct is_convertible : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >, long long) && !is_abstract<long long>::value> {
        }
template <class _T1 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >, class _T2 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct is_convertible : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >) && !is_abstract<duration<long long, ratio<1, 1000000> > >::value> {
        }
template <class _T1, class _T2> struct __attribute__((type_visibility("default"))) is_convertible : public integral_constant<bool, __is_convertible_to(_T1, _T2) && !is_abstract<_T2>::value> {
        };
        template <class _Tp = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep> struct is_empty : public integral_constant<bool, __is_empty(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep)> {
        }
template <class _Tp = std::__1::allocator<char>> struct is_empty : public integral_constant<bool, __is_empty(std::__1::allocator<char>)> {
        }
template <class _Tp = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep> struct is_empty : public integral_constant<bool, __is_empty(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep)> {
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct is_empty : public integral_constant<bool, __is_empty(std::__1::allocator<wchar_t>)> {
        }
template <class _Tp = unsigned char *> struct is_empty : public integral_constant<bool, __is_empty(unsigned char *)> {
        }
template <class _Tp = void (*)(void *)> struct is_empty : public integral_constant<bool, __is_empty(void (*)(void *))> {
        }
template <class _Tp = char *> struct is_empty : public integral_constant<bool, __is_empty(char *)> {
        }
template <class _Tp = unsigned int *> struct is_empty : public integral_constant<bool, __is_empty(unsigned int *)> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_empty : public integral_constant<bool, __is_empty(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
        };
        template <class _Tp = unsigned char> struct alignment_of : public integral_constant<size_t, alignof(unsigned char)> {
        }
template <class _Tp = unsigned short> struct alignment_of : public integral_constant<size_t, alignof(unsigned short)> {
        }
template <class _Tp = unsigned int> struct alignment_of : public integral_constant<size_t, alignof(unsigned int)> {
        }
template <class _Tp = unsigned long> struct alignment_of : public integral_constant<size_t, alignof(unsigned long)> {
        }
template <class _Tp = unsigned long long> struct alignment_of : public integral_constant<size_t, alignof(unsigned long long)> {
        }
template <class _Tp = double> struct alignment_of : public integral_constant<size_t, alignof(double)> {
        }
template <class _Tp = long double> struct alignment_of : public integral_constant<size_t, alignof(long double)> {
        }
template <class _Tp = std::__1::__struct_double> struct alignment_of : public integral_constant<size_t, alignof(std::__1::__struct_double)> {
        }
template <class _Tp = std::__1::__struct_double4> struct alignment_of : public integral_constant<size_t, alignof(std::__1::__struct_double4)> {
        }
template <class _Tp = int *> struct alignment_of : public integral_constant<size_t, alignof(int *)> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) alignment_of : public integral_constant<size_t, alignof(_Tp)> {
        };
        template <class _Hp = std::__1::__align_type<int *>, class _Tp = std::__1::__nat> struct __type_list
template <class _Hp = std::__1::__align_type<std::__1::__struct_double4>, class _Tp = std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat>> struct __type_list
template <class _Hp = std::__1::__align_type<std::__1::__struct_double>, class _Tp = std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> >> struct __type_list
template <class _Hp = std::__1::__align_type<long double>, class _Tp = std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > >> struct __type_list
template <class _Hp = std::__1::__align_type<double>, class _Tp = std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > >> struct __type_list
template <class _Hp = std::__1::__align_type<unsigned long long>, class _Tp = std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > >> struct __type_list
template <class _Hp = std::__1::__align_type<unsigned long>, class _Tp = std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > >> struct __type_list
template <class _Hp = std::__1::__align_type<unsigned int>, class _Tp = std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > >> struct __type_list
template <class _Hp = std::__1::__align_type<unsigned short>, class _Tp = std::__1::__type_list<std::__1::__align_type<unsigned int>, std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > > >> struct __type_list
template <class _Hp = std::__1::__align_type<unsigned char>, class _Tp = std::__1::__type_list<std::__1::__align_type<unsigned short>, std::__1::__type_list<std::__1::__align_type<unsigned int>, std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > > > >> struct __type_list
template <class _Hp = __int128, class _Tp = std::__1::__nat> struct __type_list
template <class _Hp = long long, class _Tp = std::__1::__type_list<__int128, std::__1::__nat>> struct __type_list
template <class _Hp = long, class _Tp = std::__1::__type_list<long long, std::__1::__type_list<__int128, std::__1::__nat> >> struct __type_list
template <class _Hp = int, class _Tp = std::__1::__type_list<long, std::__1::__type_list<long long, std::__1::__type_list<__int128, std::__1::__nat> > >> struct __type_list
template <class _Hp = short, class _Tp = std::__1::__type_list<int, std::__1::__type_list<long, std::__1::__type_list<long long, std::__1::__type_list<__int128, std::__1::__nat> > > >> struct __type_list
template <class _Hp = signed char, class _Tp = std::__1::__type_list<short, std::__1::__type_list<int, std::__1::__type_list<long, std::__1::__type_list<long long, std::__1::__type_list<__int128, std::__1::__nat> > > > >> struct __type_list {
            typedef signed char _Head;
            typedef std::__1::__type_list<short, std::__1::__type_list<int, std::__1::__type_list<long, std::__1::__type_list<long long, std::__1::__type_list<__int128, std::__1::__nat> > > > > _Tail;
        }
template <class _Hp = unsigned __int128, class _Tp = std::__1::__nat> struct __type_list
template <class _Hp = unsigned long long, class _Tp = std::__1::__type_list<unsigned __int128, std::__1::__nat>> struct __type_list
template <class _Hp = unsigned long, class _Tp = std::__1::__type_list<unsigned long long, std::__1::__type_list<unsigned __int128, std::__1::__nat> >> struct __type_list
template <class _Hp = unsigned int, class _Tp = std::__1::__type_list<unsigned long, std::__1::__type_list<unsigned long long, std::__1::__type_list<unsigned __int128, std::__1::__nat> > >> struct __type_list
template <class _Hp = unsigned short, class _Tp = std::__1::__type_list<unsigned int, std::__1::__type_list<unsigned long, std::__1::__type_list<unsigned long long, std::__1::__type_list<unsigned __int128, std::__1::__nat> > > >> struct __type_list
template <class _Hp = unsigned char, class _Tp = std::__1::__type_list<unsigned short, std::__1::__type_list<unsigned int, std::__1::__type_list<unsigned long, std::__1::__type_list<unsigned long long, std::__1::__type_list<unsigned __int128, std::__1::__nat> > > > >> struct __type_list {
            typedef unsigned char _Head;
            typedef std::__1::__type_list<unsigned short, std::__1::__type_list<unsigned int, std::__1::__type_list<unsigned long, std::__1::__type_list<unsigned long long, std::__1::__type_list<unsigned __int128, std::__1::__nat> > > > > _Tail;
        }
template <class _Hp, class _Tp> struct __type_list {
            typedef _Hp _Head;
            typedef _Tp _Tail;
        };
        struct __nat {
            __nat() = delete
            __nat(const std::__1::__nat &) = delete
            std::__1::__nat &operator=(const std::__1::__nat &) = delete
            ~std::__1::__nat() = delete
        };
        template <class _Tp = unsigned char> struct __align_type {
            static const size_t value = alignment_of<unsigned char>::value;
            typedef unsigned char type;
        }
template <class _Tp = unsigned short> struct __align_type {
            static const size_t value = alignment_of<unsigned short>::value;
            typedef unsigned short type;
        }
template <class _Tp = unsigned int> struct __align_type {
            static const size_t value = alignment_of<unsigned int>::value;
            typedef unsigned int type;
        }
template <class _Tp = unsigned long> struct __align_type {
            static const size_t value = alignment_of<unsigned long>::value;
            typedef unsigned long type;
        }
template <class _Tp = unsigned long long> struct __align_type {
            static const size_t value = alignment_of<unsigned long long>::value;
            typedef unsigned long long type;
        }
template <class _Tp = double> struct __align_type {
            static const size_t value = alignment_of<double>::value;
            typedef double type;
        }
template <class _Tp = long double> struct __align_type {
            static const size_t value = alignment_of<long double>::value;
            typedef long double type;
        }
template <class _Tp = std::__1::__struct_double> struct __align_type {
            static const size_t value = alignment_of<__struct_double>::value;
            typedef std::__1::__struct_double type;
        }
template <class _Tp = std::__1::__struct_double4> struct __align_type {
            static const size_t value = alignment_of<__struct_double4>::value;
            typedef std::__1::__struct_double4 type;
        }
template <class _Tp = int *> struct __align_type {
            static const size_t value = alignment_of<int *>::value;
            typedef int *type;
        }
template <class _Tp> struct __align_type {
            static const size_t value = alignment_of<_Tp>::value;
            typedef _Tp type;
        };
        struct __struct_double {
            long double __lx;
        };
        struct __struct_double4 {
            double __lx[4];
        };
        typedef __type_list<__align_type<unsigned char>, __type_list<__align_type<unsigned short>, __type_list<__align_type<unsigned int>, __type_list<__align_type<unsigned long>, __type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<std::__1::__struct_double>, __type_list<__align_type<std::__1::__struct_double4>, __type_list<__align_type<int *>, std::__1::__nat> > > > > > > > > > __all_types;
        template <class _TL, size_t _Align> struct __find_pod;
        struct __find_pod {
            typedef typename conditional<_Align == _Hp::value, typename _Hp::type, void>::type type;
        };
        struct __find_pod {
            typedef typename conditional<_Align == _Hp::value, typename _Hp::type, typename __find_pod<_Tp, _Align>::type>::type type;
        };
        template <class _TL = std::__1::__type_list<std::__1::__align_type<unsigned char>, std::__1::__type_list<std::__1::__align_type<unsigned short>, std::__1::__type_list<std::__1::__align_type<unsigned int>, std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > > > > >, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned char>::value, __find_max_align<__type_list<__align_type<unsigned short>, __type_list<__align_type<unsigned int>, __type_list<__align_type<unsigned long>, __type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > > > > > >, 24UL>::value>::value> {
        }
template <class _TL = std::__1::__type_list<std::__1::__align_type<unsigned short>, std::__1::__type_list<std::__1::__align_type<unsigned int>, std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > > > >, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned short>::value, __find_max_align<__type_list<__align_type<unsigned int>, __type_list<__align_type<unsigned long>, __type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > > > > >, 24UL>::value>::value> {
        }
template <class _TL = std::__1::__type_list<std::__1::__align_type<unsigned int>, std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > > >, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned int>::value, __find_max_align<__type_list<__align_type<unsigned long>, __type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > > > >, 24UL>::value>::value> {
        }
template <class _TL = std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > >, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned long>::value, __find_max_align<__type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > > >, 24UL>::value>::value> {
        }
template <class _TL = std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > >, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned long long>::value, __find_max_align<__type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > >, 24UL>::value>::value> {
        }
template <class _TL = std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > >, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __select_align<24UL, __align_type<double>::value, __find_max_align<__type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > >, 24UL>::value>::value> {
        }
template <class _TL = std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > >, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __select_align<24UL, __align_type<long double>::value, __find_max_align<__type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > >, 24UL>::value>::value> {
        }
template <class _TL = std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > >, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __select_align<24UL, __align_type<__struct_double>::value, __find_max_align<__type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> >, 24UL>::value>::value> {
        }
template <class _TL = std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> >, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __select_align<24UL, __align_type<__struct_double4>::value, __find_max_align<__type_list<__align_type<int *>, __nat>, 24UL>::value>::value> {
        }
template <class _TL = std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat>, size_t _Len = 24> struct __find_max_align : public integral_constant<size_t, __align_type<int *>::value> {
        }
template <class _TL, size_t _Len> struct __find_max_align;
        struct __find_max_align : public integral_constant<size_t, _Hp::value> {
        };
        template <size_t _Len = 24, size_t _A1 = 8, size_t _A2 = 8> struct __select_align {
        private:
            static const size_t __min = 8UL < 8UL ? 8UL : 8UL;
            static const size_t __max = 8UL < 8UL ? 8UL : 8UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        }
template <size_t _Len = 24, size_t _A1 = 16, size_t _A2 = 8> struct __select_align {
        private:
            static const size_t __min = 8UL < 16UL ? 8UL : 16UL;
            static const size_t __max = 16UL < 8UL ? 8UL : 16UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        }
template <size_t _Len = 24, size_t _A1 = 16, size_t _A2 = 16> struct __select_align {
        private:
            static const size_t __min = 16UL < 16UL ? 16UL : 16UL;
            static const size_t __max = 16UL < 16UL ? 16UL : 16UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        }
template <size_t _Len = 24, size_t _A1 = 8, size_t _A2 = 16> struct __select_align {
        private:
            static const size_t __min = 16UL < 8UL ? 16UL : 8UL;
            static const size_t __max = 8UL < 16UL ? 16UL : 8UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        }
template <size_t _Len = 24, size_t _A1 = 4, size_t _A2 = 16> struct __select_align {
        private:
            static const size_t __min = 16UL < 4UL ? 16UL : 4UL;
            static const size_t __max = 4UL < 16UL ? 16UL : 4UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        }
template <size_t _Len = 24, size_t _A1 = 2, size_t _A2 = 16> struct __select_align {
        private:
            static const size_t __min = 16UL < 2UL ? 16UL : 2UL;
            static const size_t __max = 2UL < 16UL ? 16UL : 2UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        }
template <size_t _Len = 24, size_t _A1 = 1, size_t _A2 = 16> struct __select_align {
        private:
            static const size_t __min = 16UL < 1UL ? 16UL : 1UL;
            static const size_t __max = 1UL < 16UL ? 16UL : 1UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        }
template <size_t _Len, size_t _A1, size_t _A2> struct __select_align {
        private:
            static const size_t __min = _A2 < _A1 ? _A2 : _A1;
            static const size_t __max = _A1 < _A2 ? _A2 : _A1;
        public:
            static const size_t value = _Len < __max ? __min : __max;
        };
        struct __find_max_align : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {
        };
        template <size_t _Len = 24, size_t _Align = 16> struct aligned_storage {
            struct alignas(16) type {
                unsigned char __lx[24];
            };
        }
template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value> struct __attribute__((type_visibility("default"))) aligned_storage {
            typedef typename __find_pod<__all_types, _Align>::type _Aligner;
            static_assert(!is_void<_Aligner>::value, "");
            union type {
                _Aligner __align;
                unsigned char __data[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(1) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(2) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(4) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(8) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(16) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(32) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(64) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(128) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(256) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(512) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(1024) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(2048) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(4096) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(8192) type {
                unsigned char __lx[_Len];
            };
        };
        struct __attribute__((type_visibility("default"))) aligned_storage {
            struct alignas(16384) type {
                unsigned char __lx[_Len];
            };
        };
        template <size_t _I0, size_t ..._In> struct __static_max;
        struct __static_max {
            static const size_t value = _I0;
        };
        struct __static_max {
            static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value : __static_max<_I1, _In...>::value;
        };
        template <size_t _Len, class _Type0, class ..._Types> struct aligned_union {
            static const size_t alignment_value = __static_max<alignof(_Type0), alignof(_Types)...>::value;
            static const size_t __len = __static_max<_Len, sizeof(_Type0), sizeof(_Types)...>::value;
            typedef typename aligned_storage<__len, alignment_value>::type type;
        };
        template <class _Tp = void> struct __numeric_type {
            static const bool value = true;
        }
template <class _Tp> struct __numeric_type {
            static void __test(...);
            static float __test(float);
            static double __test(char);
            static double __test(int);
            static double __test(unsigned int);
            static double __test(long);
            static double __test(unsigned long);
            static double __test(long long);
            static double __test(unsigned long long);
            static double __test(double);
            static long double __test(long double);
            typedef decltype(__test(declval<_Tp>())) type;
            static const bool value = !is_same<type, void>::value;
        };
        struct __numeric_type {
            static const bool value = true;
        };
        template <class _A1, class _A2 = void, class _A3 = void, bool = __numeric_type<_A1>::value && __numeric_type<_A2>::value && __numeric_type<_A3>::value> class __promote_imp {
        public:
            static const bool value = false;
        };
        class __promote_imp {
        private:
            typedef typename __promote_imp<_A1>::type __type1;
            typedef typename __promote_imp<_A2>::type __type2;
            typedef typename __promote_imp<_A3>::type __type3;
        public:
            typedef decltype(__type1() + __type2() + __type3()) type;
            static const bool value = true;
        };
        class __promote_imp {
        private:
            typedef typename __promote_imp<_A1>::type __type1;
            typedef typename __promote_imp<_A2>::type __type2;
        public:
            typedef decltype(__type1() + __type2()) type;
            static const bool value = true;
        };
        class __promote_imp {
        public:
            typedef typename __numeric_type<_A1>::type type;
            static const bool value = true;
        };
        template <class _A1, class _A2 = void, class _A3 = void> class __promote : public __promote_imp<_A1, _A2, _A3> {
        };
        typedef __type_list<signed char, __type_list<short, __type_list<int, __type_list<long, __type_list<long long, __type_list<__int128_t, std::__1::__nat> > > > > > __signed_types;
        typedef __type_list<unsigned char, __type_list<unsigned short, __type_list<unsigned int, __type_list<unsigned long, __type_list<unsigned long long, __type_list<__uint128_t, std::__1::__nat> > > > > > __unsigned_types;
        template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
        struct __find_first {
            typedef _Hp type;
        };
        struct __find_first {
            typedef typename __find_first<_Tp, _Size>::type type;
        };
        template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value, bool = is_volatile<typename remove_reference<_Tp>::type>::value> struct __apply_cv {
            typedef _Up type;
        };
        struct __apply_cv {
            typedef const _Up type;
        };
        struct __apply_cv {
            typedef volatile _Up type;
        };
        struct __apply_cv {
            typedef const volatile _Up type;
        };
        struct __apply_cv {
            typedef _Up &type;
        };
        struct __apply_cv {
            typedef const _Up &type;
        };
        struct __apply_cv {
            typedef volatile _Up &type;
        };
        struct __apply_cv {
            typedef const volatile _Up &type;
        };
        template <class _Tp = bool, bool = true> struct __make_signed {
        }
template <class _Tp = short, bool = true> struct __make_signed {
            typedef short type;
        }
template <class _Tp = unsigned short, bool = true> struct __make_signed {
            typedef short type;
        }
template <class _Tp = int, bool = true> struct __make_signed {
            typedef int type;
        }
template <class _Tp = unsigned int, bool = true> struct __make_signed {
            typedef int type;
        }
template <class _Tp = long, bool = true> struct __make_signed {
            typedef long type;
        }
template <class _Tp = unsigned long, bool = true> struct __make_signed {
            typedef long type;
        }
template <class _Tp = long long, bool = true> struct __make_signed {
            typedef long long type;
        }
template <class _Tp = unsigned long long, bool = true> struct __make_signed {
            typedef long long type;
        }
template <class _Tp = __int128, bool = true> struct __make_signed {
            typedef __int128_t type;
        }
template <class _Tp = unsigned __int128, bool = true> struct __make_signed {
            typedef __int128_t type;
        }
template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value> struct __make_signed {
        };
        struct __make_signed {
            typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
        };
        struct __make_signed {
        };
        struct __make_signed {
            typedef short type;
        };
        struct __make_signed {
            typedef short type;
        };
        struct __make_signed {
            typedef int type;
        };
        struct __make_signed {
            typedef int type;
        };
        struct __make_signed {
            typedef long type;
        };
        struct __make_signed {
            typedef long type;
        };
        struct __make_signed {
            typedef long long type;
        };
        struct __make_signed {
            typedef long long type;
        };
        struct __make_signed {
            typedef __int128_t type;
        };
        struct __make_signed {
            typedef __int128_t type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) make_signed {
            typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
        };
        template <class _Tp = bool, bool = true> struct __make_unsigned {
        }
template <class _Tp = short, bool = true> struct __make_unsigned {
            typedef unsigned short type;
        }
template <class _Tp = unsigned short, bool = true> struct __make_unsigned {
            typedef unsigned short type;
        }
template <class _Tp = int, bool = true> struct __make_unsigned {
            typedef unsigned int type;
        }
template <class _Tp = unsigned int, bool = true> struct __make_unsigned {
            typedef unsigned int type;
        }
template <class _Tp = long, bool = true> struct __make_unsigned {
            typedef unsigned long type;
        }
template <class _Tp = unsigned long, bool = true> struct __make_unsigned {
            typedef unsigned long type;
        }
template <class _Tp = long long, bool = true> struct __make_unsigned {
            typedef unsigned long long type;
        }
template <class _Tp = unsigned long long, bool = true> struct __make_unsigned {
            typedef unsigned long long type;
        }
template <class _Tp = __int128, bool = true> struct __make_unsigned {
            typedef __uint128_t type;
        }
template <class _Tp = unsigned __int128, bool = true> struct __make_unsigned {
            typedef __uint128_t type;
        }
template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value> struct __make_unsigned {
        };
        struct __make_unsigned {
            typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
        };
        struct __make_unsigned {
        };
        struct __make_unsigned {
            typedef unsigned short type;
        };
        struct __make_unsigned {
            typedef unsigned short type;
        };
        struct __make_unsigned {
            typedef unsigned int type;
        };
        struct __make_unsigned {
            typedef unsigned int type;
        };
        struct __make_unsigned {
            typedef unsigned long type;
        };
        struct __make_unsigned {
            typedef unsigned long type;
        };
        struct __make_unsigned {
            typedef unsigned long long type;
        };
        struct __make_unsigned {
            typedef unsigned long long type;
        };
        struct __make_unsigned {
            typedef __uint128_t type;
        };
        struct __make_unsigned {
            typedef __uint128_t type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) make_unsigned {
            typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
        };
        template <class ..._Tp = <std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >>> struct common_type {
            typedef chrono::duration<typename common_type<long long, long long>::type, typename __ratio_gcd<ratio<1, 1000000000>, ratio<1, 1000000000> >::type> type;
        }
template <class ..._Tp = <long long, long long>> struct common_type {
        private:
            static long long &&__t();
            static long long &&__u();
            static bool __f();
        public:
            typedef typename decay<decltype(__f() ? __t() : __u())>::type type;
        }
template <class ..._Tp> struct common_type;
        struct __attribute__((type_visibility("default"))) common_type {
            typedef typename decay<_Tp>::type type;
        };
        struct __attribute__((type_visibility("default"))) common_type {
        private:
            static _Tp &&__t();
            static _Up &&__u();
            static bool __f();
        public:
            typedef typename decay<decltype(__f() ? __t() : __u())>::type type;
        };
        struct __attribute__((type_visibility("default"))) common_type {
            typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
        };
        template <typename , typename _Tp> struct __select_2nd {
            typedef _Tp type;
        };
        template <class _Tp, class _Arg> typename __select_2nd<decltype((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type __is_assignable_test(_Tp &&, _Arg &&);
        template <class _Arg> false_type __is_assignable_test(std::__1::__any, _Arg &&);
        template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value> struct __is_assignable_imp : public common_type<decltype(std::__1::__is_assignable_test(declval<_Tp>(), declval<_Arg>()))>::type {
        };
        struct __is_assignable_imp : public false_type {
        };
        template <class _Tp, class _Arg> struct is_assignable : public __is_assignable_imp<_Tp, _Arg> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_copy_assignable : public is_assignable<typename add_lvalue_reference<_Tp>::type, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_move_assignable : public is_assignable<typename add_lvalue_reference<_Tp>::type, const typename add_rvalue_reference<_Tp>::type> {
        };
        template <class > struct __is_destructible_apply {
            typedef int type;
        };
        template <typename _Tp> struct __is_destructor_wellformed {
            template <typename _Tp1> static char __test(typename __is_destructible_apply<decltype(std::__1::declval<_Tp1 &>().~_Tp1())>::type);
            template <typename _Tp1> static std::__1::__two __test(...);
            static const bool value = sizeof (__test<_Tp>(12)) == sizeof(char);
        };
        template <class _Tp, bool> struct __destructible_imp;
        struct __destructible_imp : public std::__1::integral_constant<bool, __is_destructor_wellformed<typename std::__1::remove_all_extents<_Tp>::type>::value> {
        };
        struct __destructible_imp : public std::__1::true_type {
        };
        template <class _Tp, bool> struct __destructible_false;
        struct __destructible_false : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {
        };
        struct __destructible_false : public std::__1::false_type {
        };
        template <class _Tp = void> struct is_destructible : public std::__1::false_type {
        }
template <class _Tp> struct is_destructible : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {
        };
        struct is_destructible : public std::__1::false_type {
        };
        struct is_destructible : public std::__1::false_type {
        };
        template <class _Tp = std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > &> inline typename remove_reference<__compressed_pair<__rep, allocator<char> > &>::type &&move(std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > &&__t) noexcept __attribute__((always_inline))         {
            typedef typename remove_reference<__compressed_pair<__rep, allocator<char> > &>::type _Up;
            return static_cast<_Up &&>(__t);
        }

template <class _Tp = std::__1::__compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> > &> inline typename remove_reference<__compressed_pair<__rep, allocator<wchar_t> > &>::type &&move(std::__1::__compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> > &&__t) noexcept __attribute__((always_inline))         {
            typedef typename remove_reference<__compressed_pair<__rep, allocator<wchar_t> > &>::type _Up;
            return static_cast<_Up &&>(__t);
        }

template <class _Tp> inline typename remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename remove_reference<_Tp>::type _Up;
            return static_cast<_Up &&>(__t);
        }

;
        template <class _Tp> inline _Tp &&forward(typename std::remove_reference<_Tp>::type &__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<_Tp &&>(__t);
        }

;
        template <class _Tp> inline _Tp &&forward(typename std::remove_reference<_Tp>::type &&__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            static_assert(!std::is_lvalue_reference<_Tp>::value, "Can not forward an rvalue as an lvalue.");
            return static_cast<_Tp &&>(__t);
        }

;
        template <class _Tp> inline typename decay<_Tp>::type __decay_copy(_Tp &&__t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::forward<_Tp>(__t);
        }

;
        struct __member_pointer_traits_imp {
            typedef _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef const _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef const _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef volatile _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef volatile _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef const volatile _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef const volatile _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef _Class &_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef _Class &_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef const _Class &_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef const _Class &_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef volatile _Class &_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef volatile _Class &_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef const volatile _Class &_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef const volatile _Class &_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef _Class &&_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef _Class &&_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef const _Class &&_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef const _Class &&_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef volatile _Class &&_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef volatile _Class &&_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef const volatile _Class &&_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        struct __member_pointer_traits_imp {
            typedef const volatile _Class &&_ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        struct __member_pointer_traits_imp {
            typedef _Class _ClassType;
            typedef _Rp _ReturnType;
        };
        template <class _MP> struct __member_pointer_traits : public __member_pointer_traits_imp<typename remove_cv<_MP>::type, is_member_function_pointer<_MP>::value, is_member_object_pointer<_MP>::value> {
        };
        template <class _Callable> class result_of;
        namespace __is_construct {
            struct __nat {
            };
        }
        template <class _Tp = std::__1::allocator<char>, class ..._Args = <std::__1::allocator<char> &&>> struct is_constructible : public integral_constant<bool, __is_constructible(std::__1::allocator<char>, std::__1::allocator<char> &&)> {
        }
template <class _Tp = std::__1::allocator<wchar_t>, class ..._Args = <std::__1::allocator<wchar_t> &&>> struct is_constructible : public integral_constant<bool, __is_constructible(std::__1::allocator<wchar_t>, std::__1::allocator<wchar_t> &&)> {
        }
template <class _Tp, class ..._Args> struct __attribute__((type_visibility("default"))) is_constructible : public integral_constant<bool, __is_constructible(_Tp, _Args...)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_default_constructible : public is_constructible<_Tp> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_copy_constructible : public is_constructible<_Tp, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_move_constructible : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type> {
        };
        template <class _Tp, class ..._Args> struct __attribute__((type_visibility("default"))) is_trivially_constructible : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_default_constructible : public is_trivially_constructible<_Tp> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_copy_constructible : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_move_constructible : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type> {
        };
        template <class _Tp, class _Arg> struct is_trivially_assignable : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_copy_assignable : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_move_assignable : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type, typename add_rvalue_reference<_Tp>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_destructible : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {
        };
        template <bool = true, bool = false, class _Tp = std::__1::allocator<char>, class ..._Args = <std::__1::allocator<char> &&>> struct __libcpp_is_nothrow_constructible : public integral_constant<bool, noexcept(std::__1::allocator<char>(declval<std::__1::allocator<char> &&>()))> {
        }
template <bool = true, bool = false, class _Tp = std::__1::allocator<wchar_t>, class ..._Args = <std::__1::allocator<wchar_t> &&>> struct __libcpp_is_nothrow_constructible : public integral_constant<bool, noexcept(std::__1::allocator<wchar_t>(declval<std::__1::allocator<wchar_t> &&>()))> {
        }
template <bool, bool, class _Tp, class ..._Args> struct __libcpp_is_nothrow_constructible;
        struct __libcpp_is_nothrow_constructible : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))> {
        };
        template <class _Tp> void __implicit_conversion_to(_Tp) noexcept         {
        }

;
        struct __libcpp_is_nothrow_constructible : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))> {
        };
        struct __libcpp_is_nothrow_constructible : public false_type {
        };
        template <class _Tp = std::__1::allocator<char>, class ..._Args = <std::__1::allocator<char> &&>> struct is_nothrow_constructible : __libcpp_is_nothrow_constructible<is_constructible<allocator<char>, allocator<char> &&>::value, is_reference<allocator<char> >::value, std::__1::allocator<char>, std::__1::allocator<char> &&> {
        }
template <class _Tp = std::__1::allocator<wchar_t>, class ..._Args = <std::__1::allocator<wchar_t> &&>> struct is_nothrow_constructible : __libcpp_is_nothrow_constructible<is_constructible<allocator<wchar_t>, allocator<wchar_t> &&>::value, is_reference<allocator<wchar_t> >::value, std::__1::allocator<wchar_t>, std::__1::allocator<wchar_t> &&> {
        }
template <class _Tp, class ..._Args> struct __attribute__((type_visibility("default"))) is_nothrow_constructible : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...> {
        };
        struct __attribute__((type_visibility("default"))) is_nothrow_constructible : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_default_constructible : public is_nothrow_constructible<_Tp> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_copy_constructible : public is_nothrow_constructible<_Tp, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
        template <class _Tp = std::__1::allocator<char>> struct is_nothrow_move_constructible : public is_nothrow_constructible<std::__1::allocator<char>, typename add_rvalue_reference<allocator<char> >::type> {
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct is_nothrow_move_constructible : public is_nothrow_constructible<std::__1::allocator<wchar_t>, typename add_rvalue_reference<allocator<wchar_t> >::type> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_move_constructible : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type> {
        };
        template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;
        struct __libcpp_is_nothrow_assignable : public false_type {
        };
        struct __libcpp_is_nothrow_assignable : public integral_constant<bool, noexcept(std::__1::declval<_Tp>() = std::__1::declval<_Arg>())> {
        };
        template <class _Tp, class _Arg> struct __attribute__((type_visibility("default"))) is_nothrow_assignable : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_copy_assignable : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_move_assignable : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type, typename add_rvalue_reference<_Tp>::type> {
        };
        template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;
        struct __libcpp_is_nothrow_destructible : public false_type {
        };
        struct __libcpp_is_nothrow_destructible : public integral_constant<bool, noexcept(std::__1::declval<_Tp>().~_Tp())> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_destructible : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp> {
        };
        struct __attribute__((type_visibility("default"))) is_nothrow_destructible : public is_nothrow_destructible<_Tp> {
        };
        struct __attribute__((type_visibility("default"))) is_nothrow_destructible : public true_type {
        };
        struct __attribute__((type_visibility("default"))) is_nothrow_destructible : public true_type {
        };
        template <class _Tp = char> struct is_pod : public integral_constant<bool, __is_pod(char)> {
        }
template <class _Tp = wchar_t> struct is_pod : public integral_constant<bool, __is_pod(wchar_t)> {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_pod : public integral_constant<bool, __is_pod(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_literal_type : public integral_constant<bool, __is_literal(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
        };
        template <class ..._Tp = <>> struct __check_complete {
        }
template <class ..._Tp> struct __check_complete;
        struct __check_complete {
        };
        struct __check_complete : private __check_complete<_Hp>, private __check_complete<_T0, _Tp...> {
        };
        struct __check_complete : private __check_complete<_Hp> {
        };
        struct __check_complete {
            static_assert(sizeof(_Tp) > 0, "Type must be complete.");
        };
        struct __check_complete : private __check_complete<_Tp> {
        };
        struct __check_complete : private __check_complete<_Tp> {
        };
        struct __check_complete : private __check_complete<_Rp> {
        };
        struct __check_complete {
        };
        struct __check_complete : private __check_complete<_Rp> {
        };
        struct __check_complete {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        struct __check_complete : private __check_complete<_Class> {
        };
        template <class ..._Args> auto __invoke(std::__1::__any, _Args &&...__args) -> std::__1::__nat;
        template <class _Fp, class _A0, class ..._Args, class  = typename enable_if<is_member_function_pointer<typename remove_reference<_Fp>::type>::value && is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type, typename remove_reference<_A0>::type>::value>::type> auto __invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args) -> decltype((std::__1::forward<_A0>(__a0) .* __f)(std::__1::forward<_Args>(__args)...)) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Fp, class _A0, class ..._Args, class  = typename enable_if<is_member_function_pointer<typename remove_reference<_Fp>::type>::value && !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type, typename remove_reference<_A0>::type>::value>::type> auto __invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args) -> decltype(((*std::__1::forward<_A0>(__a0)) .* __f)(std::__1::forward<_Args>(__args)...)) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Fp, class _A0, class  = typename enable_if<is_member_object_pointer<typename remove_reference<_Fp>::type>::value && is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType, typename remove_reference<_A0>::type>::value>::type> auto __invoke(_Fp &&__f, _A0 &&__a0) -> decltype(std::__1::forward<_A0>(__a0) .* __f) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Fp, class _A0, class  = typename enable_if<is_member_object_pointer<typename remove_reference<_Fp>::type>::value && !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType, typename remove_reference<_A0>::type>::value>::type> auto __invoke(_Fp &&__f, _A0 &&__a0) -> decltype((*std::__1::forward<_A0>(__a0)) .* __f) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Fp, class ..._Args> auto __invoke(_Fp &&__f, _Args &&...__args) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Fp, class ..._Args> struct __invokable_imp : private __check_complete<_Fp> {
            typedef decltype(__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...)) type;
            static const bool value = !is_same<type, __nat>::value;
        };
        template <class _Fp, class ..._Args> struct __invokable : public integral_constant<bool, __invokable_imp<_Fp, _Args...>::value> {
        };
        template <bool _Invokable, class _Fp, class ..._Args> struct __invoke_of_imp {
        };
        struct __invoke_of_imp {
            typedef typename __invokable_imp<_Fp, _Args...>::type type;
        };
        template <class _Fp, class ..._Args> struct __invoke_of : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...> {
        };
        class __attribute__((type_visibility("default"))) result_of : public __invoke_of<_Fp, _Args...> {
        };
        template <class _Tp> inline typename enable_if<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>::type swap(_Tp &__x, _Tp &__y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::valueswap(_Tp &__x, _Tp &__y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            _Tp __t(std::__1::move(__x));
            __x = std::__1::move(__y);
            __y = std::__1::move(__t);
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2> inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) noexcept(noexcept(swap(*std::__1::declval<_ForwardIterator1>(), *std::__1::declval<_ForwardIterator2>()))iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) noexcept(noexcept(swap(*std::__1::declval<_ForwardIterator1>(), *std::__1::declval<_ForwardIterator2>()))) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            swap(*__a, *__b);
        }

;
        namespace __detail {
            using std::__1::swap;
            std::__1::__nat swap(std::__1::__any, std::__1::__any);
            template <class _Tp> struct __swappable {
                typedef decltype(swap(std::__1::declval<_Tp &>(), std::__1::declval<_Tp &>())) type;
                static const bool value = !is_same<type, __nat>::value;
            };
        }
        template <class _Tp> struct __is_swappable : public integral_constant<bool, __detail::__swappable<_Tp>::value> {
        };
        template <bool, class _Tp> struct __is_nothrow_swappable_imp : public integral_constant<bool, noexcept(swap(std::__1::declval<_Tp &>(), std::__1::declval<_Tp &>()))> {
        };
        struct __is_nothrow_swappable_imp : public false_type {
        };
        template <class _Tp> struct __is_nothrow_swappable : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp> {
        };
        template <class _Tp> struct underlying_type {
            typedef __underlying_type(_Tp) type;
        };
        template <class _Tp, bool = std::is_enum<_Tp>::value> struct __sfinae_underlying_type {
            typedef typename underlying_type<_Tp>::type type;
            typedef decltype(((type)1) + 0) __promoted_type;
        };
        struct __sfinae_underlying_type {
        };
        inline int __convert_to_integral(int __val) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __val;
        }


        inline unsigned int __convert_to_integral(unsigned int __val) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __val;
        }


        inline long __convert_to_integral(long __val) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __val;
        }


        inline unsigned long __convert_to_integral(unsigned long __val) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __val;
        }


        inline long long __convert_to_integral(long long __val) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __val;
        }


        inline unsigned long long __convert_to_integral(unsigned long long __val) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __val;
        }


        inline __int128_t __convert_to_integral(__int128_t __val) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __val;
        }


        inline __uint128_t __convert_to_integral(__uint128_t __val) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __val;
        }


        template <class _Tp> inline typename __sfinae_underlying_type<_Tp>::__promoted_type __convert_to_integral(_Tp __val) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __val;
        }

;
        template <class _Tp> struct __has_operator_addressof_member_imp {
            template <class _Up> static auto __test(int) -> typename __select_2nd<decltype(std::__1::declval<_Up>().operator&()), true_type>::type;
            template <class > static auto __test(long) -> false_type;
            static const bool value = decltype(__test<_Tp>(0))::value;
        };
        template <class _Tp> struct __has_operator_addressof_free_imp {
            template <class _Up> static auto __test(int) -> typename __select_2nd<decltype(operator&(std::__1::declval<_Up>())), true_type>::type;
            template <class > static auto __test(long) -> false_type;
            static const bool value = decltype(__test<_Tp>(0))::value;
        };
        template <class _Tp> struct __has_operator_addressof : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value || __has_operator_addressof_free_imp<_Tp>::value> {
        };
        const bool value;
        const bool value;
        const unsigned long value;
        const unsigned long value;
        const unsigned long value;
        const unsigned long value;
        const unsigned long value;
    }
}
namespace std {
    inline namespace __1 {
        template <class _Tp> class __attribute__((type_visibility("default"))) tuple_size;
        class __attribute__((type_visibility("default"))) tuple_size : public tuple_size<_Tp> {
        };
        class __attribute__((type_visibility("default"))) tuple_size : public tuple_size<_Tp> {
        };
        class __attribute__((type_visibility("default"))) tuple_size : public tuple_size<_Tp> {
        };
        template <size_t _Ip, class _Tp> class __attribute__((type_visibility("default"))) tuple_element;
        class __attribute__((type_visibility("default"))) tuple_element {
        public:
            typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
        };
        class __attribute__((type_visibility("default"))) tuple_element {
        public:
            typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
        };
        class __attribute__((type_visibility("default"))) tuple_element {
        public:
            typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
        };
        template <class _Tp> struct __tuple_like : false_type {
        };
        struct __tuple_like : public __tuple_like<_Tp> {
        };
        struct __tuple_like : public __tuple_like<_Tp> {
        };
        struct __tuple_like : public __tuple_like<_Tp> {
        };
        template <class ..._Tp = <>> class __attribute__((type_visibility("default"))) tuple {
        public:
            constexpr tuple() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Alloc> tuple(std::__1::allocator_arg_t, const _Alloc &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc> tuple(std::__1::allocator_arg_t, const _Alloc &, const std::__1::tuple<> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Up> tuple(array<_Up, 0>) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc, class _Up> tuple(std::__1::allocator_arg_t, const _Alloc &, array<_Up, 0>) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            void swap(std::__1::tuple<> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        }
template <class ..._Tp> class __attribute__((type_visibility("default"))) tuple;
        struct __tuple_like : true_type {
        };
        template <size_t _Ip, class ..._Tp> typename tuple_element<_Ip, tuple<_Tp...> >::type &get(tuple<_Tp...> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <size_t _Ip, class ..._Tp> const typename tuple_element<_Ip, tuple<_Tp...> >::type &get(const tuple<_Tp...> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <size_t _Ip, class ..._Tp> typename tuple_element<_Ip, tuple<_Tp...> >::type &&get(tuple<_Tp...> &&) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _T1 = unsigned long, class _T2 = unsigned long> struct pair
template <class _T1, class _T2> struct __attribute__((type_visibility("default"))) pair;
        struct __tuple_like : true_type {
        };
        template <size_t _Ip, class _T1, class _T2> typename tuple_element<_Ip, pair<_T1, _T2> >::type &get(pair<_T1, _T2> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <size_t _Ip, class _T1, class _T2> const typename tuple_element<_Ip, pair<_T1, _T2> >::type &get(const pair<_T1, _T2> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <size_t _Ip, class _T1, class _T2> typename tuple_element<_Ip, pair<_T1, _T2> >::type &&get(pair<_T1, _T2> &&) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Tp, size_t _Size> struct __attribute__((type_visibility("default"))) array;
        struct __tuple_like : true_type {
        };
        template <size_t _Ip, class _Tp, size_t _Size> _Tp &get(array<_Tp, _Size> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <size_t _Ip, class _Tp, size_t _Size> const _Tp &get(const array<_Tp, _Size> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <size_t _Ip, class _Tp, size_t _Size> _Tp &&get(array<_Tp, _Size> &&) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <bool _Last = true, class ..._Preds = <>> struct __lazy_and_impl : true_type {
        }
template <bool _Last, class ..._Preds> struct __lazy_and_impl;
        struct __lazy_and_impl : false_type {
        };
        struct __lazy_and_impl : true_type {
        };
        struct __lazy_and_impl : integral_constant<bool, _Pred::type::value> {
        };
        struct __lazy_and_impl : __lazy_and_impl<_Hp::type::value, _Tp...> {
        };
        template <class _P1, class ..._Pr> struct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {
        };
        template <class _Pred> struct __lazy_not : integral_constant<bool, !_Pred::type::value> {
        };
        template <size_t ... = <>> struct __tuple_indices {
        }
template <size_t ...> struct __tuple_indices {
        };
        template <size_t _Sp = 0, class _IntTuple = std::__1::__tuple_indices<>, size_t _Ep = 0> struct __make_indices_imp {
            typedef __tuple_indices<> type;
        }
template <size_t _Sp, class _IntTuple, size_t _Ep> struct __make_indices_imp;
        struct __make_indices_imp {
            typedef typename __make_indices_imp<_Sp + 1, __tuple_indices<_Indices..., _Sp>, _Ep>::type type;
        };
        struct __make_indices_imp {
            typedef __tuple_indices<_Indices...> type;
        };
        template <size_t _Ep = 0, size_t _Sp = 0> struct __make_tuple_indices {
            static_assert(0UL <= 0UL, "__make_tuple_indices input error");
            typedef typename __make_indices_imp<0UL, __tuple_indices<>, 0UL>::type type;
        }
template <size_t _Ep, size_t _Sp = 0> struct __make_tuple_indices {
            static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
            typedef typename __make_indices_imp<_Sp, __tuple_indices<>, _Ep>::type type;
        };
        template <class ..._Tp = <>> struct __tuple_types
template <class ..._Tp> struct __tuple_types {
        };
        class __attribute__((type_visibility("default"))) tuple_element {
        public:
            static_assert(_Ip == 0, "tuple_element index out of range");
            static_assert(_Ip != 0, "tuple_element index out of range");
        };
        class __attribute__((type_visibility("default"))) tuple_element {
        public:
            typedef _Hp type;
        };
        class __attribute__((type_visibility("default"))) tuple_element {
        public:
            typedef typename tuple_element<_Ip - 1, __tuple_types<_Tp...> >::type type;
        };
        class __attribute__((type_visibility("default"))) tuple_size : public integral_constant<size_t, sizeof...(_Tp)> {
        };
        struct __tuple_like : true_type {
        };
        template <class _TupleTypes, class _Tp, size_t _Sp, size_t _Ep> struct __make_tuple_types_imp;
        struct __make_tuple_types_imp {
            typedef typename remove_reference<_Tp>::type _Tpr;
            typedef typename __make_tuple_types_imp<__tuple_types<_Types..., typename conditional<is_lvalue_reference<_Tp>::value, typename tuple_element<_Sp, _Tpr>::type &, typename tuple_element<_Sp, _Tpr>::type>::type>, _Tp, _Sp + 1, _Ep>::type type;
        };
        struct __make_tuple_types_imp {
            typedef __tuple_types<_Types...> type;
        };
        template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value, size_t _Sp = 0> struct __make_tuple_types {
            static_assert(_Sp <= _Ep, "__make_tuple_types input error");
            typedef typename __make_tuple_types_imp<__tuple_types<>, _Tp, _Sp, _Ep>::type type;
        };
        template <class  = std::__1::__tuple_types<>, class  = std::__1::__tuple_types<>> struct __tuple_convertible_imp : public true_type {
        }
template <class , class > struct __tuple_convertible_imp : public false_type {
        };
        struct __tuple_convertible_imp : public integral_constant<bool, is_convertible<_Tp0, _Up0>::value && __tuple_convertible_imp<__tuple_types<_Tp...>, __tuple_types<_Up...> >::value> {
        };
        struct __tuple_convertible_imp : public true_type {
        };
        template <bool, class , class > struct __tuple_convertible_apply : public false_type {
        };
        struct __tuple_convertible_apply : public __tuple_convertible_imp<typename __make_tuple_types<_Tp>::type, typename __make_tuple_types<_Up>::type> {
        };
        template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value, bool = __tuple_like<_Up>::value> struct __tuple_convertible : public false_type {
        };
        struct __tuple_convertible : public __tuple_convertible_apply<tuple_size<typename remove_reference<_Tp>::type>::value == tuple_size<_Up>::value, _Tp, _Up> {
        };
        template <class  = std::__1::__tuple_types<>, class  = std::__1::__tuple_types<>> struct __tuple_constructible_imp : public true_type {
        }
template <class , class > struct __tuple_constructible_imp : public false_type {
        };
        struct __tuple_constructible_imp : public integral_constant<bool, is_constructible<_Up0, _Tp0>::value && __tuple_constructible_imp<__tuple_types<_Tp...>, __tuple_types<_Up...> >::value> {
        };
        struct __tuple_constructible_imp : public true_type {
        };
        template <bool _SameSize, class , class > struct __tuple_constructible_apply : public false_type {
        };
        struct __tuple_constructible_apply : public __tuple_constructible_imp<typename __make_tuple_types<_Tp>::type, typename __make_tuple_types<_Up>::type> {
        };
        template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value, bool = __tuple_like<_Up>::value> struct __tuple_constructible : public false_type {
        };
        struct __tuple_constructible : public __tuple_constructible_apply<tuple_size<typename remove_reference<_Tp>::type>::value == tuple_size<_Up>::value, _Tp, _Up> {
        };
        template <class  = std::__1::__tuple_types<>, class  = std::__1::__tuple_types<>> struct __tuple_assignable_imp : public true_type {
        }
template <class , class > struct __tuple_assignable_imp : public false_type {
        };
        struct __tuple_assignable_imp : public integral_constant<bool, is_assignable<_Up0 &, _Tp0>::value && __tuple_assignable_imp<__tuple_types<_Tp...>, __tuple_types<_Up...> >::value> {
        };
        struct __tuple_assignable_imp : public true_type {
        };
        template <bool, class , class > struct __tuple_assignable_apply : public false_type {
        };
        struct __tuple_assignable_apply : __tuple_assignable_imp<typename __make_tuple_types<_Tp>::type, typename __make_tuple_types<_Up>::type> {
        };
        template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value, bool = __tuple_like<_Up>::value> struct __tuple_assignable : public false_type {
        };
        struct __tuple_assignable : public __tuple_assignable_apply<tuple_size<typename remove_reference<_Tp>::type>::value == tuple_size<_Up>::value, _Tp, _Up> {
        };
    }
}
namespace std {
    inline namespace __1 {
        namespace rel_ops {
            template <class _Tp> inline bool operator!=(const _Tp &__x, const _Tp &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__x == __y);
            }

;
            template <class _Tp> inline bool operator>(const _Tp &__x, const _Tp &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __y < __x;
            }

;
            template <class _Tp> inline bool operator<=(const _Tp &__x, const _Tp &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__y < __x);
            }

;
            template <class _Tp> inline bool operator>=(const _Tp &__x, const _Tp &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__x < __y);
            }

;
        }
        template <class _Tp, size_t _Np> inline void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2) 
                swap(*__first1, *__first2);
            return __first2;
        }

;
        template <class _Tp, size_t _Np> inline void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::swap_ranges(__a, __a + _Np, __b);
        }

;
        template <class _Tp> inline typename conditional<!is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value, const _Tp &, _Tp &&>::type move_if_noexcept(_Tp &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::move(__x);
        }

;
        struct __attribute__((type_visibility("default"))) piecewise_construct_t {
        };
        const std::__1::piecewise_construct_t piecewise_construct = std::__1::piecewise_construct_t();
        template <class _T1 = unsigned long, class _T2 = unsigned long> struct pair
template <class _T1, class _T2> struct __attribute__((type_visibility("default"))) pair {
            typedef _T1 first_type;
            typedef _T2 second_type;
            _T1 first;
            _T2 second;
            template <bool _Dummy = true, class  = typename enable_if<__dependent_type<is_default_constructible<_T1>, _Dummy>::value && __dependent_type<is_default_constructible<_T2>, _Dummy>::value>::type> constexpr pair<_T1, _T2>() : first(), second() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            pair<_T1, _T2>(const _T1 &__x, const _T2 &__y) : first(__x), second(__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _U1, class _U2> pair<_T1, _T2>(const pair<_U1, _U2> &__p, typename enable_if<is_convertible<const _U1 &, _T1>::value && is_convertible<const _U2 &, _T2>::value>::type * = 0) : first(__p.first), second(__p.second) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            pair<_T1, _T2>(const pair<_T1, _T2> &__p) __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
            pair<_T1, _T2> &operator=(const pair<_T1, _T2> &__p) noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::valueoperator=(const pair<_T1, _T2> &__p) noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->first = __p.first;
                this->second = __p.second;
                return *this;
            }


            template <class _U1, class _U2, class  = typename enable_if<is_convertible<_U1, first_type>::value && is_convertible<_U2, second_type>::value>::type> pair<_T1, _T2>(_U1 &&__u1, _U2 &&__u2) : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _U1, class _U2> pair<_T1, _T2>(pair<_U1, _U2> &&__p, typename enable_if<is_convertible<_U1, _T1>::value && is_convertible<_U2, _T2>::value>::type * = 0) : first(std::__1::forward<_U1>(__p.first)), second(std::__1::forward<_U2>(__p.second)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            pair<_T1, _T2>(pair<_T1, _T2> &&__p) __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
            pair<_T1, _T2> &operator=(pair<_T1, _T2> &&__p) noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::valueoperator=(pair<_T1, _T2> &&__p) noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->first = std::__1::forward<first_type>(__p.first);
                this->second = std::__1::forward<second_type>(__p.second);
                return *this;
            }


            template <class _Tuple, class  = typename enable_if<__tuple_convertible<_Tuple, pair<_T1, _T2> >::value>::type> pair<_T1, _T2>(_Tuple &&__p) : first(std::__1::forward<typename tuple_element<0, typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<0>(__p))), second(std::__1::forward<typename tuple_element<1, typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<1>(__p))) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class ..._Args1, class ..._Args2> pair<_T1, _T2>(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) : pair<_T1, _T2>(__pc, __first_args, __second_args, typename __make_tuple_indices<sizeof...(_Args1)>::type(), typename __make_tuple_indices<sizeof...(_Args2)>::type()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tuple, class  = typename enable_if<__tuple_assignable<_Tuple, pair<_T1, _T2> >::value>::type> pair<_T1, _T2> &operator=(_Tuple &&__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename __make_tuple_types<_Tuple>::type _TupleRef;
                typedef typename tuple_element<0, _TupleRef>::type _U0;
                typedef typename tuple_element<1, _TupleRef>::type _U1;
                this->first = std::__1::forward<_U0>(std::__1::get<0>(__p));
                this->second = std::__1::forward<_U1>(std::__1::get<1>(__p));
                return *this;
            }

;
            void swap(pair<_T1, _T2> &__p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::valueswap(pair<_T1, _T2> &__p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::iter_swap(&this->first, &__p.first);
                std::__1::iter_swap(&this->second, &__p.second);
            }


        private:
            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> pair<_T1, _T2>(std::__1::piecewise_construct_t, tuple<_Args1...> &__first_args, tuple<_Args2...> &__second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        };
        template <class _T1, class _T2> inline bool operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.first == __y.first && __x.second == __y.second;
        }

;
        template <class _T1, class _T2> inline bool operator!=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }

;
        template <class _T1, class _T2> inline bool operator<(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
        }

;
        template <class _T1, class _T2> inline bool operator>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __y < __x;
        }

;
        template <class _T1, class _T2> inline bool operator>=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < __y);
        }

;
        template <class _T1, class _T2> inline bool operator<=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__y < __x);
        }

;
        template <class _T1, class _T2> inline typename enable_if<__is_swappable<_T1>::value && __is_swappable<_T2>::value, void>::type swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __x.swap(__y);
        }

;
        template <class _Tp> class __attribute__((type_visibility("default"))) reference_wrapper;
        template <class _Tp> struct __make_pair_return_impl {
            typedef _Tp type;
        };
        struct __make_pair_return_impl {
            typedef _Tp &type;
        };
        template <class _Tp> struct __make_pair_return {
            typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;
        };
        template <class _T1, class _T2> inline pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type> make_pair(_T1 &&__t1, _T2 &&__t2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>(std::__1::forward<_T1>(__t1), std::__1::forward<_T2>(__t2));
        }

;
        class __attribute__((type_visibility("default"))) tuple_size : public integral_constant<size_t, 2> {
        };
        class __attribute__((type_visibility("default"))) tuple_element {
        public:
            typedef _T1 type;
        };
        class __attribute__((type_visibility("default"))) tuple_element {
        public:
            typedef _T2 type;
        };
        template <size_t _Ip = 0> struct __get_pair {
            template <class _T1, class _T2> static _T1 &get(pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p.first;
            }

;
            template <class _T1, class _T2> static const _T1 &get(const pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p.first;
            }

;
            template <class _T1, class _T2> static _T1 &&get(pair<_T1, _T2> &&__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::forward<_T1>(__p.first);
            }

;
        }
template <size_t _Ip = 1> struct __get_pair {
            template <class _T1, class _T2> static _T2 &get(pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p.second;
            }

;
            template <class _T1, class _T2> static const _T2 &get(const pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p.second;
            }

;
            template <class _T1, class _T2> static _T2 &&get(pair<_T1, _T2> &&__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::forward<_T2>(__p.second);
            }

;
        }
template <size_t _Ip> struct __get_pair;
        struct __get_pair {
            template <class _T1, class _T2> static _T1 &get(pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p.first;
            }

;
            template <class _T1, class _T2> static const _T1 &get(const pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p.first;
            }

;
            template <class _T1, class _T2> static _T1 &&get(pair<_T1, _T2> &&__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::forward<_T1>(__p.first);
            }

;
        };
        struct __get_pair {
            template <class _T1, class _T2> static _T2 &get(pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p.second;
            }

;
            template <class _T1, class _T2> static const _T2 &get(const pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p.second;
            }

;
            template <class _T1, class _T2> static _T2 &&get(pair<_T1, _T2> &&__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::forward<_T2>(__p.second);
            }

;
        };
        template <size_t _Ip, class _T1, class _T2> inline typename tuple_element<_Ip, pair<_T1, _T2> >::type &get(pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __get_pair<_Ip>::get(__p);
        }

;
        template <size_t _Ip, class _T1, class _T2> inline const typename tuple_element<_Ip, pair<_T1, _T2> >::type &get(const pair<_T1, _T2> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __get_pair<_Ip>::get(__p);
        }

;
        template <size_t _Ip, class _T1, class _T2> inline typename tuple_element<_Ip, pair<_T1, _T2> >::type &&get(pair<_T1, _T2> &&__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __get_pair<_Ip>::get(std::__1::move(__p));
        }

;
    }
}
namespace std {
    class __attribute__((visibility("default"))) exception {
    public:
        exception() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        virtual ~std::exception() noexcept;
        virtual const char *what() const noexcept;
    };
    class __attribute__((visibility("default"))) bad_exception : public std::exception {
    public:
        bad_exception() noexcept : std::exception() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        virtual ~std::bad_exception() noexcept;
        virtual const char *what() const noexcept;
    };
    typedef void (*unexpected_handler)();
    unexpected_handler set_unexpected(unexpected_handler) noexcept __attribute__((visibility("default")));
    unexpected_handler get_unexpected() noexcept __attribute__((visibility("default")));
    void unexpected() [[noreturn]] __attribute__((visibility("default")));
    typedef void (*terminate_handler)();
    terminate_handler set_terminate(terminate_handler) noexcept __attribute__((visibility("default")));
    terminate_handler get_terminate() noexcept __attribute__((visibility("default")));
    void terminate() noexcept [[noreturn]] __attribute__((visibility("default")));
    bool uncaught_exception() noexcept __attribute__((visibility("default")));
    int uncaught_exceptions() noexcept __attribute__((availability(watchos, introduced=3.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(macos, introduced=10.12))) __attribute__((visibility("default")));
    class __attribute__((type_visibility("default"))) exception_ptr;
    std::exception_ptr current_exception() noexcept __attribute__((visibility("default")));
    void rethrow_exception(std::exception_ptr) [[noreturn]] __attribute__((visibility("default")));
    class __attribute__((type_visibility("default"))) exception_ptr {
        void *__ptr_;
    public:
        exception_ptr() noexcept : __ptr_(/*implicit*/void *()) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        exception_ptr(nullptr_t) noexcept : __ptr_(/*implicit*/void *()) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        exception_ptr(const std::exception_ptr &) noexcept;
        std::exception_ptr &operator=(const std::exception_ptr &) noexcept;
        ~std::exception_ptr() noexcept;
        explicit operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__ptr_ != nullptr;
        }


        friend bool operator==(const std::exception_ptr &__x, const std::exception_ptr &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.__ptr_ == __y.__ptr_;
        }

;
        friend bool operator!=(const std::exception_ptr &__x, const std::exception_ptr &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }

;
        friend std::exception_ptr current_exception() noexcept __attribute__((visibility("default")));
        friend void rethrow_exception(std::exception_ptr) __attribute__((visibility("default"))) [[noreturn]];
    };
    template <class _Ep> std::exception_ptr make_exception_ptr(_Ep __e) noexcept     {
        try {
            throw __e;
        } catch (...) {
            return current_exception();
        }
    }

;
    class __attribute__((visibility("default"))) nested_exception {
        std::exception_ptr __ptr_;
    public:
        nested_exception() noexcept;
        virtual ~std::nested_exception() noexcept;
        void rethrow_nested() const [[noreturn]];
        std::exception_ptr nested_ptr() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__ptr_;
        }


    };
    template <class _Tp> struct __nested : public _Tp, public std::nested_exception {
        explicit __nested<_Tp>(const _Tp &__t) : _Tp(__t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


    };
    template <class _Tp> void throw_with_nested(_Tp &&__t, typename enable_if<is_class<typename remove_reference<_Tp>::type>::value && !is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value && !__libcpp_is_final<typename remove_reference<_Tp>::type>::value>::type * = 0) [[noreturn]]     {
        throw __nested<typename remove_reference<_Tp>::type>(std::__1::forward<_Tp>(__t));
    }

;
    template <class _Tp> void throw_with_nested(_Tp &&__t, typename enable_if<!is_class<typename remove_reference<_Tp>::type>::value || is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value || __libcpp_is_final<typename remove_reference<_Tp>::type>::value>::type * = 0) [[noreturn]]     {
        throw std::__1::forward<_Tp>(__t);
    }

;
    template <class _Ep> inline void rethrow_if_nested(const _Ep &__e, typename enable_if<is_polymorphic<_Ep>::value>::type * = 0) __attribute__((always_inline)) __attribute__((visibility("hidden")))     {
        const std::nested_exception *__nep = dynamic_cast<const std::nested_exception *>(&__e);
        if (__nep)
            __nep->rethrow_nested();
    }

;
    template <class _Ep> inline void rethrow_if_nested(const _Ep &, typename enable_if<!is_polymorphic<_Ep>::value>::type * = 0) __attribute__((always_inline)) __attribute__((visibility("hidden")))     {
    }

;
}
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef __darwin_intptr_t intptr_t;
typedef unsigned long uintptr_t;
typedef long intmax_t;
typedef unsigned long uintmax_t;
namespace std {
    inline namespace __1 {
        using ::int8_t;
        using ::int16_t;
        using ::int32_t;
        using ::int64_t;
        using ::uint8_t;
        using ::uint16_t;
        using ::uint32_t;
        using ::uint64_t;
        using ::int_least8_t;
        using ::int_least16_t;
        using ::int_least32_t;
        using ::int_least64_t;
        using ::uint_least8_t;
        using ::uint_least16_t;
        using ::uint_least32_t;
        using ::uint_least64_t;
        using ::int_fast8_t;
        using ::int_fast16_t;
        using ::int_fast32_t;
        using ::int_fast64_t;
        using ::uint_fast8_t;
        using ::uint_fast16_t;
        using ::uint_fast32_t;
        using ::uint_fast64_t;
        using ::intptr_t;
        using ::uintptr_t;
        using ::intmax_t;
        using ::uintmax_t;
    }
}
namespace std {
    class __attribute__((visibility("default"))) type_info {
        std::type_info &operator=(const std::type_info &);
        type_info(const std::type_info &);
    protected:
        const char *__type_name;
        explicit type_info(const char *__n) : __type_name(__n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


    public:
        virtual ~std::type_info() noexcept __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)));
        const char *name() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__type_name;
        }


        bool before(const std::type_info &__arg) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__type_name < __arg.__type_name;
        }


        size_t hash_code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return *reinterpret_cast<const size_t *>(&this->__type_name);
        }


        bool operator==(const std::type_info &__arg) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__type_name == __arg.__type_name;
        }


        bool operator!=(const std::type_info &__arg) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !this->operator==(__arg);
        }


    };
    class __attribute__((visibility("default"))) bad_cast : public std::exception {
    public:
        bad_cast() noexcept;
        virtual ~std::bad_cast() noexcept;
        virtual const char *what() const noexcept;
    };
    class __attribute__((visibility("default"))) bad_typeid : public std::exception {
    public:
        bad_typeid() noexcept;
        virtual ~std::bad_typeid() noexcept;
        virtual const char *what() const noexcept;
    };
}
namespace std {
    class __attribute__((visibility("default"))) bad_alloc : public std::exception {
    public:
        bad_alloc() noexcept;
        virtual ~std::bad_alloc() noexcept;
        virtual const char *what() const noexcept;
    };
    class __attribute__((visibility("default"))) bad_array_new_length : public std::bad_alloc {
    public:
        bad_array_new_length() noexcept;
        virtual ~std::bad_array_new_length() noexcept;
        virtual const char *what() const noexcept;
    };
    void __throw_bad_alloc() __attribute__((visibility("default")));
    struct __attribute__((type_visibility("default"))) nothrow_t {
    };
    extern const std::nothrow_t nothrow __attribute__((visibility("default")));
    typedef void (*new_handler)();
    new_handler set_new_handler(new_handler) noexcept __attribute__((visibility("default")));
    new_handler get_new_handler() noexcept __attribute__((visibility("default")));
}
void *operator new(std::size_t __sz) __attribute__((visibility("default"))) __attribute__((malloc));
void *operator new(std::size_t __sz, const std::nothrow_t &) noexcept __attribute__((visibility("default"))) __attribute__((malloc));
void operator delete(void *__p) noexcept __attribute__((visibility("default")));
void operator delete(void *__p, const std::nothrow_t &) noexcept __attribute__((visibility("default")));
void *operator new[](std::size_t __sz) __attribute__((visibility("default"))) __attribute__((malloc));
void *operator new[](std::size_t __sz, const std::nothrow_t &) noexcept __attribute__((visibility("default"))) __attribute__((malloc));
void operator delete[](void *__p) noexcept __attribute__((visibility("default")));
void operator delete[](void *__p, const std::nothrow_t &) noexcept __attribute__((visibility("default")));
inline void *operator new(std::size_t, void *__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) {
    return __p;
}


inline void *operator new[](std::size_t, void *__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) {
    return __p;
}


inline void operator delete(void *, void *) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) {
}


inline void operator delete[](void *, void *) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) {
}


namespace std {
    inline namespace __1 {
        inline void *__allocate(size_t __size) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __builtin_operator_new(__size);
        }


        inline void __deallocate(void *__ptr) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __builtin_operator_delete(__ptr);
        }


    }
}
namespace std {
    inline namespace __1 {
        enum float_round_style {
            round_indeterminate = -1,
            round_toward_zero = 0,
            round_to_nearest = 1,
            round_toward_infinity = 2,
            round_toward_neg_infinity = 3
        };
        enum float_denorm_style {
            denorm_indeterminate = -1,
            denorm_absent = 0,
            denorm_present = 1
        };
        template <class _Tp = bool, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef bool type;
            static const bool is_specialized = true;
            static const bool is_signed = false;
            static const int digits = 1;
            static const int digits10 = 0;
            static const int max_digits10 = 0;
            static const type __min = false;
            static const type __max = true;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __min;
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return min();
            }


            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = false;
            static const bool traps = false;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        }
template <class _Tp = float, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef float type;
            static const bool is_specialized = true;
            static const bool is_signed = true;
            static const int digits = 24;
            static const int digits10 = 6;
            static const int max_digits10 = 2 + (digits * 30103) / 100000;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.17549435E-38F;
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 3.40282347E+38F;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return -max();
            }


            static const bool is_integer = false;
            static const bool is_exact = false;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.1920929E-7F;
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0.5F;
            }


            static const int min_exponent = (-125);
            static const int min_exponent10 = (-37);
            static const int max_exponent = 128;
            static const int max_exponent10 = 38;
            static const bool has_infinity = true;
            static const bool has_quiet_NaN = true;
            static const bool has_signaling_NaN = true;
            static const std::__1::float_denorm_style has_denorm = denorm_present;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_huge_valf();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nanf("");
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nansf("");
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.40129846E-45F;
            }


            static const bool is_iec559 = true;
            static const bool is_bounded = true;
            static const bool is_modulo = false;
            static const bool traps = false;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_to_nearest;
        }
template <class _Tp = double, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef double type;
            static const bool is_specialized = true;
            static const bool is_signed = true;
            static const int digits = 53;
            static const int digits10 = 15;
            static const int max_digits10 = 2 + (digits * 30103) / 100000;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 2.2250738585072014E-308;
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.7976931348623157E+308;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return -max();
            }


            static const bool is_integer = false;
            static const bool is_exact = false;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 2.2204460492503131E-16;
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0.5;
            }


            static const int min_exponent = (-1021);
            static const int min_exponent10 = (-307);
            static const int max_exponent = 1024;
            static const int max_exponent10 = 308;
            static const bool has_infinity = true;
            static const bool has_quiet_NaN = true;
            static const bool has_signaling_NaN = true;
            static const std::__1::float_denorm_style has_denorm = denorm_present;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_huge_val();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nan("");
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nans("");
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 4.9406564584124654E-324;
            }


            static const bool is_iec559 = true;
            static const bool is_bounded = true;
            static const bool is_modulo = false;
            static const bool traps = false;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_to_nearest;
        }
template <class _Tp = long double, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef long double type;
            static const bool is_specialized = true;
            static const bool is_signed = true;
            static const int digits = 64;
            static const int digits10 = 18;
            static const int max_digits10 = 2 + (digits * 30103) / 100000;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 3.36210314311209350626E-4932L;
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.18973149535723176502E+4932L;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return -max();
            }


            static const bool is_integer = false;
            static const bool is_exact = false;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.08420217248550443401E-19L;
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0.5;
            }


            static const int min_exponent = (-16381);
            static const int min_exponent10 = (-4931);
            static const int max_exponent = 16384;
            static const int max_exponent10 = 4932;
            static const bool has_infinity = true;
            static const bool has_quiet_NaN = true;
            static const bool has_signaling_NaN = true;
            static const std::__1::float_denorm_style has_denorm = denorm_present;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_huge_vall();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nanl("");
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nansl("");
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 3.64519953188247460253E-4951L;
            }


            static const bool is_iec559 = true;
            static const bool is_bounded = true;
            static const bool is_modulo = false;
            static const bool traps = false;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_to_nearest;
        }
template <class _Tp = long, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef long type;
            static const bool is_specialized = true;
            static const bool is_signed = type(-1) < type(0);
            static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
            static const int digits10 = digits * 3 / 10;
            static const int max_digits10 = 0;
            static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
            static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = !std::__1::is_signed<long>::value;
            static const bool traps = true;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        }
template <class _Tp = long long, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef long long type;
            static const bool is_specialized = true;
            static const bool is_signed = type(-1) < type(0);
            static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
            static const int digits10 = digits * 3 / 10;
            static const int max_digits10 = 0;
            static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
            static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = !std::__1::is_signed<long long>::value;
            static const bool traps = true;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        }
template <class _Tp = unsigned long, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef unsigned long type;
            static const bool is_specialized = true;
            static const bool is_signed = type(-1) < type(0);
            static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
            static const int digits10 = digits * 3 / 10;
            static const int max_digits10 = 0;
            static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
            static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = !std::__1::is_signed<unsigned long>::value;
            static const bool traps = true;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        }
template <class _Tp = unsigned long long, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef unsigned long long type;
            static const bool is_specialized = true;
            static const bool is_signed = type(-1) < type(0);
            static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
            static const int digits10 = digits * 3 / 10;
            static const int max_digits10 = 0;
            static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
            static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline));
            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = !std::__1::is_signed<unsigned long long>::value;
            static const bool traps = true;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        }
template <class _Tp = unsigned int, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef unsigned int type;
            static const bool is_specialized = true;
            static const bool is_signed = type(-1) < type(0);
            static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
            static const int digits10 = digits * 3 / 10;
            static const int max_digits10 = 0;
            static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
            static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = !std::__1::is_signed<unsigned int>::value;
            static const bool traps = true;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        }
template <class _Tp = char, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef char type;
            static const bool is_specialized = true;
            static const bool is_signed = type(-1) < type(0);
            static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
            static const int digits10 = digits * 3 / 10;
            static const int max_digits10 = 0;
            static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
            static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = !std::__1::is_signed<char>::value;
            static const bool traps = true;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        }
template <class _Tp = short, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef short type;
            static const bool is_specialized = true;
            static const bool is_signed = type(-1) < type(0);
            static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
            static const int digits10 = digits * 3 / 10;
            static const int max_digits10 = 0;
            static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
            static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
            static constexpr type min() noexcept __attribute__((always_inline))             {
                return __min;
            }


            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = !std::__1::is_signed<short>::value;
            static const bool traps = true;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        }
template <class _Tp = int, bool = true> class __libcpp_numeric_limits {
        protected:
            typedef int type;
            static const bool is_specialized = true;
            static const bool is_signed = type(-1) < type(0);
            static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
            static const int digits10 = digits * 3 / 10;
            static const int max_digits10 = 0;
            static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
            static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
            static constexpr type min() noexcept __attribute__((always_inline))             {
                return __min;
            }


            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = !std::__1::is_signed<int>::value;
            static const bool traps = true;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        }
template <class _Tp, bool = is_arithmetic<_Tp>::value> class __libcpp_numeric_limits {
        protected:
            typedef _Tp type;
            static const bool is_specialized = false;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type();
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type();
            }


            static const int digits = 0;
            static const int digits10 = 0;
            static const int max_digits10 = 0;
            static const bool is_signed = false;
            static const bool is_integer = false;
            static const bool is_exact = false;
            static const int radix = 0;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type();
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type();
            }


            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type();
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type();
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type();
            }


            static const bool is_iec559 = false;
            static const bool is_bounded = false;
            static const bool is_modulo = false;
            static const bool traps = false;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        };
        template <class _Tp = long, int digits = 63, bool is_signed = true> struct __libcpp_compute_min {
            static const long value = long(long(1) << 63);
        }
template <class _Tp = long long, int digits = 63, bool is_signed = true> struct __libcpp_compute_min {
            static const long long value = long long(long long(1) << 63);
        }
template <class _Tp = unsigned long, int digits = 64, bool is_signed = false> struct __libcpp_compute_min {
            static const unsigned long value = unsigned long(0);
        }
template <class _Tp = unsigned long long, int digits = 64, bool is_signed = false> struct __libcpp_compute_min {
            static const unsigned long long value = unsigned long long(0);
        }
template <class _Tp = unsigned int, int digits = 32, bool is_signed = false> struct __libcpp_compute_min {
            static const unsigned int value = unsigned int(0);
        }
template <class _Tp = char, int digits = 7, bool is_signed = true> struct __libcpp_compute_min {
            static const char value = char(char(1) << 7);
        }
template <class _Tp = short, int digits = 15, bool is_signed = true> struct __libcpp_compute_min {
            static const short value = short(short(1) << 15);
        }
template <class _Tp = int, int digits = 31, bool is_signed = true> struct __libcpp_compute_min {
            static const int value = int(int(1) << 31);
        }
template <class _Tp, int digits, bool is_signed> struct __libcpp_compute_min {
            static const _Tp value = _Tp(_Tp(1) << digits);
        };
        struct __libcpp_compute_min {
            static const _Tp value = _Tp(0);
        };
        class __libcpp_numeric_limits {
        protected:
            typedef _Tp type;
            static const bool is_specialized = true;
            static const bool is_signed = type(-1) < type(0);
            static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
            static const int digits10 = digits * 3 / 10;
            static const int max_digits10 = 0;
            static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
            static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __min;
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return min();
            }


            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = !std::__1::is_signed<_Tp>::value;
            static const bool traps = true;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        };
        class __libcpp_numeric_limits {
        protected:
            typedef bool type;
            static const bool is_specialized = true;
            static const bool is_signed = false;
            static const int digits = 1;
            static const int digits10 = 0;
            static const int max_digits10 = 0;
            static const type __min = false;
            static const type __max = true;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __min;
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __max;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return min();
            }


            static const bool is_integer = true;
            static const bool is_exact = true;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static const int min_exponent = 0;
            static const int min_exponent10 = 0;
            static const int max_exponent = 0;
            static const int max_exponent10 = 0;
            static const bool has_infinity = false;
            static const bool has_quiet_NaN = false;
            static const bool has_signaling_NaN = false;
            static const std::__1::float_denorm_style has_denorm = denorm_absent;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return type(0);
            }


            static const bool is_iec559 = false;
            static const bool is_bounded = true;
            static const bool is_modulo = false;
            static const bool traps = false;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_toward_zero;
        };
        class __libcpp_numeric_limits {
        protected:
            typedef float type;
            static const bool is_specialized = true;
            static const bool is_signed = true;
            static const int digits = 24;
            static const int digits10 = 6;
            static const int max_digits10 = 2 + (digits * 30103) / 100000;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.17549435E-38F;
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 3.40282347E+38F;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return -max();
            }


            static const bool is_integer = false;
            static const bool is_exact = false;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.1920929E-7F;
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0.5F;
            }


            static const int min_exponent = (-125);
            static const int min_exponent10 = (-37);
            static const int max_exponent = 128;
            static const int max_exponent10 = 38;
            static const bool has_infinity = true;
            static const bool has_quiet_NaN = true;
            static const bool has_signaling_NaN = true;
            static const std::__1::float_denorm_style has_denorm = denorm_present;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_huge_valf();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nanf("");
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nansf("");
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.40129846E-45F;
            }


            static const bool is_iec559 = true;
            static const bool is_bounded = true;
            static const bool is_modulo = false;
            static const bool traps = false;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_to_nearest;
        };
        class __libcpp_numeric_limits {
        protected:
            typedef double type;
            static const bool is_specialized = true;
            static const bool is_signed = true;
            static const int digits = 53;
            static const int digits10 = 15;
            static const int max_digits10 = 2 + (digits * 30103) / 100000;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 2.2250738585072014E-308;
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.7976931348623157E+308;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return -max();
            }


            static const bool is_integer = false;
            static const bool is_exact = false;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 2.2204460492503131E-16;
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0.5;
            }


            static const int min_exponent = (-1021);
            static const int min_exponent10 = (-307);
            static const int max_exponent = 1024;
            static const int max_exponent10 = 308;
            static const bool has_infinity = true;
            static const bool has_quiet_NaN = true;
            static const bool has_signaling_NaN = true;
            static const std::__1::float_denorm_style has_denorm = denorm_present;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_huge_val();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nan("");
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nans("");
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 4.9406564584124654E-324;
            }


            static const bool is_iec559 = true;
            static const bool is_bounded = true;
            static const bool is_modulo = false;
            static const bool traps = false;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_to_nearest;
        };
        class __libcpp_numeric_limits {
        protected:
            typedef long double type;
            static const bool is_specialized = true;
            static const bool is_signed = true;
            static const int digits = 64;
            static const int digits10 = 18;
            static const int max_digits10 = 2 + (digits * 30103) / 100000;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 3.36210314311209350626E-4932L;
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.18973149535723176502E+4932L;
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return -max();
            }


            static const bool is_integer = false;
            static const bool is_exact = false;
            static const int radix = 2;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 1.08420217248550443401E-19L;
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0.5;
            }


            static const int min_exponent = (-16381);
            static const int min_exponent10 = (-4931);
            static const int max_exponent = 16384;
            static const int max_exponent10 = 4932;
            static const bool has_infinity = true;
            static const bool has_quiet_NaN = true;
            static const bool has_signaling_NaN = true;
            static const std::__1::float_denorm_style has_denorm = denorm_present;
            static const bool has_denorm_loss = false;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_huge_vall();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nanl("");
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __builtin_nansl("");
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 3.64519953188247460253E-4951L;
            }


            static const bool is_iec559 = true;
            static const bool is_bounded = true;
            static const bool is_modulo = false;
            static const bool traps = false;
            static const bool tinyness_before = false;
            static const std::__1::float_round_style round_style = round_to_nearest;
        };
        template <class _Tp = long> class numeric_limits : private __libcpp_numeric_limits<typename remove_cv<long>::type> {
            typedef __libcpp_numeric_limits<typename remove_cv<long>::type> __base;
            typedef typename __base::type type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        }
template <class _Tp = long long> class numeric_limits : private __libcpp_numeric_limits<typename remove_cv<long long>::type> {
            typedef __libcpp_numeric_limits<typename remove_cv<long long>::type> __base;
            typedef typename __base::type type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        }
template <class _Tp = unsigned long> class numeric_limits : private __libcpp_numeric_limits<typename remove_cv<unsigned long>::type> {
            typedef __libcpp_numeric_limits<typename remove_cv<unsigned long>::type> __base;
            typedef typename __base::type type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        }
template <class _Tp = unsigned long long> class numeric_limits : private __libcpp_numeric_limits<typename remove_cv<unsigned long long>::type> {
            typedef __libcpp_numeric_limits<typename remove_cv<unsigned long long>::type> __base;
            typedef typename __base::type type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline));
            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        }
template <class _Tp = unsigned int> class numeric_limits : private __libcpp_numeric_limits<typename remove_cv<unsigned int>::type> {
            typedef __libcpp_numeric_limits<typename remove_cv<unsigned int>::type> __base;
            typedef typename __base::type type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        }
template <class _Tp = char> class numeric_limits : private __libcpp_numeric_limits<typename remove_cv<char>::type> {
            typedef __libcpp_numeric_limits<typename remove_cv<char>::type> __base;
            typedef typename __base::type type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline));
            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        }
template <class _Tp = short> class numeric_limits : private __libcpp_numeric_limits<typename remove_cv<short>::type> {
            typedef __libcpp_numeric_limits<typename remove_cv<short>::type> __base;
            typedef typename __base::type type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline))             {
                return __base::min();
            }


            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        }
template <class _Tp = int> class numeric_limits : private __libcpp_numeric_limits<typename remove_cv<int>::type> {
            typedef __libcpp_numeric_limits<typename remove_cv<int>::type> __base;
            typedef typename __base::type type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline))             {
                return __base::min();
            }


            static constexpr type max() noexcept __attribute__((always_inline))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline));
            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline));
            static constexpr type round_error() noexcept __attribute__((always_inline));
            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline));
            static constexpr type quiet_NaN() noexcept __attribute__((always_inline));
            static constexpr type signaling_NaN() noexcept __attribute__((always_inline));
            static constexpr type denorm_min() noexcept __attribute__((always_inline));
            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        }
template <class _Tp> class __attribute__((type_visibility("default"))) numeric_limits : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type> {
            typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
            typedef typename __base::type type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::min();
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::lowest();
            }


            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::epsilon();
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::round_error();
            }


            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::infinity();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::quiet_NaN();
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::signaling_NaN();
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::denorm_min();
            }


            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        };
        const bool is_specialized;
        const int digits;
        const int digits10;
        const int max_digits10;
        const bool is_signed;
        const bool is_integer;
        const bool is_exact;
        const int radix;
        const int min_exponent;
        const int min_exponent10;
        const int max_exponent;
        const int max_exponent10;
        const bool has_infinity;
        const bool has_quiet_NaN;
        const bool has_signaling_NaN;
        const std::__1::float_denorm_style has_denorm;
        const bool has_denorm_loss;
        const bool is_iec559;
        const bool is_bounded;
        const bool is_modulo;
        const bool traps;
        const bool tinyness_before;
        const std::__1::float_round_style round_style;
        class __attribute__((type_visibility("default"))) numeric_limits : private numeric_limits<_Tp> {
            typedef numeric_limits<_Tp> __base;
            typedef _Tp type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::min();
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::lowest();
            }


            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::epsilon();
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::round_error();
            }


            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::infinity();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::quiet_NaN();
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::signaling_NaN();
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::denorm_min();
            }


            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        };
        const bool is_specialized;
        const int digits;
        const int digits10;
        const int max_digits10;
        const bool is_signed;
        const bool is_integer;
        const bool is_exact;
        const int radix;
        const int min_exponent;
        const int min_exponent10;
        const int max_exponent;
        const int max_exponent10;
        const bool has_infinity;
        const bool has_quiet_NaN;
        const bool has_signaling_NaN;
        const std::__1::float_denorm_style has_denorm;
        const bool has_denorm_loss;
        const bool is_iec559;
        const bool is_bounded;
        const bool is_modulo;
        const bool traps;
        const bool tinyness_before;
        const std::__1::float_round_style round_style;
        class __attribute__((type_visibility("default"))) numeric_limits : private numeric_limits<_Tp> {
            typedef numeric_limits<_Tp> __base;
            typedef _Tp type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::min();
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::lowest();
            }


            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::epsilon();
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::round_error();
            }


            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::infinity();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::quiet_NaN();
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::signaling_NaN();
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::denorm_min();
            }


            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        };
        const bool is_specialized;
        const int digits;
        const int digits10;
        const int max_digits10;
        const bool is_signed;
        const bool is_integer;
        const bool is_exact;
        const int radix;
        const int min_exponent;
        const int min_exponent10;
        const int max_exponent;
        const int max_exponent10;
        const bool has_infinity;
        const bool has_quiet_NaN;
        const bool has_signaling_NaN;
        const std::__1::float_denorm_style has_denorm;
        const bool has_denorm_loss;
        const bool is_iec559;
        const bool is_bounded;
        const bool is_modulo;
        const bool traps;
        const bool tinyness_before;
        const std::__1::float_round_style round_style;
        class __attribute__((type_visibility("default"))) numeric_limits : private numeric_limits<_Tp> {
            typedef numeric_limits<_Tp> __base;
            typedef _Tp type;
        public:
            static const bool is_specialized = __base::is_specialized;
            static constexpr type min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::min();
            }


            static constexpr type max() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::max();
            }


            static constexpr type lowest() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::lowest();
            }


            static const int digits = __base::digits;
            static const int digits10 = __base::digits10;
            static const int max_digits10 = __base::max_digits10;
            static const bool is_signed = __base::is_signed;
            static const bool is_integer = __base::is_integer;
            static const bool is_exact = __base::is_exact;
            static const int radix = __base::radix;
            static constexpr type epsilon() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::epsilon();
            }


            static constexpr type round_error() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::round_error();
            }


            static const int min_exponent = __base::min_exponent;
            static const int min_exponent10 = __base::min_exponent10;
            static const int max_exponent = __base::max_exponent;
            static const int max_exponent10 = __base::max_exponent10;
            static const bool has_infinity = __base::has_infinity;
            static const bool has_quiet_NaN = __base::has_quiet_NaN;
            static const bool has_signaling_NaN = __base::has_signaling_NaN;
            static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
            static const bool has_denorm_loss = __base::has_denorm_loss;
            static constexpr type infinity() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::infinity();
            }


            static constexpr type quiet_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::quiet_NaN();
            }


            static constexpr type signaling_NaN() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::signaling_NaN();
            }


            static constexpr type denorm_min() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __base::denorm_min();
            }


            static const bool is_iec559 = __base::is_iec559;
            static const bool is_bounded = __base::is_bounded;
            static const bool is_modulo = __base::is_modulo;
            static const bool traps = __base::traps;
            static const bool tinyness_before = __base::tinyness_before;
            static const std::__1::float_round_style round_style = __base::round_style;
        };
        const bool is_specialized;
        const int digits;
        const int digits10;
        const int max_digits10;
        const bool is_signed;
        const bool is_integer;
        const bool is_exact;
        const int radix;
        const int min_exponent;
        const int min_exponent10;
        const int max_exponent;
        const int max_exponent10;
        const bool has_infinity;
        const bool has_quiet_NaN;
        const bool has_signaling_NaN;
        const std::__1::float_denorm_style has_denorm;
        const bool has_denorm_loss;
        const bool is_iec559;
        const bool is_bounded;
        const bool is_modulo;
        const bool traps;
        const bool tinyness_before;
        const std::__1::float_round_style round_style;
        const int digits;
        const int digits;
        const int digits;
        const int digits;
    }
}
namespace std {
    inline namespace __1 {
        template <class _Arg = std::__1::error_code, class _Result = unsigned long> struct unary_function {
            typedef std::__1::error_code argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = bool, class _Result = unsigned long> struct unary_function {
            typedef bool argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = char, class _Result = unsigned long> struct unary_function {
            typedef char argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = signed char, class _Result = unsigned long> struct unary_function {
            typedef signed char argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = unsigned char, class _Result = unsigned long> struct unary_function {
            typedef unsigned char argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = char16_t, class _Result = unsigned long> struct unary_function {
            typedef char16_t argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = char32_t, class _Result = unsigned long> struct unary_function {
            typedef char32_t argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = wchar_t, class _Result = unsigned long> struct unary_function {
            typedef wchar_t argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = short, class _Result = unsigned long> struct unary_function {
            typedef short argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = unsigned short, class _Result = unsigned long> struct unary_function {
            typedef unsigned short argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = int, class _Result = unsigned long> struct unary_function {
            typedef int argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = unsigned int, class _Result = unsigned long> struct unary_function {
            typedef unsigned int argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = long, class _Result = unsigned long> struct unary_function {
            typedef long argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = unsigned long, class _Result = unsigned long> struct unary_function {
            typedef unsigned long argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = long long, class _Result = unsigned long> struct unary_function {
            typedef long long argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = unsigned long long, class _Result = unsigned long> struct unary_function {
            typedef unsigned long long argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = float, class _Result = unsigned long> struct unary_function {
            typedef float argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = double, class _Result = unsigned long> struct unary_function {
            typedef double argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg = long double, class _Result = unsigned long> struct unary_function {
            typedef long double argument_type;
            typedef unsigned long result_type;
        }
template <class _Arg, class _Result> struct __attribute__((type_visibility("default"))) unary_function {
            typedef _Arg argument_type;
            typedef _Result result_type;
        };
        template <class _Arg1, class _Arg2, class _Result> struct __attribute__((type_visibility("default"))) binary_function {
            typedef _Arg1 first_argument_type;
            typedef _Arg2 second_argument_type;
            typedef _Result result_type;
        };
        template <class _Tp = std::__1::error_code> struct __attribute__((type_visibility("default"))) hash : public unary_function<std::__1::error_code, size_t> {
            size_t operator()(const std::__1::error_code &__ec) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__ec.value());
            }


        }
template <class _Tp = bool> struct __attribute__((type_visibility("default"))) hash : public unary_function<bool, size_t> {
            size_t operator()(bool __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = char> struct __attribute__((type_visibility("default"))) hash : public unary_function<char, size_t> {
            size_t operator()(char __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = signed char> struct __attribute__((type_visibility("default"))) hash : public unary_function<signed char, size_t> {
            size_t operator()(signed char __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = unsigned char> struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned char, size_t> {
            size_t operator()(unsigned char __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = char16_t> struct __attribute__((type_visibility("default"))) hash : public unary_function<char16_t, size_t> {
            size_t operator()(char16_t __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = char32_t> struct __attribute__((type_visibility("default"))) hash : public unary_function<char32_t, size_t> {
            size_t operator()(char32_t __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = wchar_t> struct __attribute__((type_visibility("default"))) hash : public unary_function<wchar_t, size_t> {
            size_t operator()(wchar_t __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = short> struct __attribute__((type_visibility("default"))) hash : public unary_function<short, size_t> {
            size_t operator()(short __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = unsigned short> struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned short, size_t> {
            size_t operator()(unsigned short __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = int> struct __attribute__((type_visibility("default"))) hash : public unary_function<int, size_t> {
            size_t operator()(int __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = unsigned int> struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned int, size_t> {
            size_t operator()(unsigned int __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = long> struct __attribute__((type_visibility("default"))) hash : public unary_function<long, size_t> {
            size_t operator()(long __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = unsigned long> struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned long, size_t> {
            size_t operator()(unsigned long __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = long long> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<long long> {
        }
template <class _Tp = unsigned long long> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<unsigned long long> {
        }
template <class _Tp = float> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<float> {
            size_t operator()(float __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__v == 0)
                    return 0;
                return this->__scalar_hash<float>::operator()(__v);
            }


        }
template <class _Tp = double> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<double> {
            size_t operator()(double __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__v == 0)
                    return 0;
                return this->__scalar_hash<double>::operator()(__v);
            }


        }
template <class _Tp = long double> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<long double> {
            size_t operator()(long double __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__v == 0)
                    return 0;
                union {
                    long double __t;
                    struct {
                        size_t __a;
                        size_t __b;
                    } __s;
                } __u;
                __u.__s.__a = 0;
                __u.__s.__b = 0;
                __u.__t = __v;
                return __u.__s.__a ^ __u.__s.__b;
            }


        }
template <class _Tp> struct __attribute__((type_visibility("default"))) hash;
        template <class _Tp> struct __has_result_type {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_result_type::__two __test(...);
            template <class _Up> static char __test(typename _Up::result_type * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) less : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x < __y;
            }


        };
        template <class _Tp = const char> inline const char *addressof(const char &__x) noexcept __attribute__((always_inline))         {
            return (const char *)&reinterpret_cast<const volatile char &>(__x);
        }

template <class _Tp> inline _Tp *addressof(_Tp &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return (_Tp *)&reinterpret_cast<const volatile char &>(__x);
        }

;
        template <class _Tp> struct __derives_from_unary_function {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            static std::__1::__derives_from_unary_function::__two __test(...);
            template <class _Ap, class _Rp> static unary_function<_Ap, _Rp> __test(const volatile unary_function<_Ap, _Rp> *);
        public:
            static const bool value = !is_same<decltype(__test((_Tp *)0)), __two>::value;
            typedef decltype(__test((_Tp *)0)) type;
        };
        template <class _Tp> struct __derives_from_binary_function {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            static std::__1::__derives_from_binary_function::__two __test(...);
            template <class _A1, class _A2, class _Rp> static binary_function<_A1, _A2, _Rp> __test(const volatile binary_function<_A1, _A2, _Rp> *);
        public:
            static const bool value = !is_same<decltype(__test((_Tp *)0)), __two>::value;
            typedef decltype(__test((_Tp *)0)) type;
        };
        template <class _Tp, bool = __derives_from_unary_function<_Tp>::value> struct __maybe_derive_from_unary_function : public __derives_from_unary_function<_Tp>::type {
        };
        struct __maybe_derive_from_unary_function {
        };
        template <class _Tp, bool = __derives_from_binary_function<_Tp>::value> struct __maybe_derive_from_binary_function : public __derives_from_binary_function<_Tp>::type {
        };
        struct __maybe_derive_from_binary_function {
        };
        template <class _Tp, bool = __has_result_type<_Tp>::value> struct __weak_result_type_imp : public __maybe_derive_from_unary_function<_Tp>, public __maybe_derive_from_binary_function<_Tp> {
            typedef typename _Tp::result_type result_type;
        };
        struct __weak_result_type_imp : public __maybe_derive_from_unary_function<_Tp>, public __maybe_derive_from_binary_function<_Tp> {
        };
        template <class _Tp> struct __weak_result_type : public __weak_result_type_imp<_Tp> {
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        struct __weak_result_type : public unary_function<_A1, _Rp> {
        };
        struct __weak_result_type : public unary_function<_A1, _Rp> {
        };
        struct __weak_result_type : public unary_function<_A1, _Rp> {
        };
        struct __weak_result_type : public unary_function<_Cp *, _Rp> {
        };
        struct __weak_result_type : public unary_function<const _Cp *, _Rp> {
        };
        struct __weak_result_type : public unary_function<volatile _Cp *, _Rp> {
        };
        struct __weak_result_type : public unary_function<const volatile _Cp *, _Rp> {
        };
        struct __weak_result_type : public binary_function<_A1, _A2, _Rp> {
        };
        struct __weak_result_type : public binary_function<_A1, _A2, _Rp> {
        };
        struct __weak_result_type : public binary_function<_A1, _A2, _Rp> {
        };
        struct __weak_result_type : public binary_function<_Cp *, _A1, _Rp> {
        };
        struct __weak_result_type : public binary_function<const _Cp *, _A1, _Rp> {
        };
        struct __weak_result_type : public binary_function<volatile _Cp *, _A1, _Rp> {
        };
        struct __weak_result_type : public binary_function<const volatile _Cp *, _A1, _Rp> {
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        struct __weak_result_type {
            typedef _Rp result_type;
        };
        template <class _Fp, class _A0, class ..._Args, class  = typename enable_if<is_member_function_pointer<typename remove_reference<_Fp>::type>::value && is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type, typename remove_reference<_A0>::type>::value>::type> inline auto __invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args) -> decltype((std::__1::forward<_A0>(__a0) .* __f)(std::__1::forward<_Args>(__args)...)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return (std::__1::forward<_A0>(__a0) .* __f)(std::__1::forward<_Args>(__args)...);
        }

;
        template <class _Fp, class _A0, class ..._Args, class  = typename enable_if<is_member_function_pointer<typename remove_reference<_Fp>::type>::value && !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type, typename remove_reference<_A0>::type>::value>::type> inline auto __invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args) -> decltype(((*std::__1::forward<_A0>(__a0)) .* __f)(std::__1::forward<_Args>(__args)...)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ((*std::__1::forward<_A0>(__a0)) .* __f)(std::__1::forward<_Args>(__args)...);
        }

;
        template <class _Fp, class _A0, class  = typename enable_if<is_member_object_pointer<typename remove_reference<_Fp>::type>::value && is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType, typename remove_reference<_A0>::type>::value>::type> inline auto __invoke(_Fp &&__f, _A0 &&__a0) -> decltype(std::__1::forward<_A0>(__a0) .* __f) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::forward<_A0>(__a0) .* __f;
        }

;
        template <class _Fp, class _A0, class  = typename enable_if<is_member_object_pointer<typename remove_reference<_Fp>::type>::value && !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType, typename remove_reference<_A0>::type>::value>::type> inline auto __invoke(_Fp &&__f, _A0 &&__a0) -> decltype((*std::__1::forward<_A0>(__a0)) .* __f) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return (*std::__1::forward<_A0>(__a0)) .* __f;
        }

;
        template <class _Fp, class ..._Args> inline auto __invoke(_Fp &&__f, _Args &&...__args) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...);
        }

;
        template <class _Tp, class ..._Args> struct __invoke_return {
            typedef decltype(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_Args>()...)) type;
        };
        template <class _Ret = void> struct __invoke_void_return_wrapper {
            template <class ..._Args> static void __call(_Args &&...__args)             {
                __invoke(std::__1::forward<_Args>(__args)...);
            }

;
        }
template <class _Ret> struct __invoke_void_return_wrapper {
            template <class ..._Args> static _Ret __call(_Args &&...__args)             {
                return __invoke(std::__1::forward<_Args>(__args)...);
            }

;
        };
        struct __invoke_void_return_wrapper {
            template <class ..._Args> static void __call(_Args &&...__args)             {
                __invoke(std::__1::forward<_Args>(__args)...);
            }

;
        };
        template <class _Tp> class __attribute__((type_visibility("default"))) reference_wrapper : public __weak_result_type<_Tp> {
        public:
            typedef _Tp type;
        private:
            type *__f_;
        public:
            reference_wrapper<_Tp>(type &__f) noexcept : __f_(std::__1::addressof(__f)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        private:
            reference_wrapper<_Tp>(type &&);
        public:
            operator type &() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this->__f_;
            }


            type &get() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this->__f_;
            }


            template <class ..._ArgTypes> typename __invoke_of<type &, _ArgTypes...>::type operator()(_ArgTypes &&...__args) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __invoke(this->get(), std::__1::forward<_ArgTypes>(__args)...);
            }

;
        };
        template <class _Tp> struct __is_reference_wrapper_impl : public false_type {
        };
        struct __is_reference_wrapper_impl : public true_type {
        };
        template <class _Tp> struct __is_reference_wrapper : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp> inline reference_wrapper<_Tp> ref(_Tp &__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return reference_wrapper<_Tp>(__t);
        }

;
        template <class _Tp> inline reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ref(__t.get());
        }

;
        template <class _Tp> inline reference_wrapper<const _Tp> cref(const _Tp &__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return reference_wrapper<const _Tp>(__t);
        }

;
        template <class _Tp> inline reference_wrapper<const _Tp> cref(reference_wrapper<_Tp> __t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return cref(__t.get());
        }

;
        template <class _Tp> void ref(const _Tp &&) = delete;
        template <class _Tp> void cref(const _Tp &&) = delete;
        struct __attribute__((type_visibility("default"))) allocator_arg_t {
        };
        const std::__1::allocator_arg_t allocator_arg = std::__1::allocator_arg_t();
        template <class _Tp> struct __has_allocator_type {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_allocator_type::__two __test(...);
            template <class _Up> static char __test(typename _Up::allocator_type * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value> struct __uses_allocator : public integral_constant<bool, is_convertible<_Alloc, typename _Tp::allocator_type>::value> {
        };
        struct __uses_allocator : public false_type {
        };
        template <class _Tp, class _Alloc> struct __attribute__((type_visibility("default"))) uses_allocator : public __uses_allocator<_Tp, _Alloc> {
        };
        template <class _Tp, class _Alloc, class ..._Args> struct __uses_alloc_ctor_imp {
            static const bool __ua = uses_allocator<_Tp, _Alloc>::value;
            static const bool __ic = is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
            static const int value = __ua ? 2 - __ic : 0;
        };
        template <class _Tp, class _Alloc, class ..._Args> struct __uses_alloc_ctor : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value> {
        };
        template <class _Tp, class _Allocator, class ..._Args> inline void __user_alloc_construct_impl(integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            new (__storage) _Tp((std::__1::forward<_Args>(__args)...));
        }

;
        template <class _Tp, class _Allocator, class ..._Args> inline void __user_alloc_construct_impl(integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            new (__storage) _Tp((allocator_arg, __a, std::__1::forward<_Args>(__args)...));
        }

;
        template <class _Tp, class _Allocator, class ..._Args> inline void __user_alloc_construct_impl(integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            new (__storage) _Tp((std::__1::forward<_Args>(__args)..., __a));
        }

;
        template <class _Tp, class _Allocator, class ..._Args> inline void __user_alloc_construct(_Tp *__storage, const _Allocator &__a, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __user_alloc_construct_impl(__uses_alloc_ctor<_Tp, _Allocator>(), __storage, __a, std::__1::forward<_Args>(__args)...);
        }

;
    }
}
namespace std {
    inline namespace __1 {
        struct __attribute__((type_visibility("default"))) input_iterator_tag {
        };
        struct __attribute__((type_visibility("default"))) output_iterator_tag {
        };
        struct __attribute__((type_visibility("default"))) forward_iterator_tag : public std::__1::input_iterator_tag {
        };
        struct __attribute__((type_visibility("default"))) bidirectional_iterator_tag : public std::__1::forward_iterator_tag {
        };
        struct __attribute__((type_visibility("default"))) random_access_iterator_tag : public std::__1::bidirectional_iterator_tag {
        };
        template <class _Tp> struct __has_iterator_category {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_iterator_category::__two __test(...);
            template <class _Up> static char __test(typename _Up::iterator_category * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Iter, bool> struct __iterator_traits_impl {
        };
        struct __iterator_traits_impl {
            typedef typename _Iter::difference_type difference_type;
            typedef typename _Iter::value_type value_type;
            typedef typename _Iter::pointer pointer;
            typedef typename _Iter::reference reference;
            typedef typename _Iter::iterator_category iterator_category;
        };
        template <class _Iter, bool> struct __iterator_traits {
        };
        struct __iterator_traits : __iterator_traits_impl<_Iter, is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value || is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value> {
        };
        template <class _Iter> struct __attribute__((type_visibility("default"))) iterator_traits : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {
        };
        struct __attribute__((type_visibility("default"))) iterator_traits {
            typedef ptrdiff_t difference_type;
            typedef typename remove_const<_Tp>::type value_type;
            typedef _Tp *pointer;
            typedef _Tp &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        };
        template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value> struct __has_iterator_category_convertible_to : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value> {
        };
        struct __has_iterator_category_convertible_to : public false_type {
        };
        template <class _Tp> struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, std::__1::input_iterator_tag> {
        };
        template <class _Tp> struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, std::__1::forward_iterator_tag> {
        };
        template <class _Tp> struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, std::__1::bidirectional_iterator_tag> {
        };
        template <class _Tp> struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, std::__1::random_access_iterator_tag> {
        };
        template <class _Category = std::__1::output_iterator_tag, class _Tp = void, class _Distance = void, class _Pointer = void, class _Reference = void> struct iterator {
            typedef void value_type;
            typedef void difference_type;
            typedef void pointer;
            typedef void reference;
            typedef std::__1::output_iterator_tag iterator_category;
        }
template <class _Category = std::__1::output_iterator_tag, class _Tp = void, class _Distance = void, class _Pointer = void, class _Reference = std::__1::back_insert_iterator<std::__1::basic_string<char> > &> struct iterator {
            typedef void value_type;
            typedef void difference_type;
            typedef void pointer;
            typedef std::__1::back_insert_iterator<std::__1::basic_string<char> > &reference;
            typedef std::__1::output_iterator_tag iterator_category;
        }
template <class _Category, class _Tp, class _Distance = ptrdiff_t, class _Pointer = _Tp *, class _Reference = _Tp &> struct __attribute__((type_visibility("default"))) iterator {
            typedef _Tp value_type;
            typedef _Distance difference_type;
            typedef _Pointer pointer;
            typedef _Reference reference;
            typedef _Category iterator_category;
        };
        template <class _InputIter> inline void __advance(_InputIter &__i, typename iterator_traits<_InputIter>::difference_type __n, std::__1::input_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __n > 0; --__n) 
                ++__i;
        }

;
        template <class _BiDirIter> inline void __advance(_BiDirIter &__i, typename iterator_traits<_BiDirIter>::difference_type __n, std::__1::bidirectional_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__n >= 0)
                for (; __n > 0; --__n) 
                    ++__i;
            else
                for (; __n < 0; ++__n) 
                    --__i;
        }

;
        template <class _RandIter> inline void __advance(_RandIter &__i, typename iterator_traits<_RandIter>::difference_type __n, std::__1::random_access_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __i += __n;
        }

;
        template <class _InputIter> inline void advance(_InputIter &__i, typename iterator_traits<_InputIter>::difference_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
        }

;
        template <class _InputIter> inline typename iterator_traits<_InputIter>::difference_type __distance(_InputIter __first, _InputIter __last, std::__1::input_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typename iterator_traits<_InputIter>::difference_type __r(0);
            for (; __first != __last; ++__first) 
                ++__r;
            return __r;
        }

;
        template <class _RandIter> inline typename iterator_traits<_RandIter>::difference_type __distance(_RandIter __first, _RandIter __last, std::__1::random_access_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __last - __first;
        }

;
        template <class _InputIter> inline typename iterator_traits<_InputIter>::difference_type distance(_InputIter __first, _InputIter __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
        }

;
        template <class _ForwardIter> inline _ForwardIter next(_ForwardIter __x, typename iterator_traits<_ForwardIter>::difference_type __n = 1, typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type * = 0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::advance(__x, __n);
            return __x;
        }

;
        template <class _BidiretionalIter> inline _BidiretionalIter prev(_BidiretionalIter __x, typename iterator_traits<_BidiretionalIter>::difference_type __n = 1, typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type * = 0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::advance(__x, -__n);
            return __x;
        }

;
        template <class _Iter = std::__1::__wrap_iter<char *>> class reverse_iterator
template <class _Iter = std::__1::__wrap_iter<const char *>> class reverse_iterator
template <class _Iter = std::__1::__wrap_iter<wchar_t *>> class reverse_iterator
template <class _Iter = std::__1::__wrap_iter<const wchar_t *>> class reverse_iterator
template <class _Iter> class __attribute__((type_visibility("default"))) reverse_iterator : public iterator<typename iterator_traits<_Iter>::iterator_category, typename iterator_traits<_Iter>::value_type, typename iterator_traits<_Iter>::difference_type, typename iterator_traits<_Iter>::pointer, typename iterator_traits<_Iter>::reference> {
        private:
            mutable _Iter __t;
        protected:
            _Iter current;
        public:
            typedef _Iter iterator_type;
            typedef typename iterator_traits<_Iter>::difference_type difference_type;
            typedef typename iterator_traits<_Iter>::reference reference;
            typedef typename iterator_traits<_Iter>::pointer pointer;
            reverse_iterator<_Iter>() : current() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit reverse_iterator<_Iter>(_Iter __x) : __t(__x), current(__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Up> reverse_iterator<_Iter>(const reverse_iterator<_Up> &__u) : __t(__u.base()), current(__u.base()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            _Iter base() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->current;
            }


            reference operator*() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                _Iter __tmp = this->current;
                return *--__tmp;
            }


            pointer operator->() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::addressof(this->operator*());
            }


            reverse_iterator<_Iter> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                --this->current;
                return *this;
            }


            reverse_iterator<_Iter> operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                reverse_iterator<_Iter> __tmp(*this);
                --this->current;
                return __tmp;
            }


            reverse_iterator<_Iter> &operator--() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ++this->current;
                return *this;
            }


            reverse_iterator<_Iter> operator--(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                reverse_iterator<_Iter> __tmp(*this);
                ++this->current;
                return __tmp;
            }


            reverse_iterator<_Iter> operator+(difference_type __n) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reverse_iterator<_Iter>(this->current - __n);
            }


            reverse_iterator<_Iter> &operator+=(difference_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->current -= __n;
                return *this;
            }


            reverse_iterator<_Iter> operator-(difference_type __n) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reverse_iterator<_Iter>(this->current + __n);
            }


            reverse_iterator<_Iter> &operator-=(difference_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->current += __n;
                return *this;
            }


            reference operator[](difference_type __n) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *(*this + __n);
            }


        };
        template <class _Iter1, class _Iter2> inline bool operator==(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() == __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator<(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() > __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator!=(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() != __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator>(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() < __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator>=(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() <= __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator<=(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() >= __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline typename reverse_iterator<_Iter1>::difference_type operator-(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __y.base() - __x.base();
        }

;
        template <class _Iter> inline reverse_iterator<_Iter> operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter> &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return reverse_iterator<_Iter>(__x.base() - __n);
        }

;
        template <class _Container = std::__1::basic_string<char>> class back_insert_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, back_insert_iterator<std::__1::basic_string<char> > &> {
        protected:
            std::__1::basic_string<char> *container;
        public:
            typedef std::__1::basic_string<char> container_type;
            explicit back_insert_iterator(std::__1::basic_string<char> &__x) __attribute__((always_inline));
            std::__1::back_insert_iterator<std::__1::basic_string<char> > &operator=(const typename basic_string<char>::value_type &__value_) __attribute__((always_inline));
            std::__1::back_insert_iterator<std::__1::basic_string<char> > &operator=(typename basic_string<char>::value_type &&__value_) __attribute__((always_inline));
            std::__1::back_insert_iterator<std::__1::basic_string<char> > &operator*() __attribute__((always_inline));
            std::__1::back_insert_iterator<std::__1::basic_string<char> > &operator++() __attribute__((always_inline));
            std::__1::back_insert_iterator<std::__1::basic_string<char> > operator++(int) __attribute__((always_inline));
        }
template <class _Container> class __attribute__((type_visibility("default"))) back_insert_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, back_insert_iterator<_Container> &> {
        protected:
            _Container *container;
        public:
            typedef _Container container_type;
            explicit back_insert_iterator<_Container>(_Container &__x) : container(std::__1::addressof(__x)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            back_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->container->push_back(__value_);
                return *this;
            }


            back_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->container->push_back(std::__1::move(__value_));
                return *this;
            }


            back_insert_iterator<_Container> &operator*() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            back_insert_iterator<_Container> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            back_insert_iterator<_Container> operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


        };
        template <class _Container = std::__1::basic_string<char>> inline back_insert_iterator<std::__1::basic_string<char> > back_inserter(std::__1::basic_string<char> &__x) __attribute__((always_inline))template <class _Container> inline back_insert_iterator<_Container> back_inserter(_Container &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return back_insert_iterator<_Container>(__x);
        }

;
        template <class _Container> class __attribute__((type_visibility("default"))) front_insert_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, front_insert_iterator<_Container> &> {
        protected:
            _Container *container;
        public:
            typedef _Container container_type;
            explicit front_insert_iterator<_Container>(_Container &__x) : container(std::__1::addressof(__x)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            front_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->container->push_front(__value_);
                return *this;
            }


            front_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->container->push_front(std::__1::move(__value_));
                return *this;
            }


            front_insert_iterator<_Container> &operator*() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            front_insert_iterator<_Container> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            front_insert_iterator<_Container> operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


        };
        template <class _Container> inline front_insert_iterator<_Container> front_inserter(_Container &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return front_insert_iterator<_Container>(__x);
        }

;
        template <class _Container> class __attribute__((type_visibility("default"))) insert_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, insert_iterator<_Container> &> {
        protected:
            _Container *container;
            typename _Container::iterator iter;
        public:
            typedef _Container container_type;
            insert_iterator<_Container>(_Container &__x, typename _Container::iterator __i) : container(std::__1::addressof(__x)), iter(__i) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            insert_iterator<_Container> &operator=(const typename _Container::value_type &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->iter = this->container->insert(this->iter, __value_);
                ++this->iter;
                return *this;
            }


            insert_iterator<_Container> &operator=(typename _Container::value_type &&__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->iter = this->container->insert(this->iter, std::__1::move(__value_));
                ++this->iter;
                return *this;
            }


            insert_iterator<_Container> &operator*() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            insert_iterator<_Container> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            insert_iterator<_Container> &operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


        };
        template <class _Container> inline insert_iterator<_Container> inserter(_Container &__x, typename _Container::iterator __i) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return insert_iterator<_Container>(__x, __i);
        }

;
        template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t> class __attribute__((type_visibility("default"))) istream_iterator : public iterator<std::__1::input_iterator_tag, _Tp, _Distance, const _Tp *, const _Tp &> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_istream<_CharT, _Traits> istream_type;
        private:
            istream_type *__in_stream_;
            _Tp __value_;
        public:
            constexpr istream_iterator<_Tp, _CharT, _Traits, _Distance>() : __in_stream_(0), __value_() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            istream_iterator<_Tp, _CharT, _Traits, _Distance>(istream_type &__s) : __in_stream_(&__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (!(*this->__in_stream_ >> this->__value_))
                    this->__in_stream_ = 0;
            }


            const _Tp &operator*() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__value_;
            }


            const _Tp *operator->() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return &(this->operator*());
            }


            istream_iterator<_Tp, _CharT, _Traits, _Distance> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (!(*this->__in_stream_ >> this->__value_))
                    this->__in_stream_ = 0;
                return *this;
            }


            istream_iterator<_Tp, _CharT, _Traits, _Distance> operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                istream_iterator<_Tp, _CharT, _Traits, _Distance> __t(*this);
                ++(*this);
                return __t;
            }


            friend bool operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__x, const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x.__in_stream_ == __y.__in_stream_;
            }

;
            friend bool operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__x, const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__x == __y);
            }

;
        };
        template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) ostream_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_ostream<_CharT, _Traits> ostream_type;
        private:
            ostream_type *__out_stream_;
            const char_type *__delim_;
        public:
            ostream_iterator<_Tp, _CharT, _Traits>(ostream_type &__s) : __out_stream_(&__s), __delim_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ostream_iterator<_Tp, _CharT, _Traits>(ostream_type &__s, const _CharT *__delimiter) : __out_stream_(&__s), __delim_(__delimiter) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ostream_iterator<_Tp, _CharT, _Traits> &operator=(const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                *this->__out_stream_ << __value_;
                if (this->__delim_)
                    *this->__out_stream_ << this->__delim_;
                return *this;
            }


            ostream_iterator<_Tp, _CharT, _Traits> &operator*() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            ostream_iterator<_Tp, _CharT, _Traits> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            ostream_iterator<_Tp, _CharT, _Traits> &operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


        };
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class istreambuf_iterator
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class istreambuf_iterator
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) istreambuf_iterator : public iterator<std::__1::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename _Traits::int_type int_type;
            typedef basic_streambuf<_CharT, _Traits> streambuf_type;
            typedef basic_istream<_CharT, _Traits> istream_type;
        private:
            mutable streambuf_type *__sbuf_;
            class __proxy {
                char_type __keep_;
                streambuf_type *__sbuf_;
                __proxy(char_type __c, streambuf_type *__s) : __keep_(__c), __sbuf_(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }


                friend  class istreambuf_iterator<_CharT, _Traits>;
            public:
                char_type operator*() const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return this->__keep_;
                }


            };
            bool __test_for_eof() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (this->__sbuf_ && traits_type::eq_int_type(this->__sbuf_->sgetc(), traits_type::eof()))
                    this->__sbuf_ = 0;
                return this->__sbuf_ == 0;
            }


        public:
            constexpr istreambuf_iterator<_CharT, _Traits>() noexcept : __sbuf_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            istreambuf_iterator<_CharT, _Traits>(istream_type &__s) noexcept : __sbuf_(__s.rdbuf()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            istreambuf_iterator<_CharT, _Traits>(streambuf_type *__s) noexcept : __sbuf_(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            istreambuf_iterator<_CharT, _Traits>(const std::__1::istreambuf_iterator::__proxy &__p) noexcept : __sbuf_(__p.__sbuf_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            char_type operator*() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<char_type>(this->__sbuf_->sgetc());
            }


            char_type *operator->() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return nullptr;
            }


            istreambuf_iterator<_CharT, _Traits> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__sbuf_->sbumpc();
                return *this;
            }


            std::__1::istreambuf_iterator::__proxy operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::istreambuf_iterator::__proxy(this->__sbuf_->sbumpc(), this->__sbuf_);
            }


            bool equal(const istreambuf_iterator<_CharT, _Traits> &__b) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__test_for_eof() == __b.__test_for_eof();
            }


        };
        template <class _CharT, class _Traits> inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __a.equal(__b);
        }

;
        template <class _CharT, class _Traits> inline bool operator!=(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !__a.equal(__b);
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class ostreambuf_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::__1::char_traits<char> > streambuf_type;
            typedef basic_ostream<char, std::__1::char_traits<char> > ostream_type;
        private:
            streambuf_type *__sbuf_;
        public:
            ostreambuf_iterator(ostream_type &__s) noexcept : iterator<std::__1::output_iterator_tag, void, void, void, void>(), __sbuf_(__s.rdbuf()) __attribute__((always_inline))             {
            }


            ostreambuf_iterator(streambuf_type *__s) noexcept __attribute__((always_inline));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator=(char __c) __attribute__((always_inline));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator*() __attribute__((always_inline));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator++() __attribute__((always_inline));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator++(int) __attribute__((always_inline));
            bool failed() const noexcept __attribute__((always_inline))             {
                return this->__sbuf_ == 0;
            }


            friend template <class _Ch = char, class _Tr = std::__1::char_traits<char>> ostreambuf_iterator<char, std::__1::char_traits<char> > __pad_and_output(ostreambuf_iterator<char, std::__1::char_traits<char> > __s, const char *__ob, const char *__op, const char *__oe, std::__1::ios_base &__iob, char __fl)             {
                if (__s.__sbuf_ == nullptr)
                    return __s;
                streamsize __sz = __oe - __ob;
                streamsize __ns = __iob.width();
                if (__ns > __sz)
                    __ns -= __sz;
                else
                    __ns = 0;
                streamsize __np = __op - __ob;
                if (__np > 0) {
                    if (__s.__sbuf_->sputn(__ob, __np) != __np) {
                        __s.__sbuf_ = nullptr;
                        return __s;
                    }
                }
                if (__ns > 0) {
                    basic_string<char, std::__1::char_traits<char> > __sp(__ns, __fl);
                    if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns) {
                        __s.__sbuf_ = nullptr;
                        return __s;
                    }
                }
                __np = __oe - __op;
                if (__np > 0) {
                    if (__s.__sbuf_->sputn(__op, __np) != __np) {
                        __s.__sbuf_ = nullptr;
                        return __s;
                    }
                }
                __iob.width(0);
                return __s;
            }

template <class _Ch, class _Tr> ostreambuf_iterator<_Ch, _Tr> __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s, const _Ch *__ob, const _Ch *__op, const _Ch *__oe, std::__1::ios_base &__iob, _Ch __fl) __attribute__((visibility("hidden")));
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class ostreambuf_iterator
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) ostreambuf_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_streambuf<_CharT, _Traits> streambuf_type;
            typedef basic_ostream<_CharT, _Traits> ostream_type;
        private:
            streambuf_type *__sbuf_;
        public:
            ostreambuf_iterator<_CharT, _Traits>(ostream_type &__s) noexcept : __sbuf_(__s.rdbuf()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ostreambuf_iterator<_CharT, _Traits>(streambuf_type *__s) noexcept : __sbuf_(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ostreambuf_iterator<_CharT, _Traits> &operator=(_CharT __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (this->__sbuf_ && traits_type::eq_int_type(this->__sbuf_->sputc(__c), traits_type::eof()))
                    this->__sbuf_ = 0;
                return *this;
            }


            ostreambuf_iterator<_CharT, _Traits> &operator*() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            ostreambuf_iterator<_CharT, _Traits> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            ostreambuf_iterator<_CharT, _Traits> &operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            bool failed() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__sbuf_ == 0;
            }


            friend template <class _Ch, class _Tr> ostreambuf_iterator<_Ch, _Tr> __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s, const _Ch *__ob, const _Ch *__op, const _Ch *__oe, std::__1::ios_base &__iob, _Ch __fl) __attribute__((visibility("hidden")));
        };
        template <class _Iter> class __attribute__((type_visibility("default"))) move_iterator {
        private:
            _Iter __i;
        public:
            typedef _Iter iterator_type;
            typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
            typedef typename iterator_traits<iterator_type>::value_type value_type;
            typedef typename iterator_traits<iterator_type>::difference_type difference_type;
            typedef typename iterator_traits<iterator_type>::pointer pointer;
            typedef value_type &&reference;
            move_iterator<_Iter>() : __i() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit move_iterator<_Iter>(_Iter __x) : __i(__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Up> move_iterator<_Iter>(const move_iterator<_Up> &__u) : __i(__u.base()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            _Iter base() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__i;
            }


            reference operator*() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<reference>(*this->__i);
            }


            pointer operator->() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typename iterator_traits<iterator_type>::reference __ref = *this->__i;
                return &__ref;
            }


            move_iterator<_Iter> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ++this->__i;
                return *this;
            }


            move_iterator<_Iter> operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                move_iterator<_Iter> __tmp(*this);
                ++this->__i;
                return __tmp;
            }


            move_iterator<_Iter> &operator--() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                --this->__i;
                return *this;
            }


            move_iterator<_Iter> operator--(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                move_iterator<_Iter> __tmp(*this);
                --this->__i;
                return __tmp;
            }


            move_iterator<_Iter> operator+(difference_type __n) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return move_iterator<_Iter>(this->__i + __n);
            }


            move_iterator<_Iter> &operator+=(difference_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__i += __n;
                return *this;
            }


            move_iterator<_Iter> operator-(difference_type __n) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return move_iterator<_Iter>(this->__i - __n);
            }


            move_iterator<_Iter> &operator-=(difference_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__i -= __n;
                return *this;
            }


            reference operator[](difference_type __n) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<reference>(this->__i[__n]);
            }


        };
        template <class _Iter1, class _Iter2> inline bool operator==(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() == __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator<(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() < __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator!=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() != __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator>(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() > __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator>=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() >= __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator<=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() <= __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline typename move_iterator<_Iter1>::difference_type operator-(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() - __y.base();
        }

;
        template <class _Iter> inline move_iterator<_Iter> operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter> &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return move_iterator<_Iter>(__x.base() + __n);
        }

;
        template <class _Iter> inline move_iterator<_Iter> make_move_iterator(_Iter __i) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return move_iterator<_Iter>(__i);
        }

;
        template <class _Iter = char *> class __wrap_iter
template <class _Iter = const char *> class __wrap_iter
template <class _Iter = wchar_t *> class __wrap_iter
template <class _Iter = const wchar_t *> class __wrap_iter
template <class _Iter> class __wrap_iter;
        template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Iter> __wrap_iter<_Iter> operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Iter = char *> class __wrap_iter
template <class _Iter = const char *> class __wrap_iter
template <class _Iter = wchar_t *> class __wrap_iter
template <class _Iter = const wchar_t *> class __wrap_iter
template <class _Iter> class __wrap_iter {
        public:
            typedef _Iter iterator_type;
            typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
            typedef typename iterator_traits<iterator_type>::value_type value_type;
            typedef typename iterator_traits<iterator_type>::difference_type difference_type;
            typedef typename iterator_traits<iterator_type>::pointer pointer;
            typedef typename iterator_traits<iterator_type>::reference reference;
        private:
            iterator_type __i;
        public:
            __wrap_iter<_Iter>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Up> __wrap_iter<_Iter>(const __wrap_iter<_Up> &__u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type * = 0) noexcept : __i(__u.base()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            reference operator*() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this->__i;
            }


            pointer operator->() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (pointer)&reinterpret_cast<const volatile char &>(*this->__i);
            }


            __wrap_iter<_Iter> &operator++() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ++this->__i;
                return *this;
            }


            __wrap_iter<_Iter> operator++(int) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __wrap_iter<_Iter> __tmp(*this);
                ++(*this);
                return __tmp;
            }


            __wrap_iter<_Iter> &operator--() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                --this->__i;
                return *this;
            }


            __wrap_iter<_Iter> operator--(int) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __wrap_iter<_Iter> __tmp(*this);
                --(*this);
                return __tmp;
            }


            __wrap_iter<_Iter> operator+(difference_type __n) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __wrap_iter<_Iter> __w(*this);
                __w += __n;
                return __w;
            }


            __wrap_iter<_Iter> &operator+=(difference_type __n) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__i += __n;
                return *this;
            }


            __wrap_iter<_Iter> operator-(difference_type __n) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this + (- __n);
            }


            __wrap_iter<_Iter> &operator-=(difference_type __n) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                *this += - __n;
                return *this;
            }


            reference operator[](difference_type __n) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__i[__n];
            }


            iterator_type base() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__i;
            }


        private:
            __wrap_iter<_Iter>(iterator_type __x) noexcept : __i(__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            friend template <class _Up> class __wrap_iter;
            friend template <class _CharT, class _Traits, class _Alloc> class __attribute__((type_visibility("default"))) basic_string;
            friend template <class _Tp, class _Alloc> class __attribute__((type_visibility("default"))) vector;
            friend template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;
            friend template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;
            friend template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;
            friend template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;
            friend template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;
            friend template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;
            friend template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;
            friend template <class _Iter1> __wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) noexcept;
            friend template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2);
            friend template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2);
            friend template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>);
        };
        template <class _Iter1, class _Iter2> inline bool operator==(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() == __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator<(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() < __y.base();
        }

;
        template <class _Iter1, class _Iter2> inline bool operator!=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }

;
        template <class _Iter1, class _Iter2> inline bool operator>(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __y < __x;
        }

;
        template <class _Iter1, class _Iter2> inline bool operator>=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < __y);
        }

;
        template <class _Iter1, class _Iter2> inline bool operator<=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__y < __x);
        }

;
        template <class _Iter1> inline bool operator!=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }

;
        template <class _Iter1> inline bool operator>(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __y < __x;
        }

;
        template <class _Iter1> inline bool operator>=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < __y);
        }

;
        template <class _Iter1> inline bool operator<=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__y < __x);
        }

;
        template <class _Iter1, class _Iter2> inline typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.base() - __y.base();
        }

;
        template <class _Iter> inline __wrap_iter<_Iter> operator+(typename __wrap_iter<_Iter>::difference_type __n, __wrap_iter<_Iter> __x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __x += __n;
            return __x;
        }

;
        template <class _Tp, size_t _Np> inline _Tp *begin(_Tp (&__array)[_Np]) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __array;
        }

;
        template <class _Tp, size_t _Np> inline _Tp *end(_Tp (&__array)[_Np]) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __array + _Np;
        }

;
        template <class _Cp> inline auto begin(_Cp &__c) -> decltype(__c.begin()) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __c.begin();
        }

;
        template <class _Cp> inline auto begin(const _Cp &__c) -> decltype(__c.begin()) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __c.begin();
        }

;
        template <class _Cp> inline auto end(_Cp &__c) -> decltype(__c.end()) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __c.end();
        }

;
        template <class _Cp> inline auto end(const _Cp &__c) -> decltype(__c.end()) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __c.end();
        }

;
    }
}
namespace std {
    inline namespace __1 {
        class __attribute__((type_visibility("default"))) tuple_size : public integral_constant<size_t, sizeof...(_Tp)> {
        };
        class __attribute__((type_visibility("default"))) tuple_element {
        public:
            typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
        };
        template <size_t _Ip, class _Hp, bool = is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value> class __tuple_leaf;
        template <size_t _Ip, class _Hp, bool _Ep> inline void swap(__tuple_leaf<_Ip, _Hp, _Ep> &__x, __tuple_leaf<_Ip, _Hp, _Ep> &__y) noexcept(__is_nothrow_swappable<_Hp>::valueswap(__tuple_leaf<_Ip, _Hp, _Ep> &__x, __tuple_leaf<_Ip, _Hp, _Ep> &__y) noexcept(__is_nothrow_swappable<_Hp>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            swap(__x.get(), __y.get());
        }

;
        template <size_t _Ip, class _Hp, bool = is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value> class __tuple_leaf {
            _Hp value;
            __tuple_leaf<_Ip, _Hp, > &operator=(const __tuple_leaf<_Ip, _Hp, > &);
        public:
            constexpr __tuple_leaf<_Ip, _Hp, >() noexcept(is_nothrow_default_constructible<_Hp>::value__tuple_leaf<_Ip, _Hp, >() noexcept(is_nothrow_default_constructible<_Hp>::value) : value() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
            }


            template <class _Alloc> __tuple_leaf<_Ip, _Hp, >(integral_constant<int, 0>, const _Alloc &) : value() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
            }

;
            template <class _Alloc> __tuple_leaf<_Ip, _Hp, >(integral_constant<int, 1>, const _Alloc &__a) : value(std::__1::allocator_arg_t(), __a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
            }

;
            template <class _Alloc> __tuple_leaf<_Ip, _Hp, >(integral_constant<int, 2>, const _Alloc &__a) : value(__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
            }

;
            template <class _Tp, class  = typename enable_if<__lazy_and<__lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf<_Ip, _Hp, > > >, is_constructible<_Hp, _Tp> >::value>::type> explicit __tuple_leaf<_Ip, _Hp, >(_Tp &&__t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value)__tuple_leaf<_Ip, _Hp, >(_Tp &&__t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value)) : value(std::__1::forward<_Tp>(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_reference<_Hp>::value || (is_lvalue_reference<_Hp>::value && (is_lvalue_reference<_Tp>::value || is_same<typename remove_reference<_Tp>::type, reference_wrapper<typename remove_reference<_Hp>::type> >::value)) || (is_rvalue_reference<_Hp>::value && !is_lvalue_reference<_Tp>::value), "Attempted to construct a reference element in a tuple with an rvalue");
            }

;
            template <class _Tp, class _Alloc> explicit __tuple_leaf<_Ip, _Hp, >(integral_constant<int, 0>, const _Alloc &, _Tp &&__t) : value(std::__1::forward<_Tp>(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_lvalue_reference<_Hp>::value || (is_lvalue_reference<_Hp>::value && (is_lvalue_reference<_Tp>::value || is_same<typename remove_reference<_Tp>::type, reference_wrapper<typename remove_reference<_Hp>::type> >::value)), "Attempted to construct a reference element in a tuple with an rvalue");
            }

;
            template <class _Tp, class _Alloc> explicit __tuple_leaf<_Ip, _Hp, >(integral_constant<int, 1>, const _Alloc &__a, _Tp &&__t) : value(std::__1::allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_lvalue_reference<_Hp>::value || (is_lvalue_reference<_Hp>::value && (is_lvalue_reference<_Tp>::value || is_same<typename remove_reference<_Tp>::type, reference_wrapper<typename remove_reference<_Hp>::type> >::value)), "Attempted to construct a reference element in a tuple with an rvalue");
            }

;
            template <class _Tp, class _Alloc> explicit __tuple_leaf<_Ip, _Hp, >(integral_constant<int, 2>, const _Alloc &__a, _Tp &&__t) : value(std::__1::forward<_Tp>(__t), __a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_lvalue_reference<_Hp>::value || (is_lvalue_reference<_Hp>::value && (is_lvalue_reference<_Tp>::value || is_same<typename remove_reference<_Tp>::type, reference_wrapper<typename remove_reference<_Hp>::type> >::value)), "Attempted to construct a reference element in a tuple with an rvalue");
            }

;
            __tuple_leaf<_Ip, _Hp, >(const __tuple_leaf<_Ip, _Hp, > &__t) = default;
            __tuple_leaf<_Ip, _Hp, >(__tuple_leaf<_Ip, _Hp, > &&__t) = default;
            template <class _Tp> __tuple_leaf<_Ip, _Hp, > &operator=(_Tp &&__t) noexcept((is_nothrow_assignable<_Hp &, _Tp>::value)operator=(_Tp &&__t) noexcept((is_nothrow_assignable<_Hp &, _Tp>::value)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->value = std::__1::forward<_Tp>(__t);
                return *this;
            }

;
            int swap(__tuple_leaf<_Ip, _Hp, > &__t) noexcept(__is_nothrow_swappable<__tuple_leaf<_Ip, _Hp, > >::valueswap(__tuple_leaf<_Ip, _Hp, > &__t) noexcept(__is_nothrow_swappable<__tuple_leaf<_Ip, _Hp, > >::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::swap(*this, __t);
                return 0;
            }


            _Hp &get() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->value;
            }


            const _Hp &get() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->value;
            }


        };
        class __tuple_leaf : private _Hp {
            __tuple_leaf<_Ip, type-parameter-0-1, true> &operator=(const __tuple_leaf<_Ip, type-parameter-0-1, true> &);
        public:
            constexpr __tuple_leaf<_Ip, type-parameter-0-1, true>() noexcept(is_nothrow_default_constructible<_Hp>::value__tuple_leaf<_Ip, type-parameter-0-1, true>() noexcept(is_nothrow_default_constructible<_Hp>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Alloc> __tuple_leaf<_Ip, type-parameter-0-1, true>(integral_constant<int, 0>, const _Alloc &) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc> __tuple_leaf<_Ip, type-parameter-0-1, true>(integral_constant<int, 1>, const _Alloc &__a) : _Hp(std::__1::allocator_arg_t(), __a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc> __tuple_leaf<_Ip, type-parameter-0-1, true>(integral_constant<int, 2>, const _Alloc &__a) : _Hp(__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tp, class  = typename enable_if<__lazy_and<__lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf<_Ip, type-parameter-0-1, true> > >, is_constructible<_Hp, _Tp> >::value>::type> explicit __tuple_leaf<_Ip, type-parameter-0-1, true>(_Tp &&__t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value)__tuple_leaf<_Ip, type-parameter-0-1, true>(_Tp &&__t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value)) : _Hp(std::__1::forward<_Tp>(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tp, class _Alloc> explicit __tuple_leaf<_Ip, type-parameter-0-1, true>(integral_constant<int, 0>, const _Alloc &, _Tp &&__t) : _Hp(std::__1::forward<_Tp>(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tp, class _Alloc> explicit __tuple_leaf<_Ip, type-parameter-0-1, true>(integral_constant<int, 1>, const _Alloc &__a, _Tp &&__t) : _Hp(std::__1::allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tp, class _Alloc> explicit __tuple_leaf<_Ip, type-parameter-0-1, true>(integral_constant<int, 2>, const _Alloc &__a, _Tp &&__t) : _Hp(std::__1::forward<_Tp>(__t), __a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            __tuple_leaf<_Ip, type-parameter-0-1, true>(const __tuple_leaf<_Ip, type-parameter-0-1, true> &) = default;
            __tuple_leaf<_Ip, type-parameter-0-1, true>(__tuple_leaf<_Ip, type-parameter-0-1, true> &&) = default;
            template <class _Tp> __tuple_leaf<_Ip, type-parameter-0-1, true> &operator=(_Tp &&__t) noexcept((is_nothrow_assignable<_Hp &, _Tp>::value)operator=(_Tp &&__t) noexcept((is_nothrow_assignable<_Hp &, _Tp>::value)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                _Hp::operator=(std::__1::forward<_Tp>(__t));
                return *this;
            }

;
            int swap(__tuple_leaf<_Ip, type-parameter-0-1, true> &__t) noexcept(__is_nothrow_swappable<__tuple_leaf<_Ip, type-parameter-0-1, true> >::valueswap(__tuple_leaf<_Ip, type-parameter-0-1, true> &__t) noexcept(__is_nothrow_swappable<__tuple_leaf<_Ip, type-parameter-0-1, true> >::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::swap(*this, __t);
                return 0;
            }


            _Hp &get() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<_Hp &>(*this);
            }


            const _Hp &get() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<const _Hp &>(*this);
            }


        };
        template <class ..._Tp> void __swallow(_Tp &&...) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }

;
        template <bool ..._Pred> struct __all : is_same<__all<_Pred...>, __all<(_Pred , true)...> > {
        };
        template <class _Tp> struct __all_default_constructible;
        struct __all_default_constructible : __all<is_default_constructible<_Tp>::value...> {
        };
        template <class _Indx, class ..._Tp> struct __tuple_impl;
        struct __tuple_impl : public __tuple_leaf<_Indx, _Tp>... {
            constexpr __tuple_impl<__tuple_indices<...>, type-parameter-0-1...>() noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value__tuple_impl<__tuple_indices<...>, type-parameter-0-1...>() noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <size_t ..._Uf, class ..._Tf, size_t ..._Ul, class ..._Tl, class ..._Up> explicit __tuple_impl<__tuple_indices<...>, type-parameter-0-1...>(__tuple_indices<_Uf...>, __tuple_types<_Tf...>, __tuple_indices<_Ul...>, __tuple_types<_Tl...>, _Up &&...__u) noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)__tuple_impl<__tuple_indices<...>, type-parameter-0-1...>(__tuple_indices<_Uf...>, __tuple_types<_Tf...>, __tuple_indices<_Ul...>, __tuple_types<_Tl...>, _Up &&...__u) noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)) : __tuple_leaf<_Uf, _Tf>(std::__1::forward<_Up>(__u))..., __tuple_leaf<_Ul, _Tl>()... __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc, size_t ..._Uf, class ..._Tf, size_t ..._Ul, class ..._Tl, class ..._Up> explicit __tuple_impl<__tuple_indices<...>, type-parameter-0-1...>(std::__1::allocator_arg_t, const _Alloc &__a, __tuple_indices<_Uf...>, __tuple_types<_Tf...>, __tuple_indices<_Ul...>, __tuple_types<_Tl...>, _Up &&...__u) : __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a, std::__1::forward<_Up>(__u))..., __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)... __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tuple, class  = typename enable_if<__tuple_constructible<_Tuple, tuple<_Tp...> >::value>::type> __tuple_impl<__tuple_indices<...>, type-parameter-0-1...>(_Tuple &&__t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value)__tuple_impl<__tuple_indices<...>, type-parameter-0-1...>(_Tuple &&__t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value)) : __tuple_leaf<_Indx, _Tp>(std::__1::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))... __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc, class _Tuple, class  = typename enable_if<__tuple_convertible<_Tuple, tuple<_Tp...> >::value>::type> __tuple_impl<__tuple_indices<...>, type-parameter-0-1...>(std::__1::allocator_arg_t, const _Alloc &__a, _Tuple &&__t) : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(), __a, std::__1::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))... __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tuple> typename enable_if<__tuple_assignable<_Tuple, tuple<_Tp...> >::value, __tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &>::type operator=(_Tuple &&__t) noexcept((__all<is_nothrow_assignable<_Tp &, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value)operator=(_Tuple &&__t) noexcept((__all<is_nothrow_assignable<_Tp &, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...);
                return *this;
            }

;
            __tuple_impl<__tuple_indices<...>, type-parameter-0-1...>(const __tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &) = default;
            __tuple_impl<__tuple_indices<...>, type-parameter-0-1...>(__tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &&) = default;
            __tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &operator=(const __tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &__t) noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value)operator=(const __tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &__t) noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp> &>(__t).get())...);
                return *this;
            }


            __tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &operator=(__tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &&__t) noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value)operator=(__tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &&__t) noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp> &>(__t).get()))...);
                return *this;
            }


            void swap(__tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &__t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::valueswap(__tuple_impl<__tuple_indices<...>, type-parameter-0-1...> &__t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp> &>(__t))...);
            }


        };
        template <class ..._Tp = <>> class __attribute__((type_visibility("default"))) tuple {
        public:
            constexpr tuple() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Alloc> tuple(std::__1::allocator_arg_t, const _Alloc &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc> tuple(std::__1::allocator_arg_t, const _Alloc &, const std::__1::tuple<> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Up> tuple(array<_Up, 0>) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc, class _Up> tuple(std::__1::allocator_arg_t, const _Alloc &, array<_Up, 0>) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            void swap(std::__1::tuple<> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        }
template <class ..._Tp> class __attribute__((type_visibility("default"))) tuple {
            typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;
            base base_;
            friend template <size_t _Jp, class ..._Up> typename tuple_element<_Jp, tuple<_Up...> >::type &get(tuple<_Up...> &) noexcept;
            friend template <size_t _Jp, class ..._Up> const typename tuple_element<_Jp, tuple<_Up...> >::type &get(const tuple<_Up...> &) noexcept;
            friend template <size_t _Jp, class ..._Up> typename tuple_element<_Jp, tuple<_Up...> >::type &&get(tuple<_Up...> &&) noexcept;
        public:
            template <bool _Dummy = true, class  = typename enable_if<__all<__dependent_type<is_default_constructible<_Tp>, _Dummy>::value...>::value>::type> constexpr tuple<_Tp...>() noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::valuetuple<_Tp...>() noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            explicit tuple<_Tp...>(const _Tp &...__t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value)tuple<_Tp...>(const _Tp &...__t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value)) : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(), typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp)>::type(), typename __make_tuple_indices<0>::type(), typename __make_tuple_types<tuple<_Tp...>, 0>::type(), __t...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Alloc> tuple<_Tp...>(std::__1::allocator_arg_t, const _Alloc &__a, const _Tp &...__t) : base_(std::__1::allocator_arg_t(), __a, typename __make_tuple_indices<sizeof...(_Tp)>::type(), typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp)>::type(), typename __make_tuple_indices<0>::type(), typename __make_tuple_types<tuple<_Tp...>, 0>::type(), __t...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class ..._Up, typename enable_if<sizeof...(_Up) <= sizeof...(_Tp) && __tuple_convertible<tuple<_Up...>, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up) < sizeof...(_Tp) ? sizeof...(_Up) : sizeof...(_Tp)>::type>::value && __all_default_constructible<typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up) < sizeof...(_Tp) ? sizeof...(_Up) : sizeof...(_Tp)>::type>::value, bool>::type = false> tuple<_Tp...>(_Up &&...__u) noexcept((is_nothrow_constructible<base, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up)>::type, _Up...>::value)tuple<_Tp...>(_Up &&...__u) noexcept((is_nothrow_constructible<base, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up)>::type, _Up...>::value)) : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(), typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up)>::type(), typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(), typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up)>::type(), std::__1::forward<_Up>(__u)...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class ..._Up, typename enable_if<sizeof...(_Up) <= sizeof...(_Tp) && __tuple_constructible<tuple<_Up...>, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up) < sizeof...(_Tp) ? sizeof...(_Up) : sizeof...(_Tp)>::type>::value && !__tuple_convertible<tuple<_Up...>, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up) < sizeof...(_Tp) ? sizeof...(_Up) : sizeof...(_Tp)>::type>::value && __all_default_constructible<typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up) < sizeof...(_Tp) ? sizeof...(_Up) : sizeof...(_Tp)>::type>::value, bool>::type = false> explicit tuple<_Tp...>(_Up &&...__u) noexcept((is_nothrow_constructible<base, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up)>::type, _Up...>::value)tuple<_Tp...>(_Up &&...__u) noexcept((is_nothrow_constructible<base, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up)>::type, _Up...>::value)) : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(), typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up)>::type(), typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(), typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up)>::type(), std::__1::forward<_Up>(__u)...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc, class ..._Up, class  = typename enable_if<sizeof...(_Up) <= sizeof...(_Tp) && __tuple_convertible<tuple<_Up...>, typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up) < sizeof...(_Tp) ? sizeof...(_Up) : sizeof...(_Tp)>::type>::value && __all_default_constructible<typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up) < sizeof...(_Tp) ? sizeof...(_Up) : sizeof...(_Tp)>::type>::value>::type> tuple<_Tp...>(std::__1::allocator_arg_t, const _Alloc &__a, _Up &&...__u) : base_(std::__1::allocator_arg_t(), __a, typename __make_tuple_indices<sizeof...(_Up)>::type(), typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Up)>::type(), typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(), typename __make_tuple_types<tuple<_Tp...>, sizeof...(_Tp), sizeof...(_Up)>::type(), std::__1::forward<_Up>(__u)...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tuple, typename enable_if<__tuple_convertible<_Tuple, tuple<_Tp...> >::value, bool>::type = false> tuple<_Tp...>(_Tuple &&__t) noexcept((is_nothrow_constructible<base, _Tuple>::value)tuple<_Tp...>(_Tuple &&__t) noexcept((is_nothrow_constructible<base, _Tuple>::value)) : base_(std::__1::forward<_Tuple>(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tuple, typename enable_if<__tuple_constructible<_Tuple, tuple<_Tp...> >::value && !__tuple_convertible<_Tuple, tuple<_Tp...> >::value, bool>::type = false> explicit tuple<_Tp...>(_Tuple &&__t) noexcept((is_nothrow_constructible<base, _Tuple>::value)tuple<_Tp...>(_Tuple &&__t) noexcept((is_nothrow_constructible<base, _Tuple>::value)) : base_(std::__1::forward<_Tuple>(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc, class _Tuple, class  = typename enable_if<__tuple_convertible<_Tuple, tuple<_Tp...> >::value>::type> tuple<_Tp...>(std::__1::allocator_arg_t, const _Alloc &__a, _Tuple &&__t) : base_(std::__1::allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Tuple, class  = typename enable_if<__tuple_assignable<_Tuple, tuple<_Tp...> >::value>::type> tuple<_Tp...> &operator=(_Tuple &&__t) noexcept((is_nothrow_assignable<base &, _Tuple>::value)operator=(_Tuple &&__t) noexcept((is_nothrow_assignable<base &, _Tuple>::value)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->base_.operator=(std::__1::forward<_Tuple>(__t));
                return *this;
            }

;
            void swap(tuple<_Tp...> &__t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::valueswap(tuple<_Tp...> &__t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->base_.swap(__t.base_);
            }


        };
        class __attribute__((type_visibility("default"))) tuple {
        public:
            constexpr tuple() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Alloc> tuple(std::__1::allocator_arg_t, const _Alloc &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc> tuple(std::__1::allocator_arg_t, const _Alloc &, const std::__1::tuple<> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Up> tuple(array<_Up, 0>) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc, class _Up> tuple(std::__1::allocator_arg_t, const _Alloc &, array<_Up, 0>) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            void swap(std::__1::tuple<> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        template <class ..._Tp> inline typename enable_if<__all<__is_swappable<_Tp>::value...>::value, void>::type swap(tuple<_Tp...> &__t, tuple<_Tp...> &__u) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::valueswap(tuple<_Tp...> &__t, tuple<_Tp...> &__u) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __t.swap(__u);
        }

;
        template <size_t _Ip, class ..._Tp> inline typename tuple_element<_Ip, tuple<_Tp...> >::type &get(tuple<_Tp...> &__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
            return static_cast<__tuple_leaf<_Ip, type> &>(__t.base_).get();
        }

;
        template <size_t _Ip, class ..._Tp> inline const typename tuple_element<_Ip, tuple<_Tp...> >::type &get(const tuple<_Tp...> &__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
            return static_cast<const __tuple_leaf<_Ip, type> &>(__t.base_).get();
        }

;
        template <size_t _Ip, class ..._Tp> inline typename tuple_element<_Ip, tuple<_Tp...> >::type &&get(tuple<_Tp...> &&__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
            return static_cast<type &&>(static_cast<__tuple_leaf<_Ip, type> &&>(__t.base_).get());
        }

;
        template <class ..._Tp> inline tuple<_Tp &...> tie(_Tp &...__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return tuple<_Tp &...>(__t...);
        }

;
        template <class _Up = unsigned char> struct __ignore_t {
            template <class _Tp> const std::__1::__ignore_t<unsigned char> &operator=(_Tp &&) const __attribute__((always_inline));
        }
template <class _Up> struct __ignore_t {
            template <class _Tp> const __ignore_t<_Up> &operator=(_Tp &&) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }

;
        };
        namespace  {
            const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
        }
        template <class _Tp> struct __make_tuple_return_impl {
            typedef _Tp type;
        };
        struct __make_tuple_return_impl {
            typedef _Tp &type;
        };
        template <class _Tp> struct __make_tuple_return {
            typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;
        };
        template <class ..._Tp> inline tuple<typename __make_tuple_return<_Tp>::type...> make_tuple(_Tp &&...__t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return tuple<typename __make_tuple_return<_Tp>::type...>(std::__1::forward<_Tp>(__t)...);
        }

;
        template <class ..._Tp = <>> inline tuple<> forward_as_tuple() noexcept __attribute__((always_inline))template <class ..._Tp> inline tuple<_Tp &&...> forward_as_tuple(_Tp &&...__t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return tuple<_Tp &&...>(std::__1::forward<_Tp>(__t)...);
        }

;
        template <size_t _Ip = 0> struct __tuple_equal {
            template <class _Tp, class _Up> bool operator()(const _Tp &, const _Up &) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return true;
            }

;
        }
template <size_t _Ip> struct __tuple_equal {
            template <class _Tp, class _Up> bool operator()(const _Tp &__x, const _Up &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __tuple_equal<_Ip - 1>()(__x, __y) && std::__1::get<_Ip - 1>(__x) == std::__1::get<_Ip - 1>(__y);
            }

;
        };
        struct __tuple_equal {
            template <class _Tp, class _Up> bool operator()(const _Tp &, const _Up &) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return true;
            }

;
        };
        template <class ..._Tp, class ..._Up> inline bool operator==(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
        }

;
        template <class ..._Tp, class ..._Up> inline bool operator!=(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }

;
        template <size_t _Ip = 0> struct __tuple_less {
            template <class _Tp, class _Up> bool operator()(const _Tp &, const _Up &) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return false;
            }

;
        }
template <size_t _Ip> struct __tuple_less {
            template <class _Tp, class _Up> bool operator()(const _Tp &__x, const _Up &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                const size_t __idx = tuple_size<_Tp>::value - _Ip;
                if (std::__1::get<__idx>(__x) < std::__1::get<__idx>(__y))
                    return true;
                if (std::__1::get<__idx>(__y) < std::__1::get<__idx>(__x))
                    return false;
                return __tuple_less<_Ip - 1>()(__x, __y);
            }

;
        };
        struct __tuple_less {
            template <class _Tp, class _Up> bool operator()(const _Tp &, const _Up &) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return false;
            }

;
        };
        template <class ..._Tp, class ..._Up> inline bool operator<(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __tuple_less<sizeof...(_Tp)>()(__x, __y);
        }

;
        template <class ..._Tp, class ..._Up> inline bool operator>(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __y < __x;
        }

;
        template <class ..._Tp, class ..._Up> inline bool operator>=(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < __y);
        }

;
        template <class ..._Tp, class ..._Up> inline bool operator<=(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__y < __x);
        }

;
        template <class _Tp, class _Up> struct __tuple_cat_type;
        struct __tuple_cat_type {
            typedef tuple<_Ttypes..., _Utypes...> type;
        };
        template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples> struct __tuple_cat_return_1 {
        };
        struct __tuple_cat_return_1 {
            typedef typename __tuple_cat_type<tuple<_Types...>, typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type type;
        };
        struct __tuple_cat_return_1 : public __tuple_cat_return_1<typename __tuple_cat_type<tuple<_Types...>, typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type, __tuple_like<typename remove_reference<_Tuple1>::type>::value, _Tuple1, _Tuples...> {
        };
        template <class ..._Tuples = <>> struct __tuple_cat_return {
            typedef tuple<> type;
        }
template <class ..._Tuples> struct __tuple_cat_return;
        struct __tuple_cat_return : public __tuple_cat_return_1<tuple<>, __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0, _Tuples...> {
        };
        struct __tuple_cat_return {
            typedef tuple<> type;
        };
        inline tuple<> tuple_cat() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return tuple<>();
        }


        template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples> struct __tuple_cat_return_ref_imp;
        struct __tuple_cat_return_ref_imp {
            typedef typename remove_reference<_Tuple0>::type _T0;
            typedef tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_I0, _T0>::type>::type &&...> type;
        };
        struct __tuple_cat_return_ref_imp : public __tuple_cat_return_ref_imp<tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_I0, typename remove_reference<_Tuple0>::type>::type>::type &&...>, typename __make_tuple_indices<tuple_size<typename remove_reference<_Tuple1>::type>::value>::type, _Tuple1, _Tuples...> {
        };
        template <class _Tuple0, class ..._Tuples> struct __tuple_cat_return_ref : public __tuple_cat_return_ref_imp<tuple<>, typename __make_tuple_indices<tuple_size<typename remove_reference<_Tuple0>::type>::value>::type, _Tuple0, _Tuples...> {
        };
        template <class _Types, class _I0, class _J0> struct __tuple_cat;
        struct __tuple_cat {
            template <class _Tuple0> typename __tuple_cat_return_ref<tuple<_Types...> &&, _Tuple0 &&>::type operator()(tuple<_Types...> __t, _Tuple0 &&__t0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return forward_as_tuple(std::__1::forward<_Types>(std::__1::get<_I0>(__t))..., std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...);
            }

;
            template <class _Tuple0, class _Tuple1, class ..._Tuples> typename __tuple_cat_return_ref<tuple<_Types...> &&, _Tuple0 &&, _Tuple1 &&, _Tuples &&...>::type operator()(tuple<_Types...> __t, _Tuple0 &&__t0, _Tuple1 &&__t1, _Tuples &&...__tpls) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename remove_reference<_Tuple0>::type _T0;
                typedef typename remove_reference<_Tuple1>::type _T1;
                return __tuple_cat<tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type &&...>, typename __make_tuple_indices<sizeof...(_Types) + tuple_size<_T0>::value>::type, typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(forward_as_tuple(std::__1::forward<_Types>(std::__1::get<_I0>(__t))..., std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...), std::__1::forward<_Tuple1>(__t1), std::__1::forward<_Tuples>(__tpls)...);
            }

;
        };
        template <class _Tuple0, class ..._Tuples> inline typename __tuple_cat_return<_Tuple0, _Tuples...>::type tuple_cat(_Tuple0 &&__t0, _Tuples &&...__tpls) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename remove_reference<_Tuple0>::type _T0;
            return __tuple_cat<tuple<>, __tuple_indices<>, typename __make_tuple_indices<tuple_size<_T0>::value>::type>()(tuple<>(), std::__1::forward<_Tuple0>(__t0), std::__1::forward<_Tuples>(__tpls)...);
        }

;
        struct __attribute__((type_visibility("default"))) uses_allocator : true_type {
        };
        template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> inline pair<_T1, _T2>(std::__1::piecewise_construct_t, tuple<_Args1...> &__first_args, tuple<_Args2...> &__second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) : first(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...), second(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }

;
    }
}
namespace std {
    inline namespace __1 {
        enum memory_order {
            memory_order_relaxed,
            memory_order_consume,
            memory_order_acquire,
            memory_order_release,
            memory_order_acq_rel,
            memory_order_seq_cst
        };
        typedef enum memory_order memory_order;
        template <class _Tp> inline _Tp kill_dependency(_Tp __y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __y;
        }

;
        template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value> struct __atomic_base {
            mutable _Atomic(_Tp) __a_;
            bool is_lock_free() const volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_is_lock_free(sizeof(_Tp));
            }


            bool is_lock_free() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<const volatile __atomic_base<_Tp, > *>(this)->is_lock_free();
            }


            void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __c11_atomic_store(&this->__a_, __d, __m);
            }


            void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __c11_atomic_store(&this->__a_, __d, __m);
            }


            _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_load(&this->__a_, __m);
            }


            _Tp load(memory_order __m = memory_order_seq_cst) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_load(&this->__a_, __m);
            }


            operator _Tp() const volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return load();
            }


            operator _Tp() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return load();
            }


            _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_exchange(&this->__a_, __d, __m);
            }


            _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_exchange(&this->__a_, __d, __m);
            }


            bool compare_exchange_weak(_Tp &__e, _Tp __d, memory_order __s, memory_order __f) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_compare_exchange_weak(&this->__a_, &__e, __d, __s, __f);
            }


            bool compare_exchange_weak(_Tp &__e, _Tp __d, memory_order __s, memory_order __f) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_compare_exchange_weak(&this->__a_, &__e, __d, __s, __f);
            }


            bool compare_exchange_strong(_Tp &__e, _Tp __d, memory_order __s, memory_order __f) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_compare_exchange_strong(&this->__a_, &__e, __d, __s, __f);
            }


            bool compare_exchange_strong(_Tp &__e, _Tp __d, memory_order __s, memory_order __f) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_compare_exchange_strong(&this->__a_, &__e, __d, __s, __f);
            }


            bool compare_exchange_weak(_Tp &__e, _Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_compare_exchange_weak(&this->__a_, &__e, __d, __m, __m);
            }


            bool compare_exchange_weak(_Tp &__e, _Tp __d, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_compare_exchange_weak(&this->__a_, &__e, __d, __m, __m);
            }


            bool compare_exchange_strong(_Tp &__e, _Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_compare_exchange_strong(&this->__a_, &__e, __d, __m, __m);
            }


            bool compare_exchange_strong(_Tp &__e, _Tp __d, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_compare_exchange_strong(&this->__a_, &__e, __d, __m, __m);
            }


            __atomic_base<_Tp, >() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
            constexpr __atomic_base<_Tp, >(_Tp __d) noexcept : __a_(__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            __atomic_base<_Tp, >(const __atomic_base<_Tp, > &) = delete
            __atomic_base<_Tp, > &operator=(const __atomic_base<_Tp, > &) = delete
            __atomic_base<_Tp, > &operator=(const __atomic_base<_Tp, > &) volatile = delete
        };
        struct __atomic_base : public __atomic_base<_Tp, false> {
            typedef __atomic_base<_Tp, false> __base;
            __atomic_base<type-parameter-0-0, true>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
            constexpr __atomic_base<type-parameter-0-0, true>(_Tp __d) noexcept : __base(__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_add(&this->__a_, __op, __m);
            }


            _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_add(&this->__a_, __op, __m);
            }


            _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_sub(&this->__a_, __op, __m);
            }


            _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_sub(&this->__a_, __op, __m);
            }


            _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_and(&this->__a_, __op, __m);
            }


            _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_and(&this->__a_, __op, __m);
            }


            _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_or(&this->__a_, __op, __m);
            }


            _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_or(&this->__a_, __op, __m);
            }


            _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_xor(&this->__a_, __op, __m);
            }


            _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_xor(&this->__a_, __op, __m);
            }


            _Tp operator++(int) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(_Tp(1));
            }


            _Tp operator++(int) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(_Tp(1));
            }


            _Tp operator--(int) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(_Tp(1));
            }


            _Tp operator--(int) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(_Tp(1));
            }


            _Tp operator++() volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(_Tp(1)) + _Tp(1);
            }


            _Tp operator++() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(_Tp(1)) + _Tp(1);
            }


            _Tp operator--() volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(_Tp(1)) - _Tp(1);
            }


            _Tp operator--() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(_Tp(1)) - _Tp(1);
            }


            _Tp operator+=(_Tp __op) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(__op) + __op;
            }


            _Tp operator+=(_Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(__op) + __op;
            }


            _Tp operator-=(_Tp __op) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(__op) - __op;
            }


            _Tp operator-=(_Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(__op) - __op;
            }


            _Tp operator&=(_Tp __op) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_and(__op) & __op;
            }


            _Tp operator&=(_Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_and(__op) & __op;
            }


            _Tp operator|=(_Tp __op) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_or(__op) | __op;
            }


            _Tp operator|=(_Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_or(__op) | __op;
            }


            _Tp operator^=(_Tp __op) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_xor(__op) ^ __op;
            }


            _Tp operator^=(_Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_xor(__op) ^ __op;
            }


        };
        template <class _Tp = bool> struct atomic
template <class _Tp = char> struct atomic
template <class _Tp = signed char> struct atomic
template <class _Tp = unsigned char> struct atomic
template <class _Tp = short> struct atomic
template <class _Tp = unsigned short> struct atomic
template <class _Tp = int> struct atomic
template <class _Tp = unsigned int> struct atomic
template <class _Tp = long> struct atomic
template <class _Tp = unsigned long> struct atomic
template <class _Tp = long long> struct atomic
template <class _Tp = unsigned long long> struct atomic
template <class _Tp = char16_t> struct atomic
template <class _Tp = char32_t> struct atomic
template <class _Tp = wchar_t> struct atomic
template <class _Tp> struct atomic : public __atomic_base<_Tp> {
            typedef __atomic_base<_Tp> __base;
            atomic<_Tp>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
            constexpr atomic<_Tp>(_Tp __d) noexcept : __base(__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Tp operator=(_Tp __d) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __base::store(__d);
                return __d;
            }


            _Tp operator=(_Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __base::store(__d);
                return __d;
            }


        };
        struct atomic : public __atomic_base<_Tp *> {
            typedef __atomic_base<_Tp *> __base;
            atomic<type-parameter-0-0 *>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
            constexpr atomic<type-parameter-0-0 *>(_Tp *__d) noexcept : __base(__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Tp *operator=(_Tp *__d) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __base::store(__d);
                return __d;
            }


            _Tp *operator=(_Tp *__d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __base::store(__d);
                return __d;
            }


            _Tp *fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_add(&this->__a_, __op, __m);
            }


            _Tp *fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_add(&this->__a_, __op, __m);
            }


            _Tp *fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_sub(&this->__a_, __op, __m);
            }


            _Tp *fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_fetch_sub(&this->__a_, __op, __m);
            }


            _Tp *operator++(int) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(1);
            }


            _Tp *operator++(int) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(1);
            }


            _Tp *operator--(int) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(1);
            }


            _Tp *operator--(int) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(1);
            }


            _Tp *operator++() volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(1) + 1;
            }


            _Tp *operator++() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(1) + 1;
            }


            _Tp *operator--() volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(1) - 1;
            }


            _Tp *operator--() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(1) - 1;
            }


            _Tp *operator+=(ptrdiff_t __op) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(__op) + __op;
            }


            _Tp *operator+=(ptrdiff_t __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_add(__op) + __op;
            }


            _Tp *operator-=(ptrdiff_t __op) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(__op) - __op;
            }


            _Tp *operator-=(ptrdiff_t __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return fetch_sub(__op) - __op;
            }


        };
        template <class _Tp> inline bool atomic_is_lock_free(const volatile atomic<_Tp> *__o) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->is_lock_free();
        }

;
        template <class _Tp> inline bool atomic_is_lock_free(const atomic<_Tp> *__o) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->is_lock_free();
        }

;
        template <class _Tp> inline void atomic_init(volatile atomic<_Tp> *__o, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __c11_atomic_init(&__o->__a_, __d);
        }

;
        template <class _Tp> inline void atomic_init(atomic<_Tp> *__o, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __c11_atomic_init(&__o->__a_, __d);
        }

;
        template <class _Tp> inline void atomic_store(volatile atomic<_Tp> *__o, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __o->store(__d);
        }

;
        template <class _Tp> inline void atomic_store(atomic<_Tp> *__o, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __o->store(__d);
        }

;
        template <class _Tp> inline void atomic_store_explicit(volatile atomic<_Tp> *__o, _Tp __d, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __o->store(__d, __m);
        }

;
        template <class _Tp> inline void atomic_store_explicit(atomic<_Tp> *__o, _Tp __d, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __o->store(__d, __m);
        }

;
        template <class _Tp> inline _Tp atomic_load(const volatile atomic<_Tp> *__o) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->load();
        }

;
        template <class _Tp> inline _Tp atomic_load(const atomic<_Tp> *__o) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->load();
        }

;
        template <class _Tp> inline _Tp atomic_load_explicit(const volatile atomic<_Tp> *__o, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->load(__m);
        }

;
        template <class _Tp> inline _Tp atomic_load_explicit(const atomic<_Tp> *__o, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->load(__m);
        }

;
        template <class _Tp> inline _Tp atomic_exchange(volatile atomic<_Tp> *__o, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->exchange(__d);
        }

;
        template <class _Tp> inline _Tp atomic_exchange(atomic<_Tp> *__o, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->exchange(__d);
        }

;
        template <class _Tp> inline _Tp atomic_exchange_explicit(volatile atomic<_Tp> *__o, _Tp __d, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->exchange(__d, __m);
        }

;
        template <class _Tp> inline _Tp atomic_exchange_explicit(atomic<_Tp> *__o, _Tp __d, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->exchange(__d, __m);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_weak(volatile atomic<_Tp> *__o, _Tp *__e, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->compare_exchange_weak(*__e, __d);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_weak(atomic<_Tp> *__o, _Tp *__e, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->compare_exchange_weak(*__e, __d);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_strong(volatile atomic<_Tp> *__o, _Tp *__e, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->compare_exchange_strong(*__e, __d);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_strong(atomic<_Tp> *__o, _Tp *__e, _Tp __d) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->compare_exchange_strong(*__e, __d);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_weak_explicit(volatile atomic<_Tp> *__o, _Tp *__e, _Tp __d, memory_order __s, memory_order __f) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->compare_exchange_weak(*__e, __d, __s, __f);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_weak_explicit(atomic<_Tp> *__o, _Tp *__e, _Tp __d, memory_order __s, memory_order __f) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->compare_exchange_weak(*__e, __d, __s, __f);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_strong_explicit(volatile atomic<_Tp> *__o, _Tp *__e, _Tp __d, memory_order __s, memory_order __f) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->compare_exchange_strong(*__e, __d, __s, __f);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_strong_explicit(atomic<_Tp> *__o, _Tp *__e, _Tp __d, memory_order __s, memory_order __f) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->compare_exchange_strong(*__e, __d, __s, __f);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_add(volatile atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_add(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_add(atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_add(__op);
        }

;
        template <class _Tp> inline _Tp *atomic_fetch_add(volatile atomic<_Tp *> *__o, ptrdiff_t __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_add(__op);
        }

;
        template <class _Tp> inline _Tp *atomic_fetch_add(atomic<_Tp *> *__o, ptrdiff_t __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_add(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_add_explicit(volatile atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_add(__op, __m);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_add_explicit(atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_add(__op, __m);
        }

;
        template <class _Tp> inline _Tp *atomic_fetch_add_explicit(volatile atomic<_Tp *> *__o, ptrdiff_t __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_add(__op, __m);
        }

;
        template <class _Tp> inline _Tp *atomic_fetch_add_explicit(atomic<_Tp *> *__o, ptrdiff_t __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_add(__op, __m);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_sub(volatile atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_sub(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_sub(atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_sub(__op);
        }

;
        template <class _Tp> inline _Tp *atomic_fetch_sub(volatile atomic<_Tp *> *__o, ptrdiff_t __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_sub(__op);
        }

;
        template <class _Tp> inline _Tp *atomic_fetch_sub(atomic<_Tp *> *__o, ptrdiff_t __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_sub(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_sub_explicit(volatile atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_sub(__op, __m);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_sub_explicit(atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_sub(__op, __m);
        }

;
        template <class _Tp> inline _Tp *atomic_fetch_sub_explicit(volatile atomic<_Tp *> *__o, ptrdiff_t __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_sub(__op, __m);
        }

;
        template <class _Tp> inline _Tp *atomic_fetch_sub_explicit(atomic<_Tp *> *__o, ptrdiff_t __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_sub(__op, __m);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_and(volatile atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_and(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_and(atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_and(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_and_explicit(volatile atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_and(__op, __m);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_and_explicit(atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_and(__op, __m);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_or(volatile atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_or(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_or(atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_or(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_or_explicit(volatile atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_or(__op, __m);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_or_explicit(atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_or(__op, __m);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_xor(volatile atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_xor(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_xor(atomic<_Tp> *__o, _Tp __op) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_xor(__op);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_xor_explicit(volatile atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_xor(__op, __m);
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_xor_explicit(atomic<_Tp> *__o, _Tp __op, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->fetch_xor(__op, __m);
        }

;
        struct atomic_flag {
            _Atomic(bool) __a_;
            bool test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_exchange(&this->__a_, true, __m);
            }


            bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __c11_atomic_exchange(&this->__a_, true, __m);
            }


            void clear(memory_order __m = memory_order_seq_cst) volatile noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __c11_atomic_store(&this->__a_, false, __m);
            }


            void clear(memory_order __m = memory_order_seq_cst) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __c11_atomic_store(&this->__a_, false, __m);
            }


            atomic_flag() __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
            atomic_flag(bool __b) noexcept : __a_(__b) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            atomic_flag(const std::__1::atomic_flag &) = delete
            std::__1::atomic_flag &operator=(const std::__1::atomic_flag &) = delete
            std::__1::atomic_flag &operator=(const std::__1::atomic_flag &) volatile = delete
        };
        typedef struct atomic_flag atomic_flag;
        inline bool atomic_flag_test_and_set(volatile atomic_flag *__o) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->test_and_set();
        }


        inline bool atomic_flag_test_and_set(atomic_flag *__o) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->test_and_set();
        }


        inline bool atomic_flag_test_and_set_explicit(volatile atomic_flag *__o, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->test_and_set(__m);
        }


        inline bool atomic_flag_test_and_set_explicit(atomic_flag *__o, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __o->test_and_set(__m);
        }


        inline void atomic_flag_clear(volatile atomic_flag *__o) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __o->clear();
        }


        inline void atomic_flag_clear(atomic_flag *__o) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __o->clear();
        }


        inline void atomic_flag_clear_explicit(volatile atomic_flag *__o, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __o->clear(__m);
        }


        inline void atomic_flag_clear_explicit(atomic_flag *__o, memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __o->clear(__m);
        }


        inline void atomic_thread_fence(memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __c11_atomic_thread_fence(__m);
        }


        inline void atomic_signal_fence(memory_order __m) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __c11_atomic_signal_fence(__m);
        }


        typedef atomic<bool> atomic_bool;
        typedef atomic<char> atomic_char;
        typedef atomic<signed char> atomic_schar;
        typedef atomic<unsigned char> atomic_uchar;
        typedef atomic<short> atomic_short;
        typedef atomic<unsigned short> atomic_ushort;
        typedef atomic<int> atomic_int;
        typedef atomic<unsigned int> atomic_uint;
        typedef atomic<long> atomic_long;
        typedef atomic<unsigned long> atomic_ulong;
        typedef atomic<long long> atomic_llong;
        typedef atomic<unsigned long long> atomic_ullong;
        typedef atomic<char16_t> atomic_char16_t;
        typedef atomic<char32_t> atomic_char32_t;
        typedef atomic<wchar_t> atomic_wchar_t;
        typedef atomic<int_least8_t> atomic_int_least8_t;
        typedef atomic<uint_least8_t> atomic_uint_least8_t;
        typedef atomic<int_least16_t> atomic_int_least16_t;
        typedef atomic<uint_least16_t> atomic_uint_least16_t;
        typedef atomic<int_least32_t> atomic_int_least32_t;
        typedef atomic<uint_least32_t> atomic_uint_least32_t;
        typedef atomic<int_least64_t> atomic_int_least64_t;
        typedef atomic<uint_least64_t> atomic_uint_least64_t;
        typedef atomic<int_fast8_t> atomic_int_fast8_t;
        typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
        typedef atomic<int_fast16_t> atomic_int_fast16_t;
        typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
        typedef atomic<int_fast32_t> atomic_int_fast32_t;
        typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
        typedef atomic<int_fast64_t> atomic_int_fast64_t;
        typedef atomic<uint_fast64_t> atomic_uint_fast64_t;
        typedef atomic<intptr_t> atomic_intptr_t;
        typedef atomic<uintptr_t> atomic_uintptr_t;
        typedef atomic<size_t> atomic_size_t;
        typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
        typedef atomic<intmax_t> atomic_intmax_t;
        typedef atomic<uintmax_t> atomic_uintmax_t;
    }
}
namespace std {
    inline namespace __1 {
        template <class _ValueType = long> inline long __libcpp_relaxed_load(const long *__value) __attribute__((always_inline))         {
            return __atomic_load_n(__value, 0);
        }

template <class _ValueType = unsigned long> inline unsigned long __libcpp_relaxed_load(const unsigned long *__value) __attribute__((always_inline))template <class _ValueType> inline _ValueType __libcpp_relaxed_load(const _ValueType *__value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __atomic_load_n(__value, 0);
        }

;
        template <class _Tp = char> class allocator {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef char *pointer;
            typedef const char *const_pointer;
            typedef char &reference;
            typedef const char &const_reference;
            typedef char value_type;
            typedef true_type propagate_on_container_move_assignment;
            typedef true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() noexcept __attribute__((always_inline))             {
            }


            template <class _Up = char> allocator(const allocator<char> &) noexcept __attribute__((always_inline))template <class _Up> allocator(const allocator<_Up> &) noexcept __attribute__((always_inline));
            pointer address(reference __x) const noexcept __attribute__((always_inline));
            const_pointer address(const_reference __x) const noexcept __attribute__((always_inline));
            pointer allocate(size_type __n, allocator<void>::const_pointer) __attribute__((always_inline));
            void deallocate(pointer __p, size_type) noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            template <class _Up, class ..._Args> void construct(_Up *__p, _Args &&...__args) __attribute__((always_inline));
            void destroy(pointer __p) __attribute__((always_inline));
        }
template <class _Tp = wchar_t> class allocator {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef wchar_t *pointer;
            typedef const wchar_t *const_pointer;
            typedef wchar_t &reference;
            typedef const wchar_t &const_reference;
            typedef wchar_t value_type;
            typedef true_type propagate_on_container_move_assignment;
            typedef true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() noexcept __attribute__((always_inline));
            template <class _Up = wchar_t> allocator(const allocator<wchar_t> &) noexcept __attribute__((always_inline))template <class _Up> allocator(const allocator<_Up> &) noexcept __attribute__((always_inline));
            pointer address(reference __x) const noexcept __attribute__((always_inline));
            const_pointer address(const_reference __x) const noexcept __attribute__((always_inline));
            pointer allocate(size_type __n, allocator<void>::const_pointer) __attribute__((always_inline));
            void deallocate(pointer __p, size_type) noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            template <class _Up, class ..._Args> void construct(_Up *__p, _Args &&...__args) __attribute__((always_inline));
            void destroy(pointer __p) __attribute__((always_inline));
        }
template <class _Tp = void> class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef void *pointer;
            typedef const void *const_pointer;
            typedef void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        }
template <class _Tp = const void> class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef const void *pointer;
            typedef const void *const_pointer;
            typedef const void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        }
template <class _Tp = char16_t> class allocator
template <class _Tp = char32_t> class allocator
template <class _Tp> class __attribute__((type_visibility("default"))) allocator;
        class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef void *pointer;
            typedef const void *const_pointer;
            typedef void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        };
        class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef const void *pointer;
            typedef const void *const_pointer;
            typedef const void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        };
        template <class _Tp> struct __has_element_type {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_element_type::__two __test(...);
            template <class _Up> static char __test(typename _Up::element_type * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Ptr, bool = __has_element_type<_Ptr>::value> struct __pointer_traits_element_type;
        struct __pointer_traits_element_type {
            typedef typename _Ptr::element_type type;
        };
        struct __pointer_traits_element_type {
            typedef typename _Sp<_Tp, _Args...>::element_type type;
        };
        struct __pointer_traits_element_type {
            typedef _Tp type;
        };
        template <class _Tp = std::__1::allocator<char>> struct __has_difference_type {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<char>> static std::__1::__has_difference_type<std::__1::allocator<char> >::__two __test(...)template <class _Up> static std::__1::__has_difference_type<std::__1::allocator<char> >::__two __test(...);
            template <class _Up = std::__1::allocator<char>> static char __test(typename allocator<char>::difference_type *)template <class _Up> static char __test(typename _Up::difference_type *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<char> >(0)) == 1;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_difference_type {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__has_difference_type<std::__1::allocator<wchar_t> >::__two __test(...)template <class _Up> static std::__1::__has_difference_type<std::__1::allocator<wchar_t> >::__two __test(...);
            template <class _Up = std::__1::allocator<wchar_t>> static char __test(typename allocator<wchar_t>::difference_type *)template <class _Up> static char __test(typename _Up::difference_type *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<wchar_t> >(0)) == 1;
        }
template <class _Tp> struct __has_difference_type {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_difference_type::__two __test(...);
            template <class _Up> static char __test(typename _Up::difference_type * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Ptr, bool = __has_difference_type<_Ptr>::value> struct __pointer_traits_difference_type {
            typedef ptrdiff_t type;
        };
        struct __pointer_traits_difference_type {
            typedef typename _Ptr::difference_type type;
        };
        template <class _Tp, class _Up> struct __has_rebind {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Xp> static std::__1::__has_rebind::__two __test(...);
            template <class _Xp> static char __test(typename _Xp::rebind<_Up> * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value> struct __pointer_traits_rebind {
            typedef typename _Tp::rebind<_Up> type;
        };
        struct __pointer_traits_rebind {
            typedef typename _Sp<_Tp, _Args...>::rebind<_Up> type;
        };
        struct __pointer_traits_rebind {
            typedef _Sp<_Up, _Args...> type;
        };
        template <class _Ptr = char *> struct pointer_traits {
            typedef char *pointer;
            typedef char element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> using rebind = _Up *;
        private:
            struct __nat;
        public:
            static pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) noexcept __attribute__((always_inline));
        }
template <class _Ptr = wchar_t *> struct pointer_traits {
            typedef wchar_t *pointer;
            typedef wchar_t element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> using rebind = _Up *;
        private:
            struct __nat;
        public:
            static pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) noexcept __attribute__((always_inline));
        }
template <class _Ptr = const char *> struct pointer_traits {
            typedef const char *pointer;
            typedef const char element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> using rebind = _Up *;
        private:
            struct __nat;
        public:
            static pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) noexcept __attribute__((always_inline))             {
                return std::__1::addressof(__r);
            }


        }
template <class _Ptr> struct __attribute__((type_visibility("default"))) pointer_traits {
            typedef _Ptr pointer;
            typedef typename __pointer_traits_element_type<pointer>::type element_type;
            typedef typename __pointer_traits_difference_type<pointer>::type difference_type;
            template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;
        private:
            struct __nat {
            };
        public:
            static pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return pointer::pointer_to(__r);
            }


        };
        struct __attribute__((type_visibility("default"))) pointer_traits {
            typedef _Tp *pointer;
            typedef _Tp element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> using rebind = _Up *;
        private:
            struct __nat {
            };
        public:
            static pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::addressof(__r);
            }


        };
        template <class _From, class _To> struct __rebind_pointer {
            typedef typename pointer_traits<_From>::rebind<_To> type;
        };
        namespace __has_pointer_type_imp {
            template <class _Up = std::__1::allocator<char>> static std::__1::__two __test(...)template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__two __test(...)template <class _Up = void (*)(void *)> static std::__1::__two __test(...)template <class _Up> static std::__1::__two __test(...);
            template <class _Up = std::__1::allocator<char>> static char __test(typename allocator<char>::pointer *)template <class _Up = std::__1::allocator<wchar_t>> static char __test(typename allocator<wchar_t>::pointer *)template <class _Up> static char __test(typename _Up::pointer * = 0);
        }
        template <class _Tp = std::__1::allocator<char>> struct __has_pointer_type : public integral_constant<bool, sizeof (__has_pointer_type_imp::__test<std::__1::allocator<char> >(0)) == 1> {
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_pointer_type : public integral_constant<bool, sizeof (__has_pointer_type_imp::__test<std::__1::allocator<wchar_t> >(0)) == 1> {
        }
template <class _Tp = void (*)(void *)> struct __has_pointer_type : public integral_constant<bool, sizeof (__has_pointer_type_imp::__test<void (*)(void *)>(0)) == 1> {
        }
template <class _Tp> struct __has_pointer_type : public integral_constant<bool, sizeof (__has_pointer_type_imp::__test<_Tp>(0)) == 1> {
        };
        namespace __pointer_type_imp {
            template <class _Tp = char, class _Dp = std::__1::allocator<char>, bool = true> struct __pointer_type {
                typedef typename allocator<char>::pointer type;
            }
template <class _Tp = wchar_t, class _Dp = std::__1::allocator<wchar_t>, bool = true> struct __pointer_type {
                typedef typename allocator<wchar_t>::pointer type;
            }
template <class _Tp = unsigned char, class _Dp = void (*)(void *), bool = false> struct __pointer_type {
                typedef unsigned char *type;
            }
template <class _Tp = char, class _Dp = void (*)(void *), bool = false> struct __pointer_type {
                typedef char *type;
            }
template <class _Tp = unsigned int, class _Dp = void (*)(void *), bool = false> struct __pointer_type {
                typedef unsigned int *type;
            }
template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value> struct __pointer_type {
                typedef typename _Dp::pointer type;
            };
            struct __pointer_type {
                typedef _Tp *type;
            };
        }
        template <class _Tp = char, class _Dp = std::__1::allocator<char>> struct __pointer_type {
            typedef typename __pointer_type_imp::__pointer_type<char, typename remove_reference<allocator<char> >::type>::type type;
        }
template <class _Tp = wchar_t, class _Dp = std::__1::allocator<wchar_t>> struct __pointer_type {
            typedef typename __pointer_type_imp::__pointer_type<wchar_t, typename remove_reference<allocator<wchar_t> >::type>::type type;
        }
template <class _Tp = unsigned char, class _Dp = void (*)(void *)> struct __pointer_type {
            typedef typename __pointer_type_imp::__pointer_type<unsigned char, typename remove_reference<void (*)(void *)>::type>::type type;
        }
template <class _Tp = char, class _Dp = void (*)(void *)> struct __pointer_type {
            typedef typename __pointer_type_imp::__pointer_type<char, typename remove_reference<void (*)(void *)>::type>::type type;
        }
template <class _Tp = unsigned int, class _Dp = void (*)(void *)> struct __pointer_type {
            typedef typename __pointer_type_imp::__pointer_type<unsigned int, typename remove_reference<void (*)(void *)>::type>::type type;
        }
template <class _Tp, class _Dp> struct __pointer_type {
            typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
        };
        template <class _Tp = std::__1::allocator<char>> struct __has_const_pointer {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<char>> static std::__1::__has_const_pointer<std::__1::allocator<char> >::__two __test(...)template <class _Up> static std::__1::__has_const_pointer<std::__1::allocator<char> >::__two __test(...);
            template <class _Up = std::__1::allocator<char>> static char __test(typename allocator<char>::const_pointer *)template <class _Up> static char __test(typename _Up::const_pointer *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<char> >(0)) == 1;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_const_pointer {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__has_const_pointer<std::__1::allocator<wchar_t> >::__two __test(...)template <class _Up> static std::__1::__has_const_pointer<std::__1::allocator<wchar_t> >::__two __test(...);
            template <class _Up = std::__1::allocator<wchar_t>> static char __test(typename allocator<wchar_t>::const_pointer *)template <class _Up> static char __test(typename _Up::const_pointer *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<wchar_t> >(0)) == 1;
        }
template <class _Tp> struct __has_const_pointer {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_const_pointer::__two __test(...);
            template <class _Up> static char __test(typename _Up::const_pointer * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Tp = char, class _Ptr = char *, class _Alloc = std::__1::allocator<char>, bool = true> struct __const_pointer {
            typedef typename allocator<char>::const_pointer type;
        }
template <class _Tp = wchar_t, class _Ptr = wchar_t *, class _Alloc = std::__1::allocator<wchar_t>, bool = true> struct __const_pointer {
            typedef typename allocator<wchar_t>::const_pointer type;
        }
template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value> struct __const_pointer {
            typedef typename _Alloc::const_pointer type;
        };
        struct __const_pointer {
            typedef typename pointer_traits<_Ptr>::rebind<const _Tp> type;
        };
        template <class _Tp = std::__1::allocator<char>> struct __has_void_pointer {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up = std::__1::allocator<char>> static std::__1::__has_void_pointer<std::__1::allocator<char> >::__two __test(...)template <class _Up> static std::__1::__has_void_pointer<std::__1::allocator<char> >::__two __test(...);
            template <class _Up> static char __test(typename _Up::void_pointer *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<char> >(0)) == 1;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_void_pointer {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__has_void_pointer<std::__1::allocator<wchar_t> >::__two __test(...)template <class _Up> static std::__1::__has_void_pointer<std::__1::allocator<wchar_t> >::__two __test(...);
            template <class _Up> static char __test(typename _Up::void_pointer *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<wchar_t> >(0)) == 1;
        }
template <class _Tp> struct __has_void_pointer {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_void_pointer::__two __test(...);
            template <class _Up> static char __test(typename _Up::void_pointer * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Ptr = char *, class _Alloc = std::__1::allocator<char>, bool = false> struct __void_pointer {
            typedef typename pointer_traits<char *>::rebind<void> type;
        }
template <class _Ptr = wchar_t *, class _Alloc = std::__1::allocator<wchar_t>, bool = false> struct __void_pointer {
            typedef typename pointer_traits<wchar_t *>::rebind<void> type;
        }
template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value> struct __void_pointer {
            typedef typename _Alloc::void_pointer type;
        };
        struct __void_pointer {
            typedef typename pointer_traits<_Ptr>::rebind<void> type;
        };
        template <class _Tp = std::__1::allocator<char>> struct __has_const_void_pointer {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up = std::__1::allocator<char>> static std::__1::__has_const_void_pointer<std::__1::allocator<char> >::__two __test(...)template <class _Up> static std::__1::__has_const_void_pointer<std::__1::allocator<char> >::__two __test(...);
            template <class _Up> static char __test(typename _Up::const_void_pointer *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<char> >(0)) == 1;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_const_void_pointer {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__has_const_void_pointer<std::__1::allocator<wchar_t> >::__two __test(...)template <class _Up> static std::__1::__has_const_void_pointer<std::__1::allocator<wchar_t> >::__two __test(...);
            template <class _Up> static char __test(typename _Up::const_void_pointer *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<wchar_t> >(0)) == 1;
        }
template <class _Tp> struct __has_const_void_pointer {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_const_void_pointer::__two __test(...);
            template <class _Up> static char __test(typename _Up::const_void_pointer * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Ptr = char *, class _Alloc = std::__1::allocator<char>, bool = false> struct __const_void_pointer {
            typedef typename pointer_traits<char *>::rebind<const void> type;
        }
template <class _Ptr = wchar_t *, class _Alloc = std::__1::allocator<wchar_t>, bool = false> struct __const_void_pointer {
            typedef typename pointer_traits<wchar_t *>::rebind<const void> type;
        }
template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value> struct __const_void_pointer {
            typedef typename _Alloc::const_void_pointer type;
        };
        struct __const_void_pointer {
            typedef typename pointer_traits<_Ptr>::rebind<const void> type;
        };
        template <class _Tp = const char> inline const char *__to_raw_pointer(const char *__p) noexcept __attribute__((always_inline))         {
            return __p;
        }

template <class _Tp> inline _Tp *__to_raw_pointer(_Tp *__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __p;
        }

;
        template <class _Pointer = const char *> inline typename pointer_traits<const char *>::element_type *__to_raw_pointer(const char *__p) noexcept __attribute__((always_inline))template <class _Pointer> inline typename pointer_traits<_Pointer>::element_type *__to_raw_pointer(_Pointer __p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__to_raw_pointer(__p.operator->());
        }

;
        template <class _Tp = std::__1::allocator<char>> struct __has_size_type {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<char>> static std::__1::__has_size_type<std::__1::allocator<char> >::__two __test(...)template <class _Up> static std::__1::__has_size_type<std::__1::allocator<char> >::__two __test(...);
            template <class _Up = std::__1::allocator<char>> static char __test(typename allocator<char>::size_type *)template <class _Up> static char __test(typename _Up::size_type *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<char> >(0)) == 1;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_size_type {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__has_size_type<std::__1::allocator<wchar_t> >::__two __test(...)template <class _Up> static std::__1::__has_size_type<std::__1::allocator<wchar_t> >::__two __test(...);
            template <class _Up = std::__1::allocator<wchar_t>> static char __test(typename allocator<wchar_t>::size_type *)template <class _Up> static char __test(typename _Up::size_type *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<wchar_t> >(0)) == 1;
        }
template <class _Tp> struct __has_size_type {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_size_type::__two __test(...);
            template <class _Up> static char __test(typename _Up::size_type * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Alloc = std::__1::allocator<char>, class _DiffType = long, bool = true> struct __size_type {
            typedef typename allocator<char>::size_type type;
        }
template <class _Alloc = std::__1::allocator<wchar_t>, class _DiffType = long, bool = true> struct __size_type {
            typedef typename allocator<wchar_t>::size_type type;
        }
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value> struct __size_type {
            typedef typename make_unsigned<_DiffType>::type type;
        };
        struct __size_type {
            typedef typename _Alloc::size_type type;
        };
        template <class _Tp = std::__1::allocator<char>> struct __has_propagate_on_container_copy_assignment {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up = std::__1::allocator<char>> static std::__1::__has_propagate_on_container_copy_assignment<std::__1::allocator<char> >::__two __test(...)template <class _Up> static std::__1::__has_propagate_on_container_copy_assignment<std::__1::allocator<char> >::__two __test(...);
            template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<char> >(0)) == 1;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_propagate_on_container_copy_assignment {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__has_propagate_on_container_copy_assignment<std::__1::allocator<wchar_t> >::__two __test(...)template <class _Up> static std::__1::__has_propagate_on_container_copy_assignment<std::__1::allocator<wchar_t> >::__two __test(...);
            template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<wchar_t> >(0)) == 1;
        }
template <class _Tp> struct __has_propagate_on_container_copy_assignment {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_propagate_on_container_copy_assignment::__two __test(...);
            template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Alloc = std::__1::allocator<char>, bool = false> struct __propagate_on_container_copy_assignment {
            typedef false_type type;
        }
template <class _Alloc = std::__1::allocator<wchar_t>, bool = false> struct __propagate_on_container_copy_assignment {
            typedef false_type type;
        }
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value> struct __propagate_on_container_copy_assignment {
            typedef false_type type;
        };
        struct __propagate_on_container_copy_assignment {
            typedef typename _Alloc::propagate_on_container_copy_assignment type;
        };
        template <class _Tp = std::__1::allocator<char>> struct __has_propagate_on_container_move_assignment {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<char>> static std::__1::__has_propagate_on_container_move_assignment<std::__1::allocator<char> >::__two __test(...)template <class _Up> static std::__1::__has_propagate_on_container_move_assignment<std::__1::allocator<char> >::__two __test(...);
            template <class _Up = std::__1::allocator<char>> static char __test(typename allocator<char>::propagate_on_container_move_assignment *)template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<char> >(0)) == 1;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_propagate_on_container_move_assignment {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__has_propagate_on_container_move_assignment<std::__1::allocator<wchar_t> >::__two __test(...)template <class _Up> static std::__1::__has_propagate_on_container_move_assignment<std::__1::allocator<wchar_t> >::__two __test(...);
            template <class _Up = std::__1::allocator<wchar_t>> static char __test(typename allocator<wchar_t>::propagate_on_container_move_assignment *)template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<wchar_t> >(0)) == 1;
        }
template <class _Tp> struct __has_propagate_on_container_move_assignment {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_propagate_on_container_move_assignment::__two __test(...);
            template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Alloc = std::__1::allocator<char>, bool = true> struct __propagate_on_container_move_assignment {
            typedef typename allocator<char>::propagate_on_container_move_assignment type;
        }
template <class _Alloc = std::__1::allocator<wchar_t>, bool = true> struct __propagate_on_container_move_assignment {
            typedef typename allocator<wchar_t>::propagate_on_container_move_assignment type;
        }
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value> struct __propagate_on_container_move_assignment {
            typedef false_type type;
        };
        struct __propagate_on_container_move_assignment {
            typedef typename _Alloc::propagate_on_container_move_assignment type;
        };
        template <class _Tp = std::__1::allocator<char>> struct __has_propagate_on_container_swap {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up = std::__1::allocator<char>> static std::__1::__has_propagate_on_container_swap<std::__1::allocator<char> >::__two __test(...)template <class _Up> static std::__1::__has_propagate_on_container_swap<std::__1::allocator<char> >::__two __test(...);
            template <class _Up> static char __test(typename _Up::propagate_on_container_swap *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<char> >(0)) == 1;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_propagate_on_container_swap {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__has_propagate_on_container_swap<std::__1::allocator<wchar_t> >::__two __test(...)template <class _Up> static std::__1::__has_propagate_on_container_swap<std::__1::allocator<wchar_t> >::__two __test(...);
            template <class _Up> static char __test(typename _Up::propagate_on_container_swap *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<wchar_t> >(0)) == 1;
        }
template <class _Tp> struct __has_propagate_on_container_swap {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_propagate_on_container_swap::__two __test(...);
            template <class _Up> static char __test(typename _Up::propagate_on_container_swap * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Alloc = std::__1::allocator<char>, bool = false> struct __propagate_on_container_swap {
            typedef false_type type;
        }
template <class _Alloc = std::__1::allocator<wchar_t>, bool = false> struct __propagate_on_container_swap {
            typedef false_type type;
        }
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value> struct __propagate_on_container_swap {
            typedef false_type type;
        };
        struct __propagate_on_container_swap {
            typedef typename _Alloc::propagate_on_container_swap type;
        };
        template <class _Tp = std::__1::allocator<char>> struct __has_is_always_equal {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<char>> static std::__1::__has_is_always_equal<std::__1::allocator<char> >::__two __test(...)template <class _Up> static std::__1::__has_is_always_equal<std::__1::allocator<char> >::__two __test(...);
            template <class _Up = std::__1::allocator<char>> static char __test(typename allocator<char>::is_always_equal *)template <class _Up> static char __test(typename _Up::is_always_equal *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<char> >(0)) == 1;
        }
template <class _Tp = std::__1::allocator<wchar_t>> struct __has_is_always_equal {
        private:
            struct __two;
            template <class _Up = std::__1::allocator<wchar_t>> static std::__1::__has_is_always_equal<std::__1::allocator<wchar_t> >::__two __test(...)template <class _Up> static std::__1::__has_is_always_equal<std::__1::allocator<wchar_t> >::__two __test(...);
            template <class _Up = std::__1::allocator<wchar_t>> static char __test(typename allocator<wchar_t>::is_always_equal *)template <class _Up> static char __test(typename _Up::is_always_equal *);
        public:
            static const bool value = sizeof (__test<std::__1::allocator<wchar_t> >(0)) == 1;
        }
template <class _Tp> struct __has_is_always_equal {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_is_always_equal::__two __test(...);
            template <class _Up> static char __test(typename _Up::is_always_equal * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Alloc = std::__1::allocator<char>, bool = true> struct __is_always_equal {
            typedef typename allocator<char>::is_always_equal type;
        }
template <class _Alloc = std::__1::allocator<wchar_t>, bool = true> struct __is_always_equal {
            typedef typename allocator<wchar_t>::is_always_equal type;
        }
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value> struct __is_always_equal {
            typedef typename std::__1::is_empty<_Alloc>::type type;
        };
        struct __is_always_equal {
            typedef typename _Alloc::is_always_equal type;
        };
        template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value> struct __has_rebind_other {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Xp> static std::__1::__has_rebind_other::__two __test(...);
            template <class _Xp> static char __test(typename _Xp::template _Xp::rebind<_Up>::other * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        struct __has_rebind_other {
            static const bool value = false;
        };
        template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value> struct __allocator_traits_rebind {
            typedef typename _Tp::template _Tp::rebind<_Up>::other type;
        };
        struct __allocator_traits_rebind {
            typedef typename _Alloc<_Tp, _Args...>::template _Alloc<_Tp, _Args...>::rebind<_Up>::other type;
        };
        struct __allocator_traits_rebind {
            typedef _Alloc<_Up, _Args...> type;
        };
        template <class _Alloc, class _SizeType, class _ConstVoidPtr> auto __has_allocate_hint_test(_Alloc &&__a, _SizeType &&__sz, _ConstVoidPtr &&__p) -> decltype(__a.allocate(__sz, __p) , true_type());
        template <class _Alloc, class _SizeType, class _ConstVoidPtr> auto __has_allocate_hint_test(const _Alloc &__a, _SizeType &&__sz, _ConstVoidPtr &&__p) -> false_type;
        template <class _Alloc, class _SizeType, class _ConstVoidPtr> struct __has_allocate_hint : integral_constant<bool, is_same<decltype(__has_allocate_hint_test(declval<_Alloc>(), declval<_SizeType>(), declval<_ConstVoidPtr>())), true_type>::value> {
        };
        template <class _Alloc, class _Tp, class ..._Args> decltype(std::__1::declval<_Alloc>().construct(std::__1::declval<_Tp *>(), std::__1::declval<_Args>()...) , true_type()) __has_construct_test(_Alloc &&__a, _Tp *__p, _Args &&...__args);
        template <class _Alloc, class _Pointer, class ..._Args> false_type __has_construct_test(const _Alloc &__a, _Pointer &&__p, _Args &&...__args);
        template <class _Alloc, class _Pointer, class ..._Args> struct __has_construct : integral_constant<bool, is_same<decltype(__has_construct_test(declval<_Alloc>(), declval<_Pointer>(), declval<_Args>()...)), true_type>::value> {
        };
        template <class _Alloc, class _Pointer> auto __has_destroy_test(_Alloc &&__a, _Pointer &&__p) -> decltype(__a.destroy(__p) , true_type());
        template <class _Alloc, class _Pointer> auto __has_destroy_test(const _Alloc &__a, _Pointer &&__p) -> false_type;
        template <class _Alloc, class _Pointer> struct __has_destroy : integral_constant<bool, is_same<decltype(__has_destroy_test(declval<_Alloc>(), declval<_Pointer>())), true_type>::value> {
        };
        template <class _Alloc> auto __has_max_size_test(_Alloc &&__a) -> decltype(__a.max_size() , true_type());
        template <class _Alloc> auto __has_max_size_test(const volatile _Alloc &__a) -> false_type;
        template <class _Alloc> struct __has_max_size : integral_constant<bool, is_same<decltype(__has_max_size_test(declval<_Alloc &>())), true_type>::value> {
        };
        template <class _Alloc> auto __has_select_on_container_copy_construction_test(_Alloc &&__a) -> decltype(__a.select_on_container_copy_construction() , true_type());
        template <class _Alloc> auto __has_select_on_container_copy_construction_test(const volatile _Alloc &__a) -> false_type;
        template <class _Alloc> struct __has_select_on_container_copy_construction : integral_constant<bool, is_same<decltype(__has_select_on_container_copy_construction_test(declval<_Alloc &>())), true_type>::value> {
        };
        template <class _Alloc = std::__1::allocator<char>, class _Ptr = char *, bool = true> struct __alloc_traits_difference_type {
            typedef typename allocator<char>::difference_type type;
        }
template <class _Alloc = std::__1::allocator<wchar_t>, class _Ptr = wchar_t *, bool = true> struct __alloc_traits_difference_type {
            typedef typename allocator<wchar_t>::difference_type type;
        }
template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value> struct __alloc_traits_difference_type {
            typedef typename pointer_traits<_Ptr>::difference_type type;
        };
        struct __alloc_traits_difference_type {
            typedef typename _Alloc::difference_type type;
        };
        template <class _Alloc = std::__1::allocator<char>> struct allocator_traits {
            typedef std::__1::allocator<char> allocator_type;
            typedef typename allocator_type::value_type value_type;
            typedef typename __pointer_type<value_type, allocator_type>::type pointer;
            typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
            typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
            typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
            typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
            typedef typename __size_type<allocator_type, difference_type>::type size_type;
            typedef typename __propagate_on_container_copy_assignment<allocator_type>::type propagate_on_container_copy_assignment;
            typedef typename __propagate_on_container_move_assignment<allocator_type>::type propagate_on_container_move_assignment;
            typedef typename __propagate_on_container_swap<allocator_type>::type propagate_on_container_swap;
            typedef typename __is_always_equal<allocator_type>::type is_always_equal;
            template <class _Tp> using rebind_alloc = typename __allocator_traits_rebind<allocator_type, _Tp>::type;
            template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
            static pointer allocate(allocator_type &__a, size_type __n) __attribute__((always_inline));
            static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) __attribute__((always_inline));
            static void deallocate(allocator_type &__a, pointer __p, size_type __n) noexcept __attribute__((always_inline));
            template <class _Tp, class ..._Args> static void construct(allocator_type &__a, _Tp *__p, _Args &&...__args) __attribute__((always_inline));
            template <class _Tp> static void destroy(allocator_type &__a, _Tp *__p) __attribute__((always_inline));
            static size_type max_size(const allocator_type &__a) noexcept __attribute__((always_inline));
            static allocator_type select_on_container_copy_construction(const allocator_type &__a) __attribute__((always_inline));
            template <class _Ptr> static void __construct_forward(allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__begin2) __attribute__((always_inline));
            template <class _Tp> static typename enable_if<(is_same<allocator_type, allocator<_Tp> >::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_forward(allocator_type &__a, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((always_inline));
            template <class _Iter, class _Ptr> static void __construct_range_forward(allocator_type &__a, _Iter __begin1, _Iter __end1, _Ptr &__begin2) __attribute__((always_inline));
            template <class _Tp> static typename enable_if<(is_same<allocator_type, allocator<_Tp> >::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_range_forward(allocator_type &__a, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((always_inline));
            template <class _Ptr> static void __construct_backward(allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__end2) __attribute__((always_inline));
            template <class _Tp> static typename enable_if<(is_same<allocator_type, allocator<_Tp> >::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_backward(allocator_type &__a, _Tp *__begin1, _Tp *__end1, _Tp *&__end2) __attribute__((always_inline));
        private:
            static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint, true_type) __attribute__((always_inline));
            static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer, false_type) __attribute__((always_inline));
            template <class _Tp, class ..._Args> static void __construct(true_type, allocator_type &__a, _Tp *__p, _Args &&...__args) __attribute__((always_inline));
            template <class _Tp, class ..._Args> static void __construct(false_type, allocator_type &, _Tp *__p, _Args &&...__args) __attribute__((always_inline));
            template <class _Tp> static void __destroy(true_type, allocator_type &__a, _Tp *__p) __attribute__((always_inline));
            template <class _Tp> static void __destroy(false_type, allocator_type &, _Tp *__p) __attribute__((always_inline));
            static size_type __max_size(true_type, const allocator_type &__a) __attribute__((always_inline));
            static size_type __max_size(false_type, const allocator_type &) __attribute__((always_inline));
            static allocator_type select_on_container_copy_construction(true_type, const allocator_type &__a) __attribute__((always_inline));
            static allocator_type select_on_container_copy_construction(false_type, const allocator_type &__a) __attribute__((always_inline));
        }
template <class _Alloc = std::__1::allocator<wchar_t>> struct allocator_traits {
            typedef std::__1::allocator<wchar_t> allocator_type;
            typedef typename allocator_type::value_type value_type;
            typedef typename __pointer_type<value_type, allocator_type>::type pointer;
            typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
            typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
            typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
            typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
            typedef typename __size_type<allocator_type, difference_type>::type size_type;
            typedef typename __propagate_on_container_copy_assignment<allocator_type>::type propagate_on_container_copy_assignment;
            typedef typename __propagate_on_container_move_assignment<allocator_type>::type propagate_on_container_move_assignment;
            typedef typename __propagate_on_container_swap<allocator_type>::type propagate_on_container_swap;
            typedef typename __is_always_equal<allocator_type>::type is_always_equal;
            template <class _Tp> using rebind_alloc = typename __allocator_traits_rebind<allocator_type, _Tp>::type;
            template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
            static pointer allocate(allocator_type &__a, size_type __n) __attribute__((always_inline));
            static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) __attribute__((always_inline));
            static void deallocate(allocator_type &__a, pointer __p, size_type __n) noexcept __attribute__((always_inline));
            template <class _Tp, class ..._Args> static void construct(allocator_type &__a, _Tp *__p, _Args &&...__args) __attribute__((always_inline));
            template <class _Tp> static void destroy(allocator_type &__a, _Tp *__p) __attribute__((always_inline));
            static size_type max_size(const allocator_type &__a) noexcept __attribute__((always_inline));
            static allocator_type select_on_container_copy_construction(const allocator_type &__a) __attribute__((always_inline));
            template <class _Ptr> static void __construct_forward(allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__begin2) __attribute__((always_inline));
            template <class _Tp> static typename enable_if<(is_same<allocator_type, allocator<_Tp> >::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_forward(allocator_type &__a, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((always_inline));
            template <class _Iter, class _Ptr> static void __construct_range_forward(allocator_type &__a, _Iter __begin1, _Iter __end1, _Ptr &__begin2) __attribute__((always_inline));
            template <class _Tp> static typename enable_if<(is_same<allocator_type, allocator<_Tp> >::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_range_forward(allocator_type &__a, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((always_inline));
            template <class _Ptr> static void __construct_backward(allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__end2) __attribute__((always_inline));
            template <class _Tp> static typename enable_if<(is_same<allocator_type, allocator<_Tp> >::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_backward(allocator_type &__a, _Tp *__begin1, _Tp *__end1, _Tp *&__end2) __attribute__((always_inline));
        private:
            static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint, true_type) __attribute__((always_inline));
            static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer, false_type) __attribute__((always_inline));
            template <class _Tp, class ..._Args> static void __construct(true_type, allocator_type &__a, _Tp *__p, _Args &&...__args) __attribute__((always_inline));
            template <class _Tp, class ..._Args> static void __construct(false_type, allocator_type &, _Tp *__p, _Args &&...__args) __attribute__((always_inline));
            template <class _Tp> static void __destroy(true_type, allocator_type &__a, _Tp *__p) __attribute__((always_inline));
            template <class _Tp> static void __destroy(false_type, allocator_type &, _Tp *__p) __attribute__((always_inline));
            static size_type __max_size(true_type, const allocator_type &__a) __attribute__((always_inline));
            static size_type __max_size(false_type, const allocator_type &) __attribute__((always_inline));
            static allocator_type select_on_container_copy_construction(true_type, const allocator_type &__a) __attribute__((always_inline));
            static allocator_type select_on_container_copy_construction(false_type, const allocator_type &__a) __attribute__((always_inline));
        }
template <class _Alloc> struct __attribute__((type_visibility("default"))) allocator_traits {
            typedef _Alloc allocator_type;
            typedef typename allocator_type::value_type value_type;
            typedef typename __pointer_type<value_type, allocator_type>::type pointer;
            typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
            typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
            typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
            typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
            typedef typename __size_type<allocator_type, difference_type>::type size_type;
            typedef typename __propagate_on_container_copy_assignment<allocator_type>::type propagate_on_container_copy_assignment;
            typedef typename __propagate_on_container_move_assignment<allocator_type>::type propagate_on_container_move_assignment;
            typedef typename __propagate_on_container_swap<allocator_type>::type propagate_on_container_swap;
            typedef typename __is_always_equal<allocator_type>::type is_always_equal;
            template <class _Tp> using rebind_alloc = typename __allocator_traits_rebind<allocator_type, _Tp>::type;
            template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
            static pointer allocate(allocator_type &__a, size_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __a.allocate(__n);
            }


            static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return allocate(__a, __n, __hint, __has_allocate_hint<allocator_type, size_type, const_void_pointer>());
            }


            static void deallocate(allocator_type &__a, pointer __p, size_type __n) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __a.deallocate(__p, __n);
            }


            template <class _Tp, class ..._Args> static void construct(allocator_type &__a, _Tp *__p, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __construct(__has_construct<allocator_type, _Tp *, _Args...>(), __a, __p, std::__1::forward<_Args>(__args)...);
            }

;
            template <class _Tp> static void destroy(allocator_type &__a, _Tp *__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __destroy(__has_destroy<allocator_type, _Tp *>(), __a, __p);
            }

;
            static size_type max_size(const allocator_type &__a) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __max_size(__has_max_size<const allocator_type>(), __a);
            }


            static allocator_type select_on_container_copy_construction(const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return select_on_container_copy_construction(__has_select_on_container_copy_construction<const allocator_type>(), __a);
            }


            template <class _Ptr> static void __construct_forward(allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__begin2) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __begin1 != __end1; ++__begin1 , ++__begin2) 
                    construct(__a, std::__1::__to_raw_pointer(__begin2), std::__1::move_if_noexcept(*__begin1));
            }

;
            template <class _Tp> static typename enable_if<(is_same<allocator_type, allocator<_Tp> >::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_forward(allocator_type &__a, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ptrdiff_t _Np = __end1 - __begin1;
                if (_Np > 0) {
                    std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
                    __begin2 += _Np;
                }
            }

;
            template <class _Iter, class _Ptr> static void __construct_range_forward(allocator_type &__a, _Iter __begin1, _Iter __end1, _Ptr &__begin2) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __begin1 != __end1; ++__begin1 , (void)++__begin2) 
                    construct(__a, std::__1::__to_raw_pointer(__begin2), *__begin1);
            }

;
            template <class _Tp> static typename enable_if<(is_same<allocator_type, allocator<_Tp> >::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_range_forward(allocator_type &__a, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename remove_const<_Tp>::type _Vp;
                ptrdiff_t _Np = __end1 - __begin1;
                if (_Np > 0) {
                    std::__1::memcpy(const_cast<_Vp *>(__begin2), __begin1, _Np * sizeof(_Tp));
                    __begin2 += _Np;
                }
            }

;
            template <class _Ptr> static void __construct_backward(allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__end2) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                while (__end1 != __begin1)
                    {
                        construct(__a, std::__1::__to_raw_pointer(__end2 - 1), std::__1::move_if_noexcept(*--__end1));
                        --__end2;
                    }
            }

;
            template <class _Tp> static typename enable_if<(is_same<allocator_type, allocator<_Tp> >::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_backward(allocator_type &__a, _Tp *__begin1, _Tp *__end1, _Tp *&__end2) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ptrdiff_t _Np = __end1 - __begin1;
                __end2 -= _Np;
                if (_Np > 0)
                    std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
            }

;
        private:
            static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint, true_type) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __a.allocate(__n, __hint);
            }


            static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer, false_type) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __a.allocate(__n);
            }


            template <class _Tp, class ..._Args> static void __construct(true_type, allocator_type &__a, _Tp *__p, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __a.construct(__p, std::__1::forward<_Args>(__args)...);
            }

;
            template <class _Tp, class ..._Args> static void __construct(false_type, allocator_type &, _Tp *__p, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ::new ((void *)__p) _Tp((std::__1::forward<_Args>(__args)...));
            }

;
            template <class _Tp> static void __destroy(true_type, allocator_type &__a, _Tp *__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __a.destroy(__p);
            }

;
            template <class _Tp> static void __destroy(false_type, allocator_type &, _Tp *__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __p->~_Tp();
            }

;
            static size_type __max_size(true_type, const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __a.max_size();
            }


            static size_type __max_size(false_type, const allocator_type &) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return numeric_limits<size_type>::max();
            }


            static allocator_type select_on_container_copy_construction(true_type, const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __a.select_on_container_copy_construction();
            }


            static allocator_type select_on_container_copy_construction(false_type, const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __a;
            }


        };
        template <class _Traits, class _Tp> struct __rebind_alloc_helper {
            typedef typename _Traits::rebind_alloc<_Tp> type;
        };
        template <class _Tp = char> class allocator {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef char *pointer;
            typedef const char *const_pointer;
            typedef char &reference;
            typedef const char &const_reference;
            typedef char value_type;
            typedef true_type propagate_on_container_move_assignment;
            typedef true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() noexcept __attribute__((always_inline))             {
            }


            template <class _Up = char> allocator(const allocator<char> &) noexcept __attribute__((always_inline))template <class _Up> allocator(const allocator<_Up> &) noexcept __attribute__((always_inline));
            pointer address(reference __x) const noexcept __attribute__((always_inline));
            const_pointer address(const_reference __x) const noexcept __attribute__((always_inline));
            pointer allocate(size_type __n, allocator<void>::const_pointer) __attribute__((always_inline));
            void deallocate(pointer __p, size_type) noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            template <class _Up, class ..._Args> void construct(_Up *__p, _Args &&...__args) __attribute__((always_inline));
            void destroy(pointer __p) __attribute__((always_inline));
        }
template <class _Tp = wchar_t> class allocator {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef wchar_t *pointer;
            typedef const wchar_t *const_pointer;
            typedef wchar_t &reference;
            typedef const wchar_t &const_reference;
            typedef wchar_t value_type;
            typedef true_type propagate_on_container_move_assignment;
            typedef true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() noexcept __attribute__((always_inline));
            template <class _Up = wchar_t> allocator(const allocator<wchar_t> &) noexcept __attribute__((always_inline))template <class _Up> allocator(const allocator<_Up> &) noexcept __attribute__((always_inline));
            pointer address(reference __x) const noexcept __attribute__((always_inline));
            const_pointer address(const_reference __x) const noexcept __attribute__((always_inline));
            pointer allocate(size_type __n, allocator<void>::const_pointer) __attribute__((always_inline));
            void deallocate(pointer __p, size_type) noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            template <class _Up, class ..._Args> void construct(_Up *__p, _Args &&...__args) __attribute__((always_inline));
            void destroy(pointer __p) __attribute__((always_inline));
        }
template <class _Tp = void> class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef void *pointer;
            typedef const void *const_pointer;
            typedef void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        }
template <class _Tp = const void> class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef const void *pointer;
            typedef const void *const_pointer;
            typedef const void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        }
template <class _Tp = char16_t> class allocator
template <class _Tp = char32_t> class allocator
template <class _Tp> class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Tp *pointer;
            typedef const _Tp *const_pointer;
            typedef _Tp &reference;
            typedef const _Tp &const_reference;
            typedef _Tp value_type;
            typedef true_type propagate_on_container_move_assignment;
            typedef true_type is_always_equal;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
            allocator<_Tp>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Up> allocator<_Tp>(const allocator<_Up> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            pointer address(reference __x) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::addressof(__x);
            }


            const_pointer address(const_reference __x) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::addressof(__x);
            }


            pointer allocate(size_type __n, allocator<void>::const_pointer = 0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));
            }


            void deallocate(pointer __p, size_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::__deallocate((void *)__p);
            }


            size_type max_size() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return size_type(~0) / sizeof(_Tp);
            }


            template <class _Up, class ..._Args> void construct(_Up *__p, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ::new ((void *)__p) _Up((std::__1::forward<_Args>(__args)...));
            }

;
            void destroy(pointer __p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __p->~_Tp();
            }


        };
        class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef const _Tp *pointer;
            typedef const _Tp *const_pointer;
            typedef const _Tp &reference;
            typedef const _Tp &const_reference;
            typedef const _Tp value_type;
            typedef true_type propagate_on_container_move_assignment;
            typedef true_type is_always_equal;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
            allocator<const type-parameter-0-0>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Up> allocator<const type-parameter-0-0>(const allocator<_Up> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            const_pointer address(const_reference __x) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::addressof(__x);
            }


            pointer allocate(size_type __n, allocator<void>::const_pointer = 0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));
            }


            void deallocate(pointer __p, size_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::__deallocate((void *)__p);
            }


            size_type max_size() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return size_type(~0) / sizeof(_Tp);
            }


            template <class _Up, class ..._Args> void construct(_Up *__p, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ::new ((void *)__p) _Up((std::__1::forward<_Args>(__args)...));
            }

;
            void destroy(pointer __p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __p->~_Tp();
            }


        };
        template <class _Tp, class _Up> inline bool operator==(const allocator<_Tp> &, const allocator<_Up> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return true;
        }

;
        template <class _Tp, class _Up> inline bool operator!=(const allocator<_Tp> &, const allocator<_Up> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return false;
        }

;
        template <class _OutputIterator, class _Tp> class __attribute__((type_visibility("default"))) raw_storage_iterator : public iterator<std::__1::output_iterator_tag, _Tp, ptrdiff_t, _Tp *, raw_storage_iterator<_OutputIterator, _Tp> &> {
        private:
            _OutputIterator __x_;
        public:
            explicit raw_storage_iterator<_OutputIterator, _Tp>(_OutputIterator __x) : __x_(__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            raw_storage_iterator<_OutputIterator, _Tp> &operator*() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            raw_storage_iterator<_OutputIterator, _Tp> &operator=(const _Tp &__element) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ::new (&*this->__x_) _Tp((__element));
                return *this;
            }


            raw_storage_iterator<_OutputIterator, _Tp> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ++this->__x_;
                return *this;
            }


            raw_storage_iterator<_OutputIterator, _Tp> operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                raw_storage_iterator<_OutputIterator, _Tp> __t(*this);
                ++this->__x_;
                return __t;
            }


        };
        template <class _Tp> pair<_Tp *, ptrdiff_t> get_temporary_buffer(ptrdiff_t __n) noexcept         {
            pair<_Tp *, ptrdiff_t> __r(0, 0);
            const ptrdiff_t __m = (~ptrdiff_t(0) ^ ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1))) / sizeof(_Tp);
            if (__n > __m)
                __n = __m;
            while (__n > 0)
                {
                    __r.first = static_cast<_Tp *>(::operator new(__n * sizeof(_Tp), nothrow));
                    if (__r.first) {
                        __r.second = __n;
                        break;
                    }
                    __n /= 2;
                }
            return __r;
        }

;
        template <class _Tp> inline void return_temporary_buffer(_Tp *__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ::operator delete(__p);
        }

;
        template <class _Tp> struct auto_ptr_ref {
            _Tp *__ptr_;
        };
        template <class _Tp = void> class __attribute__((type_visibility("default"))) auto_ptr {
        public:
            typedef void element_type;
        }
template <class _Tp> class __attribute__((type_visibility("default"))) auto_ptr {
        private:
            _Tp *__ptr_;
        public:
            typedef _Tp element_type;
            explicit auto_ptr<_Tp>(_Tp *__p = 0) throw() : __ptr_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            auto_ptr<_Tp>(auto_ptr<_Tp> &__p) throw() : __ptr_(__p.release()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Up> auto_ptr<_Tp>(auto_ptr<_Up> &__p) throw() : __ptr_(__p.release()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            auto_ptr<_Tp> &operator=(auto_ptr<_Tp> &__p) throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->reset(__p.release());
                return *this;
            }


            template <class _Up> auto_ptr<_Tp> &operator=(auto_ptr<_Up> &__p) throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->reset(__p.release());
                return *this;
            }

;
            auto_ptr<_Tp> &operator=(auto_ptr_ref<_Tp> __p) throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->reset(__p.__ptr_);
                return *this;
            }


            ~auto_ptr<_Tp>() throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                delete this->__ptr_;
            }


            _Tp &operator*() const throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this->__ptr_;
            }


            _Tp *operator->() const throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_;
            }


            _Tp *get() const throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_;
            }


            _Tp *release() throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                _Tp *__t = this->__ptr_;
                this->__ptr_ = 0;
                return __t;
            }


            void reset(_Tp *__p = 0) throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (this->__ptr_ != __p)
                    delete this->__ptr_;
                this->__ptr_ = __p;
            }


            auto_ptr<_Tp>(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Up> operator auto_ptr_ref<_Up>() throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                auto_ptr_ref<_Up> __t;
                __t.__ptr_ = this->release();
                return __t;
            }

;
            template <class _Up> operator auto_ptr<_Up>() throw() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return auto_ptr<_Up>(this->release());
            }

;
        };
        class __attribute__((type_visibility("default"))) auto_ptr {
        public:
            typedef void element_type;
        };
        template <class _T1 = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, class _T2 = std::__1::allocator<char>, bool = false, bool = false, bool = true> struct __libcpp_compressed_pair_switch {
            enum  {
                value = 2
            };
        }
template <class _T1 = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, class _T2 = std::__1::allocator<wchar_t>, bool = false, bool = false, bool = true> struct __libcpp_compressed_pair_switch {
            enum  {
                value = 2
            };
        }
template <class _T1 = unsigned char *, class _T2 = void (*)(void *), bool = false, bool = false, bool = false> struct __libcpp_compressed_pair_switch {
            enum  {
                value = 0
            };
        }
template <class _T1 = char *, class _T2 = void (*)(void *), bool = false, bool = false, bool = false> struct __libcpp_compressed_pair_switch {
            enum  {
                value = 0
            };
        }
template <class _T1 = unsigned int *, class _T2 = void (*)(void *), bool = false, bool = false, bool = false> struct __libcpp_compressed_pair_switch {
            enum  {
                value = 0
            };
        }
template <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type, typename remove_cv<_T2>::type>::value, bool = is_empty<_T1>::value && !__libcpp_is_final<_T1>::value, bool = is_empty<_T2>::value && !__libcpp_is_final<_T2>::value> struct __libcpp_compressed_pair_switch;
        struct __libcpp_compressed_pair_switch {
            enum  {
                value = 0
            };
        };
        struct __libcpp_compressed_pair_switch {
            enum  {
                value = 1
            };
        };
        struct __libcpp_compressed_pair_switch {
            enum  {
                value = 2
            };
        };
        struct __libcpp_compressed_pair_switch {
            enum  {
                value = 3
            };
        };
        struct __libcpp_compressed_pair_switch {
            enum  {
                value = 1
            };
        };
        template <class _T1 = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, class _T2 = std::__1::allocator<char>, unsigned int = 2> class __libcpp_compressed_pair_imp : private std::__1::allocator<char> {
        private:
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep __first_;
        public:
            typedef std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep _T1_param;
            typedef std::__1::allocator<char> _T2_param;
            typedef typename remove_reference<__rep>::type &_T1_reference;
            typedef std::__1::allocator<char> &_T2_reference;
            typedef const typename remove_reference<__rep>::type &_T1_const_reference;
            typedef const std::__1::allocator<char> &_T2_const_reference;
            __libcpp_compressed_pair_imp() : std::__1::allocator<char>(), __first_() __attribute__((always_inline))             {
            }


            explicit __libcpp_compressed_pair_imp(_T1_param __t1) __attribute__((always_inline));
            explicit __libcpp_compressed_pair_imp(_T2_param __t2) __attribute__((always_inline));
            __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> __libcpp_compressed_pair_imp(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline))             {
                return this->__first_;
            }


            _T1_const_reference first() const noexcept __attribute__((always_inline))             {
                return this->__first_;
            }


            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__libcpp_compressed_pair_imp<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char>, 2> &__x) __attribute__((always_inline));
        }
template <class _T1 = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, class _T2 = std::__1::allocator<wchar_t>, unsigned int = 2> class __libcpp_compressed_pair_imp : private std::__1::allocator<wchar_t> {
        private:
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep __first_;
        public:
            typedef std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep _T1_param;
            typedef std::__1::allocator<wchar_t> _T2_param;
            typedef typename remove_reference<__rep>::type &_T1_reference;
            typedef std::__1::allocator<wchar_t> &_T2_reference;
            typedef const typename remove_reference<__rep>::type &_T1_const_reference;
            typedef const std::__1::allocator<wchar_t> &_T2_const_reference;
            __libcpp_compressed_pair_imp() __attribute__((always_inline));
            explicit __libcpp_compressed_pair_imp(_T1_param __t1) __attribute__((always_inline));
            explicit __libcpp_compressed_pair_imp(_T2_param __t2) __attribute__((always_inline));
            __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> __libcpp_compressed_pair_imp(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline))             {
                return this->__first_;
            }


            _T1_const_reference first() const noexcept __attribute__((always_inline));
            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__libcpp_compressed_pair_imp<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t>, 2> &__x) __attribute__((always_inline));
        }
template <class _T1 = unsigned char *, class _T2 = void (*)(void *), unsigned int = 0> class __libcpp_compressed_pair_imp {
        private:
            unsigned char *__first_;
            void (*__second_)(void *);
        public:
            typedef unsigned char *_T1_param;
            typedef void (*_T2_param)(void *);
            typedef typename remove_reference<unsigned char *>::type &_T1_reference;
            typedef typename remove_reference<void (*)(void *)>::type &_T2_reference;
            typedef const typename remove_reference<unsigned char *>::type &_T1_const_reference;
            typedef const typename remove_reference<void (*)(void *)>::type &_T2_const_reference;
            __libcpp_compressed_pair_imp() __attribute__((always_inline));
            explicit __libcpp_compressed_pair_imp(_T1_param __t1) __attribute__((always_inline));
            explicit __libcpp_compressed_pair_imp(_T2_param __t2) __attribute__((always_inline));
            __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> __libcpp_compressed_pair_imp(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline));
            _T1_const_reference first() const noexcept __attribute__((always_inline));
            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__libcpp_compressed_pair_imp<unsigned char *, void (*)(void *), 0> &__x) __attribute__((always_inline));
        }
template <class _T1 = char *, class _T2 = void (*)(void *), unsigned int = 0> class __libcpp_compressed_pair_imp {
        private:
            char *__first_;
            void (*__second_)(void *);
        public:
            typedef char *_T1_param;
            typedef void (*_T2_param)(void *);
            typedef typename remove_reference<char *>::type &_T1_reference;
            typedef typename remove_reference<void (*)(void *)>::type &_T2_reference;
            typedef const typename remove_reference<char *>::type &_T1_const_reference;
            typedef const typename remove_reference<void (*)(void *)>::type &_T2_const_reference;
            __libcpp_compressed_pair_imp() __attribute__((always_inline));
            explicit __libcpp_compressed_pair_imp(_T1_param __t1) __attribute__((always_inline));
            explicit __libcpp_compressed_pair_imp(_T2_param __t2) __attribute__((always_inline));
            __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> __libcpp_compressed_pair_imp(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline));
            _T1_const_reference first() const noexcept __attribute__((always_inline));
            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__libcpp_compressed_pair_imp<char *, void (*)(void *), 0> &__x) __attribute__((always_inline));
        }
template <class _T1 = unsigned int *, class _T2 = void (*)(void *), unsigned int = 0> class __libcpp_compressed_pair_imp {
        private:
            unsigned int *__first_;
            void (*__second_)(void *);
        public:
            typedef unsigned int *_T1_param;
            typedef void (*_T2_param)(void *);
            typedef typename remove_reference<unsigned int *>::type &_T1_reference;
            typedef typename remove_reference<void (*)(void *)>::type &_T2_reference;
            typedef const typename remove_reference<unsigned int *>::type &_T1_const_reference;
            typedef const typename remove_reference<void (*)(void *)>::type &_T2_const_reference;
            __libcpp_compressed_pair_imp() __attribute__((always_inline));
            explicit __libcpp_compressed_pair_imp(_T1_param __t1) __attribute__((always_inline));
            explicit __libcpp_compressed_pair_imp(_T2_param __t2) __attribute__((always_inline));
            __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> __libcpp_compressed_pair_imp(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline));
            _T1_const_reference first() const noexcept __attribute__((always_inline));
            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__libcpp_compressed_pair_imp<unsigned int *, void (*)(void *), 0> &__x) __attribute__((always_inline));
        }
template <class _T1, class _T2, unsigned int = __libcpp_compressed_pair_switch<_T1, _T2>::value> class __libcpp_compressed_pair_imp;
        class __libcpp_compressed_pair_imp {
        private:
            _T1 __first_;
            _T2 __second_;
        public:
            typedef _T1 _T1_param;
            typedef _T2 _T2_param;
            typedef typename remove_reference<_T1>::type &_T1_reference;
            typedef typename remove_reference<_T2>::type &_T2_reference;
            typedef const typename remove_reference<_T1>::type &_T1_const_reference;
            typedef const typename remove_reference<_T2>::type &_T2_const_reference;
            __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 0>() : __first_(), __second_() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 0>(_T1_param __t1) : __first_(std::__1::forward<_T1_param>(__t1)), __second_() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 0>(_T2_param __t2) : __first_(), __second_(std::__1::forward<_T2_param>(__t2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 0>(_T1_param __t1, _T2_param __t2) : __first_(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 0>(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) : __first_(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...), __second_(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            _T1_reference first() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__first_;
            }


            _T1_const_reference first() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__first_;
            }


            _T2_reference second() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__second_;
            }


            _T2_const_reference second() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__second_;
            }


            void swap(__libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 0> &__x) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::valueswap(__libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 0> &__x) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                using std::__1::swap;
                swap(this->__first_, __x.__first_);
                swap(this->__second_, __x.__second_);
            }


        };
        class __libcpp_compressed_pair_imp : private _T1 {
        private:
            _T2 __second_;
        public:
            typedef _T1 _T1_param;
            typedef _T2 _T2_param;
            typedef _T1 &_T1_reference;
            typedef typename remove_reference<_T2>::type &_T2_reference;
            typedef const _T1 &_T1_const_reference;
            typedef const typename remove_reference<_T2>::type &_T2_const_reference;
            __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 1>() : __second_() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 1>(_T1_param __t1) : _T1(std::__1::forward<_T1_param>(__t1)), __second_() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 1>(_T2_param __t2) : __second_(std::__1::forward<_T2_param>(__t2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 1>(_T1_param __t1, _T2_param __t2) : _T1(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 1>(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) : _T1(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...), __second_(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            _T1_reference first() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            _T1_const_reference first() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            _T2_reference second() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__second_;
            }


            _T2_const_reference second() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__second_;
            }


            void swap(__libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 1> &__x) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::valueswap(__libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 1> &__x) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                using std::__1::swap;
                swap(this->__second_, __x.__second_);
            }


        };
        class __libcpp_compressed_pair_imp : private _T2 {
        private:
            _T1 __first_;
        public:
            typedef _T1 _T1_param;
            typedef _T2 _T2_param;
            typedef typename remove_reference<_T1>::type &_T1_reference;
            typedef _T2 &_T2_reference;
            typedef const typename remove_reference<_T1>::type &_T1_const_reference;
            typedef const _T2 &_T2_const_reference;
            __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 2>() : __first_() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 2>(_T1_param __t1) : __first_(std::__1::forward<_T1_param>(__t1)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 2>(_T2_param __t2) : _T2(std::__1::forward<_T2_param>(__t2)), __first_() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 2>(_T1_param __t1, _T2_param __t2) noexcept(is_nothrow_move_constructible<_T1>::value && is_nothrow_move_constructible<_T2>::value__libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 2>(_T1_param __t1, _T2_param __t2) noexcept(is_nothrow_move_constructible<_T1>::value && is_nothrow_move_constructible<_T2>::value) : _T2(std::__1::forward<_T2_param>(__t2)), __first_(std::__1::forward<_T1_param>(__t1)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 2>(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) : _T2(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...), __first_(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            _T1_reference first() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__first_;
            }


            _T1_const_reference first() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__first_;
            }


            _T2_reference second() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            _T2_const_reference second() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            void swap(__libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 2> &__x) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::valueswap(__libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 2> &__x) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                using std::__1::swap;
                swap(this->__first_, __x.__first_);
            }


        };
        class __libcpp_compressed_pair_imp : private _T1, private _T2 {
        public:
            typedef _T1 _T1_param;
            typedef _T2 _T2_param;
            typedef _T1 &_T1_reference;
            typedef _T2 &_T2_reference;
            typedef const _T1 &_T1_const_reference;
            typedef const _T2 &_T2_const_reference;
            __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 3>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 3>(_T1_param __t1) : _T1(std::__1::forward<_T1_param>(__t1)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 3>(_T2_param __t2) : _T2(std::__1::forward<_T2_param>(__t2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 3>(_T1_param __t1, _T2_param __t2) : _T1(std::__1::forward<_T1_param>(__t1)), _T2(std::__1::forward<_T2_param>(__t2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class ..._Args1, class ..._Args2, size_t ..._I1, size_t ..._I2> __libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 3>(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args, __tuple_indices<_I1...>, __tuple_indices<_I2...>) : _T1(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...), _T2(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            _T1_reference first() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            _T1_const_reference first() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            _T2_reference second() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            _T2_const_reference second() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            void swap(__libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 3> &) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::valueswap(__libcpp_compressed_pair_imp<type-parameter-0-0, type-parameter-0-1, 3> &) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        template <class _T1 = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, class _T2 = std::__1::allocator<char>> class __compressed_pair : private __libcpp_compressed_pair_imp<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > {
            typedef __libcpp_compressed_pair_imp<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > base;
        public:
            typedef typename base::_T1_param _T1_param;
            typedef typename base::_T2_param _T2_param;
            typedef typename base::_T1_reference _T1_reference;
            typedef typename base::_T2_reference _T2_reference;
            typedef typename base::_T1_const_reference _T1_const_reference;
            typedef typename base::_T2_const_reference _T2_const_reference;
            __compressed_pair() : __libcpp_compressed_pair_imp<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >() __attribute__((always_inline))             {
            }


            explicit __compressed_pair(_T1_param __t1) __attribute__((always_inline));
            explicit __compressed_pair(_T2_param __t2) __attribute__((always_inline));
            __compressed_pair(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2> __compressed_pair(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline))             {
                return this->base::first();
            }


            _T1_const_reference first() const noexcept __attribute__((always_inline))             {
                return this->base::first();
            }


            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > &__x) __attribute__((always_inline));
        }
template <class _T1 = std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, class _T2 = std::__1::allocator<wchar_t>> class __compressed_pair : private __libcpp_compressed_pair_imp<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> > {
            typedef __libcpp_compressed_pair_imp<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> > base;
        public:
            typedef typename base::_T1_param _T1_param;
            typedef typename base::_T2_param _T2_param;
            typedef typename base::_T1_reference _T1_reference;
            typedef typename base::_T2_reference _T2_reference;
            typedef typename base::_T1_const_reference _T1_const_reference;
            typedef typename base::_T2_const_reference _T2_const_reference;
            __compressed_pair() __attribute__((always_inline));
            explicit __compressed_pair(_T1_param __t1) __attribute__((always_inline));
            explicit __compressed_pair(_T2_param __t2) __attribute__((always_inline));
            __compressed_pair(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2> __compressed_pair(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline))             {
                return this->base::first();
            }


            _T1_const_reference first() const noexcept __attribute__((always_inline));
            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> > &__x) __attribute__((always_inline));
        }
template <class _T1 = unsigned char *, class _T2 = void (*)(void *)> class __compressed_pair : private __libcpp_compressed_pair_imp<unsigned char *, void (*)(void *)> {
            typedef __libcpp_compressed_pair_imp<unsigned char *, void (*)(void *)> base;
        public:
            typedef typename base::_T1_param _T1_param;
            typedef typename base::_T2_param _T2_param;
            typedef typename base::_T1_reference _T1_reference;
            typedef typename base::_T2_reference _T2_reference;
            typedef typename base::_T1_const_reference _T1_const_reference;
            typedef typename base::_T2_const_reference _T2_const_reference;
            __compressed_pair() __attribute__((always_inline));
            explicit __compressed_pair(_T1_param __t1) __attribute__((always_inline));
            explicit __compressed_pair(_T2_param __t2) __attribute__((always_inline));
            __compressed_pair(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2> __compressed_pair(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline));
            _T1_const_reference first() const noexcept __attribute__((always_inline));
            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__compressed_pair<unsigned char *, void (*)(void *)> &__x) __attribute__((always_inline));
        }
template <class _T1 = char *, class _T2 = void (*)(void *)> class __compressed_pair : private __libcpp_compressed_pair_imp<char *, void (*)(void *)> {
            typedef __libcpp_compressed_pair_imp<char *, void (*)(void *)> base;
        public:
            typedef typename base::_T1_param _T1_param;
            typedef typename base::_T2_param _T2_param;
            typedef typename base::_T1_reference _T1_reference;
            typedef typename base::_T2_reference _T2_reference;
            typedef typename base::_T1_const_reference _T1_const_reference;
            typedef typename base::_T2_const_reference _T2_const_reference;
            __compressed_pair() __attribute__((always_inline));
            explicit __compressed_pair(_T1_param __t1) __attribute__((always_inline));
            explicit __compressed_pair(_T2_param __t2) __attribute__((always_inline));
            __compressed_pair(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2> __compressed_pair(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline));
            _T1_const_reference first() const noexcept __attribute__((always_inline));
            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__compressed_pair<char *, void (*)(void *)> &__x) __attribute__((always_inline));
        }
template <class _T1 = unsigned int *, class _T2 = void (*)(void *)> class __compressed_pair : private __libcpp_compressed_pair_imp<unsigned int *, void (*)(void *)> {
            typedef __libcpp_compressed_pair_imp<unsigned int *, void (*)(void *)> base;
        public:
            typedef typename base::_T1_param _T1_param;
            typedef typename base::_T2_param _T2_param;
            typedef typename base::_T1_reference _T1_reference;
            typedef typename base::_T2_reference _T2_reference;
            typedef typename base::_T1_const_reference _T1_const_reference;
            typedef typename base::_T2_const_reference _T2_const_reference;
            __compressed_pair() __attribute__((always_inline));
            explicit __compressed_pair(_T1_param __t1) __attribute__((always_inline));
            explicit __compressed_pair(_T2_param __t2) __attribute__((always_inline));
            __compressed_pair(_T1_param __t1, _T2_param __t2) __attribute__((always_inline));
            template <class ..._Args1, class ..._Args2> __compressed_pair(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) __attribute__((always_inline));
            _T1_reference first() noexcept __attribute__((always_inline));
            _T1_const_reference first() const noexcept __attribute__((always_inline));
            _T2_reference second() noexcept __attribute__((always_inline));
            _T2_const_reference second() const noexcept __attribute__((always_inline));
            void swap(std::__1::__compressed_pair<unsigned int *, void (*)(void *)> &__x) __attribute__((always_inline));
        }
template <class _T1, class _T2> class __compressed_pair : private __libcpp_compressed_pair_imp<_T1, _T2> {
            typedef __libcpp_compressed_pair_imp<_T1, _T2> base;
        public:
            typedef typename base::_T1_param _T1_param;
            typedef typename base::_T2_param _T2_param;
            typedef typename base::_T1_reference _T1_reference;
            typedef typename base::_T2_reference _T2_reference;
            typedef typename base::_T1_const_reference _T1_const_reference;
            typedef typename base::_T2_const_reference _T2_const_reference;
            __compressed_pair<_T1, _T2>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __compressed_pair<_T1, _T2>(_T1_param __t1) : base(std::__1::forward<_T1_param>(__t1)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __compressed_pair<_T1, _T2>(_T2_param __t2) : base(std::__1::forward<_T2_param>(__t2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            __compressed_pair<_T1, _T2>(_T1_param __t1, _T2_param __t2) : base(std::__1::forward<_T1_param>(__t1), std::__1::forward<_T2_param>(__t2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class ..._Args1, class ..._Args2> __compressed_pair<_T1, _T2>(std::__1::piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) : base(__pc, std::__1::move(__first_args), std::__1::move(__second_args), typename __make_tuple_indices<sizeof...(_Args1)>::type(), typename __make_tuple_indices<sizeof...(_Args2)>::type()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            _T1_reference first() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return base::first();
            }


            _T1_const_reference first() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return base::first();
            }


            _T2_reference second() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return base::second();
            }


            _T2_const_reference second() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return base::second();
            }


            void swap(__compressed_pair<_T1, _T2> &__x) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::valueswap(__compressed_pair<_T1, _T2> &__x) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                base::swap(__x);
            }


        };
        template <class _T1, class _T2> inline void swap(__compressed_pair<_T1, _T2> &__x, __compressed_pair<_T1, _T2> &__y) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::valueswap(__compressed_pair<_T1, _T2> &__x, __compressed_pair<_T1, _T2> &__y) noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __x.swap(__y);
        }

;
        template <class _Ptr1, class _Ptr2, bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type, typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type>::value> struct __same_or_less_cv_qualified_imp : is_convertible<_Ptr1, _Ptr2> {
        };
        struct __same_or_less_cv_qualified_imp : false_type {
        };
        template <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value || is_same<_Ptr1, _Ptr2>::value || __has_element_type<_Ptr1>::value> struct __same_or_less_cv_qualified : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {
        };
        struct __same_or_less_cv_qualified : false_type {
        };
        template <class _Tp = unsigned char> struct default_delete
template <class _Tp = char> struct default_delete
template <class _Tp = unsigned int> struct default_delete
template <class _Tp> struct __attribute__((type_visibility("default"))) default_delete {
            default_delete<_Tp>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
            template <class _Up> default_delete<_Tp>(const default_delete<_Up> &, typename enable_if<is_convertible<_Up *, _Tp *>::value>::type * = 0) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            void operator()(_Tp *__ptr) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(sizeof(_Tp) > 0, "default_delete can not delete incomplete type");
                static_assert(!is_void<_Tp>::value, "default_delete can not delete incomplete type");
                delete __ptr;
            }


        };
        struct __attribute__((type_visibility("default"))) default_delete {
        public:
            default_delete<type-parameter-0-0 []>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
            template <class _Up> default_delete<type-parameter-0-0 []>(const default_delete<_Up []> &, typename enable_if<__same_or_less_cv_qualified<_Up *, _Tp *>::value>::type * = 0) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Up> void operator()(_Up *__ptr, typename enable_if<__same_or_less_cv_qualified<_Up *, _Tp *>::value>::type * = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(sizeof(_Tp) > 0, "default_delete can not delete incomplete type");
                static_assert(!is_void<_Tp>::value, "default_delete can not delete incomplete type");
                delete [] __ptr;
            }

;
        };
        template <class _Tp = _xlocale, class _Dp = int (*)(_xlocale *)> class unique_ptr
template <class _Tp = unsigned char, class _Dp = void (*)(void *)> class unique_ptr {
        public:
            typedef unsigned char element_type;
            typedef void (*deleter_type)(void *);
            typedef typename __pointer_type<unsigned char, deleter_type>::type pointer;
        private:
            __compressed_pair<pointer, deleter_type> __ptr_;
            struct __nat;
            typedef typename remove_reference<deleter_type>::type &_Dp_reference;
            typedef const typename remove_reference<deleter_type>::type &_Dp_const_reference;
        public:
            constexpr unique_ptr() noexcept __attribute__((always_inline));
            constexpr unique_ptr(nullptr_t) noexcept __attribute__((always_inline));
            explicit unique_ptr(pointer __p) noexcept __attribute__((always_inline));
            unique_ptr(pointer __p, typename conditional<is_reference<deleter_type>::value, deleter_type, typename add_lvalue_reference<const deleter_type>::type>::type __d) noexcept __attribute__((always_inline));
            unique_ptr(pointer __p, typename remove_reference<deleter_type>::type &&__d) noexcept __attribute__((always_inline));
            unique_ptr(std::__1::unique_ptr<unsigned char, void (*)(void *)> &&__u) noexcept __attribute__((always_inline));
            template <class _Up, class _Ep> unique_ptr(unique_ptr<_Up, _Ep> &&__u, typename enable_if<!is_array<_Up>::value && is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_convertible<_Ep, deleter_type>::value && (!is_reference<deleter_type>::value || is_same<deleter_type, _Ep>::value), __nat>::type) noexcept __attribute__((always_inline));
            template <class _Up> unique_ptr(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, unsigned char *>::value && is_same<void (*)(void *), default_delete<unsigned char> >::value, __nat>::type) noexcept __attribute__((always_inline));
            std::__1::unique_ptr<unsigned char, void (*)(void *)> &operator=(std::__1::unique_ptr<unsigned char, void (*)(void *)> &&__u) noexcept __attribute__((always_inline));
            template <class _Up, class _Ep> typename enable_if<!is_array<_Up>::value && is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_assignable<deleter_type &, _Ep &&>::value, unique_ptr<unsigned char, void (*)(void *)> &>::type operator=(unique_ptr<_Up, _Ep> &&__u) noexcept __attribute__((always_inline));
            ~std::__1::unique_ptr<unsigned char, void (*)(void *)>() __attribute__((always_inline));
            std::__1::unique_ptr<unsigned char, void (*)(void *)> &operator=(nullptr_t) noexcept __attribute__((always_inline));
            typename add_lvalue_reference<unsigned char>::type operator*() const __attribute__((always_inline));
            pointer operator->() const noexcept __attribute__((always_inline));
            pointer get() const noexcept __attribute__((always_inline));
            _Dp_reference get_deleter() noexcept __attribute__((always_inline));
            _Dp_const_reference get_deleter() const noexcept __attribute__((always_inline));
            explicit operator bool() const noexcept __attribute__((always_inline));
            pointer release() noexcept __attribute__((always_inline));
            void reset(pointer __p) noexcept __attribute__((always_inline));
            void swap(std::__1::unique_ptr<unsigned char, void (*)(void *)> &__u) noexcept __attribute__((always_inline));
        }
template <class _Tp = char, class _Dp = void (*)(void *)> class unique_ptr {
        public:
            typedef char element_type;
            typedef void (*deleter_type)(void *);
            typedef typename __pointer_type<char, deleter_type>::type pointer;
        private:
            __compressed_pair<pointer, deleter_type> __ptr_;
            struct __nat;
            typedef typename remove_reference<deleter_type>::type &_Dp_reference;
            typedef const typename remove_reference<deleter_type>::type &_Dp_const_reference;
        public:
            constexpr unique_ptr() noexcept __attribute__((always_inline));
            constexpr unique_ptr(nullptr_t) noexcept __attribute__((always_inline));
            explicit unique_ptr(pointer __p) noexcept __attribute__((always_inline));
            unique_ptr(pointer __p, typename conditional<is_reference<deleter_type>::value, deleter_type, typename add_lvalue_reference<const deleter_type>::type>::type __d) noexcept __attribute__((always_inline));
            unique_ptr(pointer __p, typename remove_reference<deleter_type>::type &&__d) noexcept __attribute__((always_inline));
            unique_ptr(std::__1::unique_ptr<char, void (*)(void *)> &&__u) noexcept __attribute__((always_inline));
            template <class _Up, class _Ep> unique_ptr(unique_ptr<_Up, _Ep> &&__u, typename enable_if<!is_array<_Up>::value && is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_convertible<_Ep, deleter_type>::value && (!is_reference<deleter_type>::value || is_same<deleter_type, _Ep>::value), __nat>::type) noexcept __attribute__((always_inline));
            template <class _Up> unique_ptr(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, char *>::value && is_same<void (*)(void *), default_delete<char> >::value, __nat>::type) noexcept __attribute__((always_inline));
            std::__1::unique_ptr<char, void (*)(void *)> &operator=(std::__1::unique_ptr<char, void (*)(void *)> &&__u) noexcept __attribute__((always_inline));
            template <class _Up, class _Ep> typename enable_if<!is_array<_Up>::value && is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_assignable<deleter_type &, _Ep &&>::value, unique_ptr<char, void (*)(void *)> &>::type operator=(unique_ptr<_Up, _Ep> &&__u) noexcept __attribute__((always_inline));
            ~std::__1::unique_ptr<char, void (*)(void *)>() __attribute__((always_inline));
            std::__1::unique_ptr<char, void (*)(void *)> &operator=(nullptr_t) noexcept __attribute__((always_inline));
            typename add_lvalue_reference<char>::type operator*() const __attribute__((always_inline));
            pointer operator->() const noexcept __attribute__((always_inline));
            pointer get() const noexcept __attribute__((always_inline));
            _Dp_reference get_deleter() noexcept __attribute__((always_inline));
            _Dp_const_reference get_deleter() const noexcept __attribute__((always_inline));
            explicit operator bool() const noexcept __attribute__((always_inline));
            pointer release() noexcept __attribute__((always_inline));
            void reset(pointer __p) noexcept __attribute__((always_inline));
            void swap(std::__1::unique_ptr<char, void (*)(void *)> &__u) noexcept __attribute__((always_inline));
        }
template <class _Tp = unsigned int, class _Dp = void (*)(void *)> class unique_ptr {
        public:
            typedef unsigned int element_type;
            typedef void (*deleter_type)(void *);
            typedef typename __pointer_type<unsigned int, deleter_type>::type pointer;
        private:
            __compressed_pair<pointer, deleter_type> __ptr_;
            struct __nat;
            typedef typename remove_reference<deleter_type>::type &_Dp_reference;
            typedef const typename remove_reference<deleter_type>::type &_Dp_const_reference;
        public:
            constexpr unique_ptr() noexcept __attribute__((always_inline));
            constexpr unique_ptr(nullptr_t) noexcept __attribute__((always_inline));
            explicit unique_ptr(pointer __p) noexcept __attribute__((always_inline));
            unique_ptr(pointer __p, typename conditional<is_reference<deleter_type>::value, deleter_type, typename add_lvalue_reference<const deleter_type>::type>::type __d) noexcept __attribute__((always_inline));
            unique_ptr(pointer __p, typename remove_reference<deleter_type>::type &&__d) noexcept __attribute__((always_inline));
            unique_ptr(std::__1::unique_ptr<unsigned int, void (*)(void *)> &&__u) noexcept __attribute__((always_inline));
            template <class _Up, class _Ep> unique_ptr(unique_ptr<_Up, _Ep> &&__u, typename enable_if<!is_array<_Up>::value && is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_convertible<_Ep, deleter_type>::value && (!is_reference<deleter_type>::value || is_same<deleter_type, _Ep>::value), __nat>::type) noexcept __attribute__((always_inline));
            template <class _Up> unique_ptr(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, unsigned int *>::value && is_same<void (*)(void *), default_delete<unsigned int> >::value, __nat>::type) noexcept __attribute__((always_inline));
            std::__1::unique_ptr<unsigned int, void (*)(void *)> &operator=(std::__1::unique_ptr<unsigned int, void (*)(void *)> &&__u) noexcept __attribute__((always_inline));
            template <class _Up, class _Ep> typename enable_if<!is_array<_Up>::value && is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_assignable<deleter_type &, _Ep &&>::value, unique_ptr<unsigned int, void (*)(void *)> &>::type operator=(unique_ptr<_Up, _Ep> &&__u) noexcept __attribute__((always_inline));
            ~std::__1::unique_ptr<unsigned int, void (*)(void *)>() __attribute__((always_inline));
            std::__1::unique_ptr<unsigned int, void (*)(void *)> &operator=(nullptr_t) noexcept __attribute__((always_inline));
            typename add_lvalue_reference<unsigned int>::type operator*() const __attribute__((always_inline));
            pointer operator->() const noexcept __attribute__((always_inline));
            pointer get() const noexcept __attribute__((always_inline));
            _Dp_reference get_deleter() noexcept __attribute__((always_inline));
            _Dp_const_reference get_deleter() const noexcept __attribute__((always_inline));
            explicit operator bool() const noexcept __attribute__((always_inline));
            pointer release() noexcept __attribute__((always_inline));
            void reset(pointer __p) noexcept __attribute__((always_inline));
            void swap(std::__1::unique_ptr<unsigned int, void (*)(void *)> &__u) noexcept __attribute__((always_inline));
        }
template <class _Tp = wchar_t, class _Dp = void (*)(void *)> class unique_ptr
template <class _Tp, class _Dp = default_delete<_Tp>> class __attribute__((type_visibility("default"))) unique_ptr {
        public:
            typedef _Tp element_type;
            typedef _Dp deleter_type;
            typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
        private:
            __compressed_pair<pointer, deleter_type> __ptr_;
            struct __nat {
                int __for_bool_;
            };
            typedef typename remove_reference<deleter_type>::type &_Dp_reference;
            typedef const typename remove_reference<deleter_type>::type &_Dp_const_reference;
        public:
            constexpr unique_ptr<_Tp, _Dp>() noexcept : __ptr_(pointer()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_pointer<deleter_type>::value, "unique_ptr constructed with null function pointer deleter");
            }


            constexpr unique_ptr<_Tp, _Dp>(nullptr_t) noexcept : __ptr_(pointer()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_pointer<deleter_type>::value, "unique_ptr constructed with null function pointer deleter");
            }


            explicit unique_ptr<_Tp, _Dp>(pointer __p) noexcept : __ptr_(std::__1::move(__p)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_pointer<deleter_type>::value, "unique_ptr constructed with null function pointer deleter");
            }


            unique_ptr<_Tp, _Dp>(pointer __p, typename conditional<is_reference<deleter_type>::value, deleter_type, typename add_lvalue_reference<const deleter_type>::type>::type __d) noexcept : __ptr_(__p, __d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            unique_ptr<_Tp, _Dp>(pointer __p, typename remove_reference<deleter_type>::type &&__d) noexcept : __ptr_(__p, std::__1::move(__d)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
            }


            unique_ptr<_Tp, _Dp>(unique_ptr<_Tp, _Dp> &&__u) noexcept : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Up, class _Ep> unique_ptr<_Tp, _Dp>(unique_ptr<_Up, _Ep> &&__u, typename enable_if<!is_array<_Up>::value && is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_convertible<_Ep, deleter_type>::value && (!is_reference<deleter_type>::value || is_same<deleter_type, _Ep>::value), __nat>::type = std::__1::unique_ptr::__nat()) noexcept : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Up> unique_ptr<_Tp, _Dp>(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, _Tp *>::value && is_same<_Dp, default_delete<_Tp> >::value, __nat>::type = std::__1::unique_ptr::__nat()) noexcept : __ptr_(__p.release()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            unique_ptr<_Tp, _Dp> &operator=(unique_ptr<_Tp, _Dp> &&__u) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->reset(__u.release());
                this->__ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
                return *this;
            }


            template <class _Up, class _Ep> typename enable_if<!is_array<_Up>::value && is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_assignable<deleter_type &, _Ep &&>::value, unique_ptr<_Tp, _Dp> &>::type operator=(unique_ptr<_Up, _Ep> &&__u) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->reset(__u.release());
                this->__ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
                return *this;
            }

;
            ~unique_ptr<_Tp, _Dp>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->reset();
            }


            unique_ptr<_Tp, _Dp> &operator=(nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->reset();
                return *this;
            }


            typename add_lvalue_reference<_Tp>::type operator*() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this->__ptr_.first();
            }


            pointer operator->() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.first();
            }


            pointer get() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.first();
            }


            _Dp_reference get_deleter() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.second();
            }


            _Dp_const_reference get_deleter() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.second();
            }


            explicit operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.first() != nullptr;
            }


            pointer release() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                pointer __t = this->__ptr_.first();
                this->__ptr_.first() = pointer();
                return __t;
            }


            void reset(pointer __p = pointer()) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                pointer __tmp = this->__ptr_.first();
                this->__ptr_.first() = __p;
                if (__tmp)
                    this->__ptr_.second()(__tmp);
            }


            void swap(unique_ptr<_Tp, _Dp> &__u) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__ptr_.swap(__u.__ptr_);
            }


        };
        class __attribute__((type_visibility("default"))) unique_ptr {
        public:
            typedef _Tp element_type;
            typedef _Dp deleter_type;
            typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
        private:
            __compressed_pair<pointer, deleter_type> __ptr_;
            struct __nat {
                int __for_bool_;
            };
            typedef typename remove_reference<deleter_type>::type &_Dp_reference;
            typedef const typename remove_reference<deleter_type>::type &_Dp_const_reference;
        public:
            constexpr unique_ptr<type-parameter-0-0 [], type-parameter-0-1>() noexcept : __ptr_(pointer()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_pointer<deleter_type>::value, "unique_ptr constructed with null function pointer deleter");
            }


            constexpr unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(nullptr_t) noexcept : __ptr_(pointer()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_pointer<deleter_type>::value, "unique_ptr constructed with null function pointer deleter");
            }


            template <class _Pp> explicit unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Pp __p, typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::__nat()) noexcept : __ptr_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_pointer<deleter_type>::value, "unique_ptr constructed with null function pointer deleter");
            }

;
            template <class _Pp> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Pp __p, typename conditional<is_reference<deleter_type>::value, deleter_type, typename add_lvalue_reference<const deleter_type>::type>::type __d, typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::__nat()) noexcept : __ptr_(__p, __d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(nullptr_t, typename conditional<is_reference<deleter_type>::value, deleter_type, typename add_lvalue_reference<const deleter_type>::type>::type __d) noexcept : __ptr_(pointer(), __d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Pp> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Pp __p, typename remove_reference<deleter_type>::type &&__d, typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::__nat()) noexcept : __ptr_(__p, std::__1::move(__d)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
            }

;
            unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(nullptr_t, typename remove_reference<deleter_type>::type &&__d) noexcept : __ptr_(pointer(), std::__1::move(__d)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
            }


            unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &&__u) noexcept : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &&__u) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                reset(__u.release());
                this->__ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
                return *this;
            }


            template <class _Up, class _Ep> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(unique_ptr<_Up, _Ep> &&__u, typename enable_if<is_array<_Up>::value && __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_convertible<_Ep, deleter_type>::value && (!is_reference<deleter_type>::value || is_same<deleter_type, _Ep>::value), __nat>::type = std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::__nat()) noexcept : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Up, class _Ep> typename enable_if<is_array<_Up>::value && __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value && is_assignable<deleter_type &, _Ep &&>::value, unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &>::type operator=(unique_ptr<_Up, _Ep> &&__u) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                reset(__u.release());
                this->__ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
                return *this;
            }

;
            ~unique_ptr<type-parameter-0-0 [], type-parameter-0-1>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                reset();
            }


            unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                reset();
                return *this;
            }


            typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.first()[__i];
            }


            pointer get() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.first();
            }


            _Dp_reference get_deleter() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.second();
            }


            _Dp_const_reference get_deleter() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.second();
            }


            explicit operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_.first() != nullptr;
            }


            pointer release() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                pointer __t = this->__ptr_.first();
                this->__ptr_.first() = pointer();
                return __t;
            }


            template <class _Pp> typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type reset(_Pp __p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                pointer __tmp = this->__ptr_.first();
                this->__ptr_.first() = __p;
                if (__tmp)
                    this->__ptr_.second()(__tmp);
            }

;
            void reset(nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                pointer __tmp = this->__ptr_.first();
                this->__ptr_.first() = nullptr;
                if (__tmp)
                    this->__ptr_.second()(__tmp);
            }


            void reset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                pointer __tmp = this->__ptr_.first();
                this->__ptr_.first() = nullptr;
                if (__tmp)
                    this->__ptr_.second()(__tmp);
            }


            void swap(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &__u) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__ptr_.swap(__u.__ptr_);
            }


        private:
        };
        template <class _Tp, class _Dp> inline void swap(unique_ptr<_Tp, _Dp> &__x, unique_ptr<_Tp, _Dp> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __x.swap(__y);
        }

;
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator==(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.get() == __y.get();
        }

;
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator!=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }

;
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator<(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename unique_ptr<_T1, _D1>::pointer _P1;
            typedef typename unique_ptr<_T2, _D2>::pointer _P2;
            typedef typename common_type<_P1, _P2>::type _Vp;
            return less<_Vp>()(__x.get(), __y.get());
        }

;
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator>(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __y < __x;
        }

;
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator<=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__y < __x);
        }

;
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator>=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < __y);
        }

;
        template <class _T1, class _D1> inline bool operator==(const unique_ptr<_T1, _D1> &__x, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !__x;
        }

;
        template <class _T1, class _D1> inline bool operator==(nullptr_t, const unique_ptr<_T1, _D1> &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !__x;
        }

;
        template <class _T1, class _D1> inline bool operator!=(const unique_ptr<_T1, _D1> &__x, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<bool>(__x);
        }

;
        template <class _T1, class _D1> inline bool operator!=(nullptr_t, const unique_ptr<_T1, _D1> &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<bool>(__x);
        }

;
        template <class _T1, class _D1> inline bool operator<(const unique_ptr<_T1, _D1> &__x, nullptr_t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename unique_ptr<_T1, _D1>::pointer _P1;
            return less<_P1>()(__x.get(), nullptr);
        }

;
        template <class _T1, class _D1> inline bool operator<(nullptr_t, const unique_ptr<_T1, _D1> &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename unique_ptr<_T1, _D1>::pointer _P1;
            return less<_P1>()(nullptr, __x.get());
        }

;
        template <class _T1, class _D1> inline bool operator>(const unique_ptr<_T1, _D1> &__x, nullptr_t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return nullptr < __x;
        }

;
        template <class _T1, class _D1> inline bool operator>(nullptr_t, const unique_ptr<_T1, _D1> &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x < nullptr;
        }

;
        template <class _T1, class _D1> inline bool operator<=(const unique_ptr<_T1, _D1> &__x, nullptr_t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(nullptr < __x);
        }

;
        template <class _T1, class _D1> inline bool operator<=(nullptr_t, const unique_ptr<_T1, _D1> &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < nullptr);
        }

;
        template <class _T1, class _D1> inline bool operator>=(const unique_ptr<_T1, _D1> &__x, nullptr_t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < nullptr);
        }

;
        template <class _T1, class _D1> inline bool operator>=(nullptr_t, const unique_ptr<_T1, _D1> &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(nullptr < __x);
        }

;
        template <class _Tp = std::__1::error_code> struct __attribute__((type_visibility("default"))) hash : public unary_function<std::__1::error_code, size_t> {
            size_t operator()(const std::__1::error_code &__ec) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__ec.value());
            }


        }
template <class _Tp = bool> struct __attribute__((type_visibility("default"))) hash : public unary_function<bool, size_t> {
            size_t operator()(bool __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = char> struct __attribute__((type_visibility("default"))) hash : public unary_function<char, size_t> {
            size_t operator()(char __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = signed char> struct __attribute__((type_visibility("default"))) hash : public unary_function<signed char, size_t> {
            size_t operator()(signed char __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = unsigned char> struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned char, size_t> {
            size_t operator()(unsigned char __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = char16_t> struct __attribute__((type_visibility("default"))) hash : public unary_function<char16_t, size_t> {
            size_t operator()(char16_t __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = char32_t> struct __attribute__((type_visibility("default"))) hash : public unary_function<char32_t, size_t> {
            size_t operator()(char32_t __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = wchar_t> struct __attribute__((type_visibility("default"))) hash : public unary_function<wchar_t, size_t> {
            size_t operator()(wchar_t __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = short> struct __attribute__((type_visibility("default"))) hash : public unary_function<short, size_t> {
            size_t operator()(short __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = unsigned short> struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned short, size_t> {
            size_t operator()(unsigned short __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = int> struct __attribute__((type_visibility("default"))) hash : public unary_function<int, size_t> {
            size_t operator()(int __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = unsigned int> struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned int, size_t> {
            size_t operator()(unsigned int __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = long> struct __attribute__((type_visibility("default"))) hash : public unary_function<long, size_t> {
            size_t operator()(long __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = unsigned long> struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned long, size_t> {
            size_t operator()(unsigned long __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        }
template <class _Tp = long long> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<long long> {
        }
template <class _Tp = unsigned long long> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<unsigned long long> {
        }
template <class _Tp = float> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<float> {
            size_t operator()(float __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__v == 0)
                    return 0;
                return this->__scalar_hash<float>::operator()(__v);
            }


        }
template <class _Tp = double> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<double> {
            size_t operator()(double __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__v == 0)
                    return 0;
                return this->__scalar_hash<double>::operator()(__v);
            }


        }
template <class _Tp = long double> struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<long double> {
            size_t operator()(long double __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__v == 0)
                    return 0;
                union {
                    long double __t;
                    struct {
                        size_t __a;
                        size_t __b;
                    } __s;
                } __u;
                __u.__s.__a = 0;
                __u.__s.__b = 0;
                __u.__t = __v;
                return __u.__s.__a ^ __u.__s.__b;
            }


        }
template <class _Tp> struct __attribute__((type_visibility("default"))) hash;
        template <class _Size = unsigned int> inline unsigned int __loadword(const void *__p) __attribute__((always_inline))template <class _Size> inline _Size __loadword(const void *__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            _Size __r;
            std::memcpy(&__r, __p, sizeof (__r));
            return __r;
        }

;
        template <class _Size = unsigned long, size_t = 64> struct __murmur2_or_cityhash {
            unsigned long operator()(const void *__key, unsigned long __len);
        private:
            static const unsigned long __k0 = 14097894508562428199ULL;
            static const unsigned long __k1 = 13011662864482103923ULL;
            static const unsigned long __k2 = 11160318154034397263ULL;
            static const unsigned long __k3 = 14504361325974414679ULL;
            static unsigned long __rotate(unsigned long __val, int __shift);
            static unsigned long __rotate_by_at_least_1(unsigned long __val, int __shift);
            static unsigned long __shift_mix(unsigned long __val);
            static unsigned long __hash_len_16(unsigned long __u, unsigned long __v);
            static unsigned long __hash_len_0_to_16(const char *__s, unsigned long __len);
            static unsigned long __hash_len_17_to_32(const char *__s, unsigned long __len);
            static pair<unsigned long, unsigned long> __weak_hash_len_32_with_seeds(unsigned long __w, unsigned long __x, unsigned long __y, unsigned long __z, unsigned long __a, unsigned long __b);
            static pair<unsigned long, unsigned long> __weak_hash_len_32_with_seeds(const char *__s, unsigned long __a, unsigned long __b);
            static unsigned long __hash_len_33_to_64(const char *__s, size_t __len);
        }
template <class _Size, size_t = sizeof(_Size) * 8> struct __murmur2_or_cityhash;
        struct __murmur2_or_cityhash {
            _Size operator()(const void *__key, _Size __len);
        };
        _Size operator()(const void *__key, _Size __len)         {
            const _Size __m = 1540483477;
            const _Size __r = 24;
            _Size __h = __len;
            const unsigned char *__data = static_cast<const unsigned char *>(__key);
            for (; __len >= 4; __data += 4 , __len -= 4) {
                _Size __k = __loadword<_Size>(__data);
                __k *= __m;
                __k ^= __k >> __r;
                __k *= __m;
                __h *= __m;
                __h ^= __k;
            }
            switch (__len) {
              case 3:
                __h ^= __data[2] << 16;
              case 2:
                __h ^= __data[1] << 8;
              case 1:
                __h ^= __data[0];
                __h *= __m;
            }
            __h ^= __h >> 13;
            __h *= __m;
            __h ^= __h >> 15;
            return __h;
        }


        struct __murmur2_or_cityhash {
            _Size operator()(const void *__key, _Size __len);
        private:
            static const _Size __k0 = 14097894508562428199ULL;
            static const _Size __k1 = 13011662864482103923ULL;
            static const _Size __k2 = 11160318154034397263ULL;
            static const _Size __k3 = 14504361325974414679ULL;
            static _Size __rotate(_Size __val, int __shift)             {
                return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
            }


            static _Size __rotate_by_at_least_1(_Size __val, int __shift)             {
                return (__val >> __shift) | (__val << (64 - __shift));
            }


            static _Size __shift_mix(_Size __val)             {
                return __val ^ (__val >> 47);
            }


            static _Size __hash_len_16(_Size __u, _Size __v)             {
                const _Size __mul = 11376068507788127593ULL;
                _Size __a = (__u ^ __v) * __mul;
                __a ^= (__a >> 47);
                _Size __b = (__v ^ __a) * __mul;
                __b ^= (__b >> 47);
                __b *= __mul;
                return __b;
            }


            static _Size __hash_len_0_to_16(const char *__s, _Size __len)             {
                if (__len > 8) {
                    const _Size __a = __loadword<_Size>(__s);
                    const _Size __b = __loadword<_Size>(__s + __len - 8);
                    return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
                }
                if (__len >= 4) {
                    const uint32_t __a = __loadword<uint32_t>(__s);
                    const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
                    return __hash_len_16(__len + (__a << 3), __b);
                }
                if (__len > 0) {
                    const unsigned char __a = __s[0];
                    const unsigned char __b = __s[__len >> 1];
                    const unsigned char __c = __s[__len - 1];
                    const uint32_t __y = static_cast<uint32_t>(__a) + (static_cast<uint32_t>(__b) << 8);
                    const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
                    return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
                }
                return __k2;
            }


            static _Size __hash_len_17_to_32(const char *__s, _Size __len)             {
                const _Size __a = __loadword<_Size>(__s) * __k1;
                const _Size __b = __loadword<_Size>(__s + 8);
                const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
                const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
                return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d, __a + __rotate(__b ^ __k3, 20) - __c + __len);
            }


            static pair<_Size, _Size> __weak_hash_len_32_with_seeds(_Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)             {
                __a += __w;
                __b = __rotate(__b + __a + __z, 21);
                const _Size __c = __a;
                __a += __x;
                __a += __y;
                __b += __rotate(__a, 44);
                return pair<_Size, _Size>(__a + __z, __b + __c);
            }


            static pair<_Size, _Size> __weak_hash_len_32_with_seeds(const char *__s, _Size __a, _Size __b)             {
                return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s), __loadword<_Size>(__s + 8), __loadword<_Size>(__s + 16), __loadword<_Size>(__s + 24), __a, __b);
            }


            static _Size __hash_len_33_to_64(const char *__s, size_t __len)             {
                _Size __z = __loadword<_Size>(__s + 24);
                _Size __a = __loadword<_Size>(__s) + (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
                _Size __b = __rotate(__a + __z, 52);
                _Size __c = __rotate(__a, 37);
                __a += __loadword<_Size>(__s + 8);
                __c += __rotate(__a, 7);
                __a += __loadword<_Size>(__s + 16);
                _Size __vf = __a + __z;
                _Size __vs = __b + __rotate(__a, 31) + __c;
                __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
                __z += __loadword<_Size>(__s + __len - 8);
                __b = __rotate(__a + __z, 52);
                __c = __rotate(__a, 37);
                __a += __loadword<_Size>(__s + __len - 24);
                __c += __rotate(__a, 7);
                __a += __loadword<_Size>(__s + __len - 16);
                _Size __wf = __a + __z;
                _Size __ws = __b + __rotate(__a, 31) + __c;
                _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
                return __shift_mix(__r * __k0 + __vs) * __k2;
            }


        };
        _Size operator()(const void *__key, _Size __len)         {
            const char *__s = static_cast<const char *>(__key);
            if (__len <= 32) {
                if (__len <= 16) {
                    return __hash_len_0_to_16(__s, __len);
                } else {
                    return __hash_len_17_to_32(__s, __len);
                }
            } else if (__len <= 64) {
                return __hash_len_33_to_64(__s, __len);
            }
            _Size __x = __loadword<_Size>(__s + __len - 40);
            _Size __y = __loadword<_Size>(__s + __len - 16) + __loadword<_Size>(__s + __len - 56);
            _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len, __loadword<_Size>(__s + __len - 24));
            pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
            pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
            __x = __x * __k1 + __loadword<_Size>(__s);
            __len = (__len - 1) & ~static_cast<_Size>(63);
            do {
                __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
                __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
                __x ^= __w.second;
                __y += __v.first + __loadword<_Size>(__s + 40);
                __z = __rotate(__z + __w.first, 33) * __k1;
                __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
                __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second, __y + __loadword<_Size>(__s + 16));
                std::swap(__z, __x);
                __s += 64;
                __len -= 64;
            } while (__len != 0);
            return __hash_len_16(__hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z, __hash_len_16(__v.second, __w.second) + __x);
        }


        template <class _Tp = long long, size_t = 1> struct __scalar_hash : public unary_function<long long, size_t> {
            size_t operator()(long long __v) const noexcept __attribute__((always_inline));
        }
template <class _Tp = unsigned long long, size_t = 1> struct __scalar_hash : public unary_function<unsigned long long, size_t> {
            size_t operator()(unsigned long long __v) const noexcept __attribute__((always_inline));
        }
template <class _Tp = float, size_t = 0> struct __scalar_hash : public unary_function<float, size_t> {
            size_t operator()(float __v) const noexcept __attribute__((always_inline))             {
                union {
                    float __t;
                    size_t __a;
                } __u;
                __u.__a = 0;
                __u.__t = __v;
                return __u.__a;
            }


        }
template <class _Tp = double, size_t = 1> struct __scalar_hash : public unary_function<double, size_t> {
            size_t operator()(double __v) const noexcept __attribute__((always_inline))             {
                union {
                    double __t;
                    size_t __a;
                } __u;
                __u.__t = __v;
                return __u.__a;
            }


        }
template <class _Tp = long double, size_t = 2> struct __scalar_hash : public unary_function<long double, size_t> {
            size_t operator()(long double __v) const noexcept __attribute__((always_inline));
        }
template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)> struct __scalar_hash;
        struct __scalar_hash : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                union {
                    _Tp __t;
                    size_t __a;
                } __u;
                __u.__a = 0;
                __u.__t = __v;
                return __u.__a;
            }


        };
        struct __scalar_hash : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                union {
                    _Tp __t;
                    size_t __a;
                } __u;
                __u.__t = __v;
                return __u.__a;
            }


        };
        struct __scalar_hash : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                union {
                    _Tp __t;
                    struct {
                        size_t __a;
                        size_t __b;
                    } __s;
                } __u;
                __u.__t = __v;
                return __murmur2_or_cityhash<size_t>()(&__u, sizeof (__u));
            }


        };
        struct __scalar_hash : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                union {
                    _Tp __t;
                    struct {
                        size_t __a;
                        size_t __b;
                        size_t __c;
                    } __s;
                } __u;
                __u.__t = __v;
                return __murmur2_or_cityhash<size_t>()(&__u, sizeof (__u));
            }


        };
        struct __scalar_hash : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                union {
                    _Tp __t;
                    struct {
                        size_t __a;
                        size_t __b;
                        size_t __c;
                        size_t __d;
                    } __s;
                } __u;
                __u.__t = __v;
                return __murmur2_or_cityhash<size_t>()(&__u, sizeof (__u));
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<_Tp *, size_t> {
            size_t operator()(_Tp *__v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                union {
                    _Tp *__t;
                    size_t __a;
                } __u;
                __u.__t = __v;
                return __murmur2_or_cityhash<size_t>()(&__u, sizeof (__u));
            }


        };
        struct __attribute__((type_visibility("default"))) hash {
            typedef unique_ptr<_Tp, _Dp> argument_type;
            typedef size_t result_type;
            result_type operator()(const argument_type &__ptr) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename argument_type::pointer pointer;
                return hash<pointer>()(__ptr.get());
            }


        };
        struct __destruct_n {
        private:
            size_t size;
            template <class _Tp> void __process(_Tp *__p, false_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (size_t __i = 0; __i < this->size; ++__i , ++__p) 
                    __p->~_Tp();
            }

;
            template <class _Tp> void __process(_Tp *, true_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            void __incr(false_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ++this->size;
            }


            void __incr(true_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void __set(size_t __s, false_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->size = __s;
            }


            void __set(size_t, true_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        public:
            explicit __destruct_n(size_t __s) noexcept : size(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Tp> void __incr(_Tp *) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());
            }

;
            template <class _Tp> void __set(size_t __s, _Tp *) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());
            }

;
            template <class _Tp> void operator()(_Tp *__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());
            }

;
        };
        template <class _Alloc> class __allocator_destructor {
            typedef allocator_traits<_Alloc> __alloc_traits;
        public:
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::size_type size_type;
        private:
            _Alloc &__alloc_;
            size_type __s_;
        public:
            __allocator_destructor<_Alloc>(_Alloc &__a, size_type __s) noexcept : __alloc_(__a), __s_(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void operator()(pointer __p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __alloc_traits::deallocate(this->__alloc_, __p, this->__s_);
            }


        };
        template <class _InputIterator, class _ForwardIterator> _ForwardIterator uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            _ForwardIterator __s = __r;
            try {
                for (; __f != __l; ++__f , (void)++__r) 
                    ::new (static_cast<void *>(std::__1::addressof(*__r))) value_type((*__f));
            } catch (...) {
                for (; __s != __r; ++__s) 
                    __s->~value_type();
                throw;
            }
            return __r;
        }

;
        template <class _InputIterator, class _Size, class _ForwardIterator> _ForwardIterator uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            _ForwardIterator __s = __r;
            try {
                for (; __n > 0; ++__f , (void)++__r , (void)--__n) 
                    ::new (static_cast<void *>(std::__1::addressof(*__r))) value_type((*__f));
            } catch (...) {
                for (; __s != __r; ++__s) 
                    __s->~value_type();
                throw;
            }
            return __r;
        }

;
        template <class _ForwardIterator, class _Tp> void uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp &__x)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            _ForwardIterator __s = __f;
            try {
                for (; __f != __l; ++__f) 
                    ::new (static_cast<void *>(std::__1::addressof(*__f))) value_type((__x));
            } catch (...) {
                for (; __s != __f; ++__s) 
                    __s->~value_type();
                throw;
            }
        }

;
        template <class _ForwardIterator, class _Size, class _Tp> _ForwardIterator uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp &__x)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            _ForwardIterator __s = __f;
            try {
                for (; __n > 0; ++__f , (void)--__n) 
                    ::new (static_cast<void *>(std::__1::addressof(*__f))) value_type((__x));
            } catch (...) {
                for (; __s != __f; ++__s) 
                    __s->~value_type();
                throw;
            }
            return __f;
        }

;
        class __attribute__((visibility("default"))) bad_weak_ptr : public std::exception {
        public:
            virtual ~std::__1::bad_weak_ptr() noexcept;
            virtual const char *what() const noexcept;
        };
        template <class _Tp> class __attribute__((type_visibility("default"))) weak_ptr;
        class __attribute__((type_visibility("default"))) __shared_count {
            __shared_count(const std::__1::__shared_count &);
            std::__1::__shared_count &operator=(const std::__1::__shared_count &);
        protected:
            long __shared_owners_;
            virtual ~std::__1::__shared_count() noexcept;
        private:
            virtual void __on_zero_shared() noexcept = 0;
        public:
            explicit __shared_count(long __refs = 0) noexcept : __shared_owners_(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void __add_shared() noexcept;
            bool __release_shared() noexcept;
            long use_count() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __libcpp_relaxed_load(&this->__shared_owners_) + 1;
            }


        };
        class __attribute__((type_visibility("default"))) __shared_weak_count : private std::__1::__shared_count {
            long __shared_weak_owners_;
        public:
            explicit __shared_weak_count(long __refs = 0) noexcept : std::__1::__shared_count(__refs), __shared_weak_owners_(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        protected:
            virtual ~std::__1::__shared_weak_count() noexcept;
        public:
            void __add_shared() noexcept;
            void __add_weak() noexcept;
            void __release_shared() noexcept;
            void __release_weak() noexcept;
            long use_count() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__shared_count::use_count();
            }


            std::__1::__shared_weak_count *lock() noexcept;
            virtual const void *__get_deleter(const std::type_info &) const noexcept;
        private:
            virtual void __on_zero_shared_weak() noexcept = 0;
        };
        template <class _Tp, class _Dp, class _Alloc> class __shared_ptr_pointer : public std::__1::__shared_weak_count {
            __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
        public:
            __shared_ptr_pointer<_Tp, _Dp, _Alloc>(_Tp __p, _Dp __d, _Alloc __a) : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual const void *__get_deleter(const std::type_info &) const noexcept;
        private:
            virtual void __on_zero_shared() noexcept;
            virtual void __on_zero_shared_weak() noexcept;
        };
        const void *__get_deleter(const std::type_info &__t) const noexcept         {
            return __t == typeid(_Dp) ? std::__1::addressof(this->__data_.first().second()) : 0;
        }


        void __on_zero_shared() noexcept         {
            this->__data_.first().second()(this->__data_.first().first());
            this->__data_.first().second().~_Dp();
        }


        void __on_zero_shared_weak() noexcept         {
            typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer<_Tp, _Dp, _Alloc> >::type _Al;
            typedef allocator_traits<_Al> _ATraits;
            typedef pointer_traits<typename _ATraits::pointer> _PTraits;
            _Al __a(this->__data_.second());
            this->__data_.second().~_Alloc();
            __a.deallocate(_PTraits::pointer_to(*this), 1);
        }


        template <class _Tp, class _Alloc> class __shared_ptr_emplace : public std::__1::__shared_weak_count {
            __compressed_pair<_Alloc, _Tp> __data_;
        public:
            __shared_ptr_emplace<_Tp, _Alloc>(_Alloc __a) : __data_(std::__1::move(__a)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class ..._Args> __shared_ptr_emplace<_Tp, _Alloc>(_Alloc __a, _Args &&...__args) : __data_(piecewise_construct, std::__1::forward_as_tuple(__a), std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
        private:
            virtual void __on_zero_shared() noexcept;
            virtual void __on_zero_shared_weak() noexcept;
        public:
            _Tp *get() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return &this->__data_.second();
            }


        };
        void __on_zero_shared() noexcept         {
            this->__data_.second().~_Tp();
        }


        void __on_zero_shared_weak() noexcept         {
            typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace<_Tp, _Alloc> >::type _Al;
            typedef allocator_traits<_Al> _ATraits;
            typedef pointer_traits<typename _ATraits::pointer> _PTraits;
            _Al __a(this->__data_.first());
            this->__data_.first().~_Alloc();
            __a.deallocate(_PTraits::pointer_to(*this), 1);
        }


        template <class _Tp> class __attribute__((type_visibility("default"))) enable_shared_from_this;
        template <class _Tp> class __attribute__((type_visibility("default"))) shared_ptr {
        public:
            typedef _Tp element_type;
        private:
            element_type *__ptr_;
            std::__1::__shared_weak_count *__cntrl_;
            struct __nat {
                int __for_bool_;
            };
        public:
            constexpr shared_ptr<_Tp>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            constexpr shared_ptr<_Tp>(nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> explicit shared_ptr<_Tp>(_Yp *__p, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp, class _Dp> shared_ptr<_Tp>(_Yp *__p, _Dp __d, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp, class _Dp, class _Alloc> shared_ptr<_Tp>(_Yp *__p, _Dp __d, _Alloc __a, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Dp> shared_ptr<_Tp>(nullptr_t __p, _Dp __d);
            template <class _Dp, class _Alloc> shared_ptr<_Tp>(nullptr_t __p, _Dp __d, _Alloc __a);
            template <class _Yp> shared_ptr<_Tp>(const shared_ptr<_Yp> &__r, element_type *__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            shared_ptr<_Tp>(const shared_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> shared_ptr<_Tp>(const shared_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type = std::__1::shared_ptr::__nat()) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            shared_ptr<_Tp>(shared_ptr<_Tp> &&__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> shared_ptr<_Tp>(shared_ptr<_Yp> &&__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type = std::__1::shared_ptr::__nat()) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> explicit shared_ptr<_Tp>(const weak_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp> shared_ptr<_Tp>(auto_ptr<_Yp> &&__r, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp, class _Dp> shared_ptr<_Tp>(unique_ptr<_Yp, _Dp> &&, typename enable_if<!is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp, class _Dp> shared_ptr<_Tp>(unique_ptr<_Yp, _Dp> &&, typename enable_if<is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            ~shared_ptr<_Tp>();
            shared_ptr<_Tp> &operator=(const shared_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, shared_ptr<_Tp> &>::type operator=(const shared_ptr<_Yp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            shared_ptr<_Tp> &operator=(shared_ptr<_Tp> &&__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, shared_ptr<_Tp> &>::type operator=(shared_ptr<_Yp> &&__r) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> typename enable_if<!is_array<_Yp>::value && is_convertible<_Yp *, element_type *>::value, shared_ptr<_Tp> >::type &operator=(auto_ptr<_Yp> &&__r) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp, class _Dp> typename enable_if<!is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, shared_ptr<_Tp> &>::type operator=(unique_ptr<_Yp, _Dp> &&__r) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void swap(shared_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void reset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type reset(_Yp *__p) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp, class _Dp> typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type reset(_Yp *__p, _Dp __d) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp, class _Dp, class _Alloc> typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type reset(_Yp *__p, _Dp __d, _Alloc __a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            element_type *get() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_;
            }


            typename add_lvalue_reference<element_type>::type operator*() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this->__ptr_;
            }


            element_type *operator->() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ptr_;
            }


            long use_count() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cntrl_ ? this->__cntrl_->use_count() : 0;
            }


            bool unique() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->use_count() == 1;
            }


            explicit operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->get() != 0;
            }


            template <class _Up> bool owner_before(const shared_ptr<_Up> &__p) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cntrl_ < __p.__cntrl_;
            }

;
            template <class _Up> bool owner_before(const weak_ptr<_Up> &__p) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cntrl_ < __p.__cntrl_;
            }

;
            bool __owner_equivalent(const shared_ptr<_Tp> &__p) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cntrl_ == __p.__cntrl_;
            }


            template <class _Dp> _Dp *__get_deleter() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (_Dp *)(this->__cntrl_ ? this->__cntrl_->__get_deleter(typeid(_Dp)) : 0);
            }

;
            template <class ..._Args> static shared_ptr<_Tp> make_shared(_Args &&...__args);
            template <class _Alloc, class ..._Args> static shared_ptr<_Tp> allocate_shared(const _Alloc &__a, _Args &&...__args);
        private:
            template <class _Yp, class _OrigPtr> void __enable_weak_this(const enable_shared_from_this<_Yp> *__e, _OrigPtr *__ptr) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename remove_cv<_Yp>::type _RawYp;
                if (__e) {
                    __e->__weak_this_ = shared_ptr<_RawYp>(*this, const_cast<_RawYp *>(static_cast<const _Yp *>(__ptr)));
                }
            }

;
            void __enable_weak_this(const volatile void *, const volatile void *) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            friend template <class _Up> class __attribute__((type_visibility("default"))) shared_ptr;
            friend template <class _Up> class __attribute__((type_visibility("default"))) weak_ptr;
        };
        inline constexpr shared_ptr<_Tp>() noexcept : __ptr_(0), __cntrl_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline constexpr shared_ptr<_Tp>(nullptr_t) noexcept : __ptr_(0), __cntrl_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        template <class _Yp> shared_ptr<_Tp>(_Yp *__p, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__p)         {
            unique_ptr<_Yp> __hold(__p);
            typedef __shared_ptr_pointer<_Yp *, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
            this->__cntrl_ = new _CntrlBlk((__p, default_delete<_Yp>(), allocator<_Yp>()));
            __hold.release();
            __enable_weak_this(__p, __p);
        }

;
        template <class _Yp, class _Dp> shared_ptr<_Tp>(_Yp *__p, _Dp __d, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__p)         {
            try {
                typedef __shared_ptr_pointer<_Yp *, _Dp, allocator<_Yp> > _CntrlBlk;
                this->__cntrl_ = new _CntrlBlk((__p, __d, allocator<_Yp>()));
                __enable_weak_this(__p, __p);
            } catch (...) {
                __d(__p);
                throw;
            }
        }

;
        template <class _Dp> shared_ptr<_Tp>(nullptr_t __p, _Dp __d) : __ptr_(0)         {
            try {
                typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;
                this->__cntrl_ = new _CntrlBlk((__p, __d, allocator<_Tp>()));
            } catch (...) {
                __d(__p);
                throw;
            }
        }

;
        template <class _Yp, class _Dp, class _Alloc> shared_ptr<_Tp>(_Yp *__p, _Dp __d, _Alloc __a, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__p)         {
            try {
                typedef __shared_ptr_pointer<_Yp *, _Dp, _Alloc> _CntrlBlk;
                typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
                typedef __allocator_destructor<_A2> _D2;
                _A2 __a2(__a);
                unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
                ::new (static_cast<void *>(std::__1::addressof(*__hold2.get()))) _CntrlBlk((__p, __d, __a));
                this->__cntrl_ = std::__1::addressof(*__hold2.release());
                __enable_weak_this(__p, __p);
            } catch (...) {
                __d(__p);
                throw;
            }
        }

;
        template <class _Dp, class _Alloc> shared_ptr<_Tp>(nullptr_t __p, _Dp __d, _Alloc __a) : __ptr_(0)         {
            try {
                typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
                typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
                typedef __allocator_destructor<_A2> _D2;
                _A2 __a2(__a);
                unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
                ::new (static_cast<void *>(std::__1::addressof(*__hold2.get()))) _CntrlBlk((__p, __d, __a));
                this->__cntrl_ = std::__1::addressof(*__hold2.release());
            } catch (...) {
                __d(__p);
                throw;
            }
        }

;
        template <class _Yp> inline shared_ptr<_Tp>(const shared_ptr<_Yp> &__r, element_type *__p) noexcept : __ptr_(__p), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__cntrl_)
                this->__cntrl_->__add_shared();
        }

;
        inline shared_ptr<_Tp>(const shared_ptr<_Tp> &__r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__cntrl_)
                this->__cntrl_->__add_shared();
        }


        template <class _Yp> inline shared_ptr<_Tp>(const shared_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type = std::__1::shared_ptr::__nat()) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__cntrl_)
                this->__cntrl_->__add_shared();
        }

;
        inline shared_ptr<_Tp>(shared_ptr<_Tp> &&__r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __r.__ptr_ = 0;
            __r.__cntrl_ = 0;
        }


        template <class _Yp> inline shared_ptr<_Tp>(shared_ptr<_Yp> &&__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type = std::__1::shared_ptr::__nat()) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __r.__ptr_ = 0;
            __r.__cntrl_ = 0;
        }

;
        template <class _Yp> shared_ptr<_Tp>(auto_ptr<_Yp> &&__r, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__r.get())         {
            typedef __shared_ptr_pointer<_Yp *, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
            this->__cntrl_ = new _CntrlBlk((__r.get(), default_delete<_Yp>(), allocator<_Yp>()));
            __enable_weak_this(__r.get(), __r.get());
            __r.release();
        }

;
        template <class _Yp, class _Dp> shared_ptr<_Tp>(unique_ptr<_Yp, _Dp> &&__r, typename enable_if<!is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__r.get())         {
            {
                typedef __shared_ptr_pointer<_Yp *, _Dp, allocator<_Yp> > _CntrlBlk;
                this->__cntrl_ = new _CntrlBlk((__r.get(), __r.get_deleter(), allocator<_Yp>()));
                __enable_weak_this(__r.get(), __r.get());
            }
            __r.release();
        }

;
        template <class _Yp, class _Dp> shared_ptr<_Tp>(unique_ptr<_Yp, _Dp> &&__r, typename enable_if<is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__r.get())         {
            {
                typedef __shared_ptr_pointer<_Yp *, reference_wrapper<typename remove_reference<_Dp>::type>, allocator<_Yp> > _CntrlBlk;
                this->__cntrl_ = new _CntrlBlk((__r.get(), ref(__r.get_deleter()), allocator<_Yp>()));
                __enable_weak_this(__r.get(), __r.get());
            }
            __r.release();
        }

;
        template <class ..._Args> shared_ptr<_Tp> make_shared(_Args &&...__args)         {
            typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
            typedef allocator<_CntrlBlk> _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2;
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new (__hold2.get()) _CntrlBlk((__a2, std::__1::forward<_Args>(__args)...));
            shared_ptr<_Tp> __r;
            __r.__ptr_ = __hold2.get()->get();
            __r.__cntrl_ = __hold2.release();
            __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
            return __r;
        }

;
        template <class _Alloc, class ..._Args> shared_ptr<_Tp> allocate_shared(const _Alloc &__a, _Args &&...__args)         {
            typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
            typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2(__a);
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new (static_cast<void *>(std::__1::addressof(*__hold2.get()))) _CntrlBlk((__a, std::__1::forward<_Args>(__args)...));
            shared_ptr<_Tp> __r;
            __r.__ptr_ = __hold2.get()->get();
            __r.__cntrl_ = std::__1::addressof(*__hold2.release());
            __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
            return __r;
        }

;
        ~shared_ptr<_Tp>()         {
            if (this->__cntrl_)
                this->__cntrl_->__release_shared();
        }


        inline shared_ptr<_Tp> &operator=(const shared_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>(__r).swap(*this);
            return *this;
        }


        template <class _Yp> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, shared_ptr<_Tp> &>::type operator=(const shared_ptr<_Yp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>(__r).swap(*this);
            return *this;
        }

;
        inline shared_ptr<_Tp> &operator=(shared_ptr<_Tp> &&__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>(std::__1::move(__r)).swap(*this);
            return *this;
        }


        template <class _Yp> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, shared_ptr<_Tp> &>::type operator=(shared_ptr<_Yp> &&__r) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>(std::__1::move(__r)).swap(*this);
            return *this;
        }

;
        template <class _Yp> inline typename enable_if<!is_array<_Yp>::value && is_convertible<_Yp *, _Tp *>::value, shared_ptr<_Tp> >::type &operator=(auto_ptr<_Yp> &&__r) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>(std::__1::move(__r)).swap(*this);
            return *this;
        }

;
        template <class _Yp, class _Dp> inline typename enable_if<!is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp *>::value, shared_ptr<_Tp> &>::type operator=(unique_ptr<_Yp, _Dp> &&__r) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>(std::__1::move(__r)).swap(*this);
            return *this;
        }

;
        inline void swap(shared_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::swap(this->__ptr_, __r.__ptr_);
            std::__1::swap(this->__cntrl_, __r.__cntrl_);
        }


        inline void reset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>().swap(*this);
        }


        template <class _Yp> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, void>::type reset(_Yp *__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>(__p).swap(*this);
        }

;
        template <class _Yp, class _Dp> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, void>::type reset(_Yp *__p, _Dp __d) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>(__p, __d).swap(*this);
        }

;
        template <class _Yp, class _Dp, class _Alloc> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, void>::type reset(_Yp *__p, _Dp __d, _Alloc __a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            shared_ptr<_Tp>(__p, __d, __a).swap(*this);
        }

;
        template <class _Tp, class ..._Args> inline typename enable_if<!is_array<_Tp>::value, shared_ptr<_Tp> >::type make_shared(_Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return shared_ptr<_Tp>::make_shared(std::__1::forward<_Args>(__args)...);
        }

;
        template <class _Tp, class _Alloc, class ..._Args> inline typename enable_if<!is_array<_Tp>::value, shared_ptr<_Tp> >::type allocate_shared(const _Alloc &__a, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return shared_ptr<_Tp>::allocate_shared(__a, std::__1::forward<_Args>(__args)...);
        }

;
        template <class _Tp, class _Up> inline bool operator==(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.get() == __y.get();
        }

;
        template <class _Tp, class _Up> inline bool operator!=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }

;
        template <class _Tp, class _Up> inline bool operator<(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename common_type<_Tp *, _Up *>::type _Vp;
            return less<_Vp>()(__x.get(), __y.get());
        }

;
        template <class _Tp, class _Up> inline bool operator>(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __y < __x;
        }

;
        template <class _Tp, class _Up> inline bool operator<=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__y < __x);
        }

;
        template <class _Tp, class _Up> inline bool operator>=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < __y);
        }

;
        template <class _Tp> inline bool operator==(const shared_ptr<_Tp> &__x, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !__x;
        }

;
        template <class _Tp> inline bool operator==(nullptr_t, const shared_ptr<_Tp> &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !__x;
        }

;
        template <class _Tp> inline bool operator!=(const shared_ptr<_Tp> &__x, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<bool>(__x);
        }

;
        template <class _Tp> inline bool operator!=(nullptr_t, const shared_ptr<_Tp> &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<bool>(__x);
        }

;
        template <class _Tp> inline bool operator<(const shared_ptr<_Tp> &__x, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return less<_Tp *>()(__x.get(), nullptr);
        }

;
        template <class _Tp> inline bool operator<(nullptr_t, const shared_ptr<_Tp> &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return less<_Tp *>()(nullptr, __x.get());
        }

;
        template <class _Tp> inline bool operator>(const shared_ptr<_Tp> &__x, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return nullptr < __x;
        }

;
        template <class _Tp> inline bool operator>(nullptr_t, const shared_ptr<_Tp> &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x < nullptr;
        }

;
        template <class _Tp> inline bool operator<=(const shared_ptr<_Tp> &__x, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(nullptr < __x);
        }

;
        template <class _Tp> inline bool operator<=(nullptr_t, const shared_ptr<_Tp> &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < nullptr);
        }

;
        template <class _Tp> inline bool operator>=(const shared_ptr<_Tp> &__x, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x < nullptr);
        }

;
        template <class _Tp> inline bool operator>=(nullptr_t, const shared_ptr<_Tp> &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(nullptr < __x);
        }

;
        template <class _Tp> inline void swap(shared_ptr<_Tp> &__x, shared_ptr<_Tp> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __x.swap(__y);
        }

;
        template <class _Tp, class _Up> inline typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value, shared_ptr<_Tp> >::type static_pointer_cast(const shared_ptr<_Up> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return shared_ptr<_Tp>(__r, static_cast<_Tp *>(__r.get()));
        }

;
        template <class _Tp, class _Up> inline typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value, shared_ptr<_Tp> >::type dynamic_pointer_cast(const shared_ptr<_Up> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            _Tp *__p = dynamic_cast<_Tp *>(__r.get());
            return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
        }

;
        template <class _Tp, class _Up> typename enable_if<is_array<_Tp>::value == is_array<_Up>::value, shared_ptr<_Tp> >::type const_pointer_cast(const shared_ptr<_Up> &__r) noexcept         {
            typedef typename remove_extent<_Tp>::type _RTp;
            return shared_ptr<_Tp>(__r, const_cast<_RTp *>(__r.get()));
        }

;
        template <class _Dp, class _Tp> inline _Dp *get_deleter(const shared_ptr<_Tp> &__p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __p.template __get_deleter<_Dp>();
        }

;
        template <class _Tp> class __attribute__((type_visibility("default"))) weak_ptr {
        public:
            typedef _Tp element_type;
        private:
            element_type *__ptr_;
            std::__1::__shared_weak_count *__cntrl_;
        public:
            constexpr weak_ptr<_Tp>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> weak_ptr<_Tp>(const shared_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            weak_ptr<_Tp>(const weak_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> weak_ptr<_Tp>(const weak_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            weak_ptr<_Tp>(weak_ptr<_Tp> &&__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> weak_ptr<_Tp>(weak_ptr<_Yp> &&__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            ~weak_ptr<_Tp>();
            weak_ptr<_Tp> &operator=(const weak_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, weak_ptr<_Tp> &>::type operator=(const weak_ptr<_Yp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            weak_ptr<_Tp> &operator=(weak_ptr<_Tp> &&__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, weak_ptr<_Tp> &>::type operator=(weak_ptr<_Yp> &&__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, weak_ptr<_Tp> &>::type operator=(const shared_ptr<_Yp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void swap(weak_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void reset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            long use_count() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cntrl_ ? this->__cntrl_->use_count() : 0;
            }


            bool expired() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cntrl_ == 0 || this->__cntrl_->use_count() == 0;
            }


            shared_ptr<_Tp> lock() const noexcept;
            template <class _Up> bool owner_before(const shared_ptr<_Up> &__r) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cntrl_ < __r.__cntrl_;
            }

;
            template <class _Up> bool owner_before(const weak_ptr<_Up> &__r) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cntrl_ < __r.__cntrl_;
            }

;
            friend template <class _Up> class __attribute__((type_visibility("default"))) weak_ptr;
            friend template <class _Up> class __attribute__((type_visibility("default"))) shared_ptr;
        };
        inline constexpr weak_ptr<_Tp>() noexcept : __ptr_(0), __cntrl_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline weak_ptr<_Tp>(const weak_ptr<_Tp> &__r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__cntrl_)
                this->__cntrl_->__add_weak();
        }


        template <class _Yp> inline weak_ptr<_Tp>(const shared_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__cntrl_)
                this->__cntrl_->__add_weak();
        }

;
        template <class _Yp> inline weak_ptr<_Tp>(const weak_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__cntrl_)
                this->__cntrl_->__add_weak();
        }

;
        inline weak_ptr<_Tp>(weak_ptr<_Tp> &&__r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __r.__ptr_ = 0;
            __r.__cntrl_ = 0;
        }


        template <class _Yp> inline weak_ptr<_Tp>(weak_ptr<_Yp> &&__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __r.__ptr_ = 0;
            __r.__cntrl_ = 0;
        }

;
        ~weak_ptr<_Tp>()         {
            if (this->__cntrl_)
                this->__cntrl_->__release_weak();
        }


        inline weak_ptr<_Tp> &operator=(const weak_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            weak_ptr<_Tp>(__r).swap(*this);
            return *this;
        }


        template <class _Yp> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, weak_ptr<_Tp> &>::type operator=(const weak_ptr<_Yp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            weak_ptr<_Tp>(__r).swap(*this);
            return *this;
        }

;
        inline weak_ptr<_Tp> &operator=(weak_ptr<_Tp> &&__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            weak_ptr<_Tp>(std::__1::move(__r)).swap(*this);
            return *this;
        }


        template <class _Yp> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, weak_ptr<_Tp> &>::type operator=(weak_ptr<_Yp> &&__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            weak_ptr<_Tp>(std::__1::move(__r)).swap(*this);
            return *this;
        }

;
        template <class _Yp> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, weak_ptr<_Tp> &>::type operator=(const shared_ptr<_Yp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            weak_ptr<_Tp>(__r).swap(*this);
            return *this;
        }

;
        inline void swap(weak_ptr<_Tp> &__r) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::swap(this->__ptr_, __r.__ptr_);
            std::__1::swap(this->__cntrl_, __r.__cntrl_);
        }


        template <class _Tp> inline void swap(weak_ptr<_Tp> &__x, weak_ptr<_Tp> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __x.swap(__y);
        }

;
        inline void reset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            weak_ptr<_Tp>().swap(*this);
        }


        template <class _Yp> shared_ptr<_Tp>(const weak_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)         {
            if (this->__cntrl_ == 0)
                throw std::__1::bad_weak_ptr();
        }

;
        shared_ptr<_Tp> lock() const noexcept         {
            shared_ptr<_Tp> __r;
            __r.__cntrl_ = this->__cntrl_ ? this->__cntrl_->lock() : this->__cntrl_;
            if (__r.__cntrl_)
                __r.__ptr_ = this->__ptr_;
            return __r;
        }


        template <class _Tp> struct owner_less;
        struct __attribute__((type_visibility("default"))) owner_less : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool> {
            typedef bool result_type;
            bool operator()(const shared_ptr<_Tp> &__x, const shared_ptr<_Tp> &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x.owner_before(__y);
            }


            bool operator()(const shared_ptr<_Tp> &__x, const weak_ptr<_Tp> &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x.owner_before(__y);
            }


            bool operator()(const weak_ptr<_Tp> &__x, const shared_ptr<_Tp> &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x.owner_before(__y);
            }


        };
        struct __attribute__((type_visibility("default"))) owner_less : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool> {
            typedef bool result_type;
            bool operator()(const weak_ptr<_Tp> &__x, const weak_ptr<_Tp> &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x.owner_before(__y);
            }


            bool operator()(const shared_ptr<_Tp> &__x, const weak_ptr<_Tp> &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x.owner_before(__y);
            }


            bool operator()(const weak_ptr<_Tp> &__x, const shared_ptr<_Tp> &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x.owner_before(__y);
            }


        };
        template <class _Tp> class __attribute__((type_visibility("default"))) enable_shared_from_this {
            mutable weak_ptr<_Tp> __weak_this_;
        protected:
            constexpr enable_shared_from_this<_Tp>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            enable_shared_from_this<_Tp>(const enable_shared_from_this<_Tp> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            enable_shared_from_this<_Tp> &operator=(const enable_shared_from_this<_Tp> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this;
            }


            ~enable_shared_from_this<_Tp>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        public:
            shared_ptr<_Tp> shared_from_this() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return shared_ptr<_Tp>(this->__weak_this_);
            }


            shared_ptr<const _Tp> shared_from_this() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return shared_ptr<const _Tp>(this->__weak_this_);
            }


            friend template <class _Up> class __attribute__((type_visibility("default"))) shared_ptr;
        };
        struct __attribute__((type_visibility("default"))) hash {
            typedef shared_ptr<_Tp> argument_type;
            typedef size_t result_type;
            result_type operator()(const argument_type &__ptr) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return hash<_Tp *>()(__ptr.get());
            }


        };
        template <class _CharT, class _Traits, class _Yp> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const shared_ptr<_Yp> &__p) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        class __attribute__((type_visibility("default"))) __sp_mut {
            void *__lx;
        public:
            void lock() noexcept;
            void unlock() noexcept;
        private:
            constexpr __sp_mut(void *) noexcept;
            __sp_mut(const std::__1::__sp_mut &);
            std::__1::__sp_mut &operator=(const std::__1::__sp_mut &);
            friend std::__1::__sp_mut &__get_sp_mut(const void *) __attribute__((visibility("default")));
        };
        std::__1::__sp_mut &__get_sp_mut(const void *) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9))) __attribute__((visibility("default")));
        template <class _Tp> inline bool atomic_is_lock_free(const shared_ptr<_Tp> *) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return false;
        }

;
        template <class _Tp> shared_ptr<_Tp> atomic_load(const shared_ptr<_Tp> *__p) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)))         {
            std::__1::__sp_mut &__m = __get_sp_mut(__p);
            __m.lock();
            shared_ptr<_Tp> __q = *__p;
            __m.unlock();
            return __q;
        }

;
        template <class _Tp> inline shared_ptr<_Tp> atomic_load_explicit(const shared_ptr<_Tp> *__p, memory_order) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9))) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return atomic_load(__p);
        }

;
        template <class _Tp> void atomic_store(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)))         {
            std::__1::__sp_mut &__m = __get_sp_mut(__p);
            __m.lock();
            __p->swap(__r);
            __m.unlock();
        }

;
        template <class _Tp> inline void atomic_store_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, memory_order) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9))) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            atomic_store(__p, __r);
        }

;
        template <class _Tp> shared_ptr<_Tp> atomic_exchange(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)))         {
            std::__1::__sp_mut &__m = __get_sp_mut(__p);
            __m.lock();
            __p->swap(__r);
            __m.unlock();
            return __r;
        }

;
        template <class _Tp> inline shared_ptr<_Tp> atomic_exchange_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, memory_order) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9))) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return atomic_exchange(__p, __r);
        }

;
        template <class _Tp> bool atomic_compare_exchange_strong(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)))         {
            std::__1::__sp_mut &__m = __get_sp_mut(__p);
            __m.lock();
            if (__p->__owner_equivalent(*__v)) {
                *__p = __w;
                __m.unlock();
                return true;
            }
            *__v = *__p;
            __m.unlock();
            return false;
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_weak(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9))) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return atomic_compare_exchange_strong(__p, __v, __w);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_strong_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w, memory_order, memory_order) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9))) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return atomic_compare_exchange_strong(__p, __v, __w);
        }

;
        template <class _Tp> inline bool atomic_compare_exchange_weak_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w, memory_order, memory_order) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9))) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return atomic_compare_exchange_weak(__p, __v, __w);
        }

;
        struct __attribute__((type_visibility("default"))) pointer_safety {
            enum __lx {
                relaxed,
                preferred,
                strict
            };
            std::__1::pointer_safety::__lx __v_;
            pointer_safety(std::__1::pointer_safety::__lx __v) : __v_(__v) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            operator int() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__v_;
            }


        };
        void declare_reachable(void *__p) __attribute__((visibility("default")));
        void declare_no_pointers(char *__p, size_t __n) __attribute__((visibility("default")));
        void undeclare_no_pointers(char *__p, size_t __n) __attribute__((visibility("default")));
        std::__1::pointer_safety get_pointer_safety() noexcept __attribute__((visibility("default")));
        void *__undeclare_reachable(void *__p) __attribute__((visibility("default")));
        template <class _Tp> inline _Tp *undeclare_reachable(_Tp *__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<_Tp *>(__undeclare_reachable(__p));
        }

;
        void *align(size_t __align, size_t __sz, void *&__ptr, size_t &__space) __attribute__((visibility("default")));
        template <typename _Alloc> void __swap_allocator(_Alloc &__a1, _Alloc &__a2) noexcept(__is_nothrow_swappable<_Alloc>::value__swap_allocator(_Alloc &__a1, _Alloc &__a2) noexcept(__is_nothrow_swappable<_Alloc>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __swap_allocator(__a1, __a2, integral_constant<bool, std::__1::allocator_traits<_Alloc>::propagate_on_container_swap::value>());
        }

;
        template <typename _Alloc> void __swap_allocator(_Alloc &__a1, _Alloc &__a2, true_type) noexcept(__is_nothrow_swappable<_Alloc>::value__swap_allocator(_Alloc &__a1, _Alloc &__a2, true_type) noexcept(__is_nothrow_swappable<_Alloc>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            using std::__1::swap;
            swap(__a1, __a2);
        }

;
        template <typename _Alloc> void __swap_allocator(_Alloc &, _Alloc &, false_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }

;
    }
}
namespace std {
    inline namespace __1 {
        template <class _T1, class _T2 = _T1> struct __equal_to {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x == __y;
            }


            bool operator()(const _T1 &__x, const _T2 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x == __y;
            }


            bool operator()(const _T2 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x == __y;
            }


            bool operator()(const _T2 &__x, const _T2 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x == __y;
            }


        };
        struct __equal_to {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x == __y;
            }


        };
        struct __equal_to {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x == __y;
            }


        };
        struct __equal_to {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x == __y;
            }


        };
        template <class _T1 = unsigned long, class _T2 = unsigned long> struct __less {
            bool operator()(const unsigned long &__x, const unsigned long &__y) const __attribute__((always_inline));
        }
template <class _T1 = char, class _T2 = char> struct __less
template <class _T1 = wchar_t, class _T2 = wchar_t> struct __less
template <class _T1 = signed char, class _T2 = signed char> struct __less
template <class _T1 = unsigned char, class _T2 = unsigned char> struct __less
template <class _T1 = short, class _T2 = short> struct __less
template <class _T1 = unsigned short, class _T2 = unsigned short> struct __less
template <class _T1 = int, class _T2 = int> struct __less
template <class _T1 = unsigned int, class _T2 = unsigned int> struct __less
template <class _T1 = long, class _T2 = long> struct __less
template <class _T1 = long long, class _T2 = long long> struct __less
template <class _T1 = unsigned long long, class _T2 = unsigned long long> struct __less
template <class _T1 = float, class _T2 = float> struct __less
template <class _T1 = double, class _T2 = double> struct __less
template <class _T1 = long double, class _T2 = long double> struct __less
template <class _T1, class _T2 = _T1> struct __less {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x < __y;
            }


            bool operator()(const _T1 &__x, const _T2 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x < __y;
            }


            bool operator()(const _T2 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x < __y;
            }


            bool operator()(const _T2 &__x, const _T2 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x < __y;
            }


        };
        struct __less {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x < __y;
            }


        };
        struct __less {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x < __y;
            }


        };
        struct __less {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x < __y;
            }


        };
        template <class _Predicate> class __negate {
        private:
            _Predicate __p_;
        public:
            __negate<_Predicate>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit __negate<_Predicate>(_Predicate __p) : __p_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _T1> bool operator()(const _T1 &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !this->__p_(__x);
            }

;
            template <class _T1, class _T2> bool operator()(const _T1 &__x, const _T2 &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !this->__p_(__x, __y);
            }

;
        };
        inline unsigned int __ctz(unsigned int __x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<unsigned int>(__builtin_ctz(__x));
        }


        inline unsigned long __ctz(unsigned long __x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<unsigned long>(__builtin_ctzl(__x));
        }


        inline unsigned long long __ctz(unsigned long long __x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<unsigned long long>(__builtin_ctzll(__x));
        }


        inline unsigned int __clz(unsigned int __x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<unsigned int>(__builtin_clz(__x));
        }


        inline unsigned long __clz(unsigned long __x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<unsigned long>(__builtin_clzl(__x));
        }


        inline unsigned long long __clz(unsigned long long __x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<unsigned long long>(__builtin_clzll(__x));
        }


        inline int __pop_count(unsigned int __x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __builtin_popcount(__x);
        }


        inline int __pop_count(unsigned long __x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __builtin_popcountl(__x);
        }


        inline int __pop_count(unsigned long long __x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __builtin_popcountll(__x);
        }


        template <class _InputIterator, class _Predicate> inline bool all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                if (!__pred(*__first))
                    return false;
            return true;
        }

;
        template <class _InputIterator, class _Predicate> inline bool any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                if (__pred(*__first))
                    return true;
            return false;
        }

;
        template <class _InputIterator, class _Predicate> inline bool none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                if (__pred(*__first))
                    return false;
            return true;
        }

;
        template <class _InputIterator, class _Function> inline _Function for_each(_InputIterator __first, _InputIterator __last, _Function __f) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                __f(*__first);
            return std::__1::move(__f);
        }

;
        template <class _InputIterator, class _Tp> inline _InputIterator find(_InputIterator __first, _InputIterator __last, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                if (*__first == __value_)
                    break;
            return __first;
        }

;
        template <class _InputIterator, class _Predicate> inline _InputIterator find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                if (__pred(*__first))
                    break;
            return __first;
        }

;
        template <class _InputIterator, class _Predicate> inline _InputIterator find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                if (!__pred(*__first))
                    break;
            return __first;
        }

;
        template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2> _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred, std::__1::forward_iterator_tag, std::__1::forward_iterator_tag)         {
            _ForwardIterator1 __r = __last1;
            if (__first2 == __last2)
                return __r;
            while (true)
                {
                    while (true)
                        {
                            if (__first1 == __last1)
                                return __r;
                            if (__pred(*__first1, *__first2))
                                break;
                            ++__first1;
                        }
                    _ForwardIterator1 __m1 = __first1;
                    _ForwardIterator2 __m2 = __first2;
                    while (true)
                        {
                            if (++__m2 == __last2) {
                                __r = __first1;
                                ++__first1;
                                break;
                            }
                            if (++__m1 == __last1)
                                return __r;
                            if (!__pred(*__m1, *__m2)) {
                                ++__first1;
                                break;
                            }
                        }
                }
        }

;
        template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2> _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred, std::__1::bidirectional_iterator_tag, std::__1::bidirectional_iterator_tag)         {
            if (__first2 == __last2)
                return __last1;
            _BidirectionalIterator1 __l1 = __last1;
            _BidirectionalIterator2 __l2 = __last2;
            --__l2;
            while (true)
                {
                    while (true)
                        {
                            if (__first1 == __l1)
                                return __last1;
                            if (__pred(*--__l1, *__l2))
                                break;
                        }
                    _BidirectionalIterator1 __m1 = __l1;
                    _BidirectionalIterator2 __m2 = __l2;
                    while (true)
                        {
                            if (__m2 == __first2)
                                return __m1;
                            if (__m1 == __first1)
                                return __last1;
                            if (!__pred(*--__m1, *--__m2)) {
                                break;
                            }
                        }
                }
        }

;
        template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2> _RandomAccessIterator1 __find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, std::__1::random_access_iterator_tag, std::__1::random_access_iterator_tag)         {
            typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
            if (__len2 == 0)
                return __last1;
            typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
            if (__len1 < __len2)
                return __last1;
            const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
            _RandomAccessIterator1 __l1 = __last1;
            _RandomAccessIterator2 __l2 = __last2;
            --__l2;
            while (true)
                {
                    while (true)
                        {
                            if (__s == __l1)
                                return __last1;
                            if (__pred(*--__l1, *__l2))
                                break;
                        }
                    _RandomAccessIterator1 __m1 = __l1;
                    _RandomAccessIterator2 __m2 = __l2;
                    while (true)
                        {
                            if (__m2 == __first2)
                                return __m1;
                            if (!__pred(*--__m1, *--__m2)) {
                                break;
                            }
                        }
                }
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>(__first1, __last1, __first2, __last2, __pred, typename iterator_traits<_ForwardIterator1>::iterator_category(), typename iterator_traits<_ForwardIterator2>::iterator_category());
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
            typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
            return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> _ForwardIterator1 __find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)         {
            for (; __first1 != __last1; ++__first1) 
                for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j) 
                    if (__pred(*__first1, *__j))
                        return __first1;
            return __last1;
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _ForwardIterator1 find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
            typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
            return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
        }

;
        template <class _ForwardIterator, class _BinaryPredicate> inline _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (__pred(*__first, *__i))
                            return __first;
                        __first = __i;
                    }
            }
            return __last;
        }

;
        template <class _ForwardIterator> inline _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_ForwardIterator>::value_type __v;
            return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
        }

;
        template <class _InputIterator, class _Tp> inline typename iterator_traits<_InputIterator>::difference_type count(_InputIterator __first, _InputIterator __last, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typename iterator_traits<_InputIterator>::difference_type __r(0);
            for (; __first != __last; ++__first) 
                if (*__first == __value_)
                    ++__r;
            return __r;
        }

;
        template <class _InputIterator, class _Predicate> inline typename iterator_traits<_InputIterator>::difference_type count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typename iterator_traits<_InputIterator>::difference_type __r(0);
            for (; __first != __last; ++__first) 
                if (__pred(*__first))
                    ++__r;
            return __r;
        }

;
        template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2) 
                if (!__pred(*__first1, *__first2))
                    break;
            return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
        }

;
        template <class _InputIterator1, class _InputIterator2> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_InputIterator1>::value_type __v1;
            typedef typename iterator_traits<_InputIterator2>::value_type __v2;
            return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
        }

;
        template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate> inline bool equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2) 
                if (!__pred(*__first1, *__first2))
                    return false;
            return true;
        }

;
        template <class _InputIterator1, class _InputIterator2> inline bool equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_InputIterator1>::value_type __v1;
            typedef typename iterator_traits<_InputIterator2>::value_type __v2;
            return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2) 
                if (!__pred(*__first1, *__first2))
                    goto __not_done;
            return true;
          __not_done:
            typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
            _D1 __l1 = std::__1::distance(__first1, __last1);
            if (__l1 == _D1(1))
                return false;
            _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);
            for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i) {
                for (_ForwardIterator1 __j = __first1; __j != __i; ++__j) 
                    if (__pred(*__j, *__i))
                        goto __next_iter;
                {
                    _D1 __c2 = 0;
                    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j) 
                        if (__pred(*__i, *__j))
                            ++__c2;
                    if (__c2 == 0)
                        return false;
                    _D1 __c1 = 1;
                    for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j) 
                        if (__pred(*__i, *__j))
                            ++__c1;
                    if (__c1 != __c2)
                        return false;
                }
              __next_iter:
                ;
            }
            return true;
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2> inline bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
            typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
            return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
        }

;
        template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2> _ForwardIterator1 __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred, std::__1::forward_iterator_tag, std::__1::forward_iterator_tag)         {
            if (__first2 == __last2)
                return __first1;
            while (true)
                {
                    while (true)
                        {
                            if (__first1 == __last1)
                                return __last1;
                            if (__pred(*__first1, *__first2))
                                break;
                            ++__first1;
                        }
                    _ForwardIterator1 __m1 = __first1;
                    _ForwardIterator2 __m2 = __first2;
                    while (true)
                        {
                            if (++__m2 == __last2)
                                return __first1;
                            if (++__m1 == __last1)
                                return __last1;
                            if (!__pred(*__m1, *__m2)) {
                                ++__first1;
                                break;
                            }
                        }
                }
        }

;
        template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2> _RandomAccessIterator1 __search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, std::__1::random_access_iterator_tag, std::__1::random_access_iterator_tag)         {
            typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;
            typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;
            _D2 __len2 = __last2 - __first2;
            if (__len2 == 0)
                return __first1;
            _D1 __len1 = __last1 - __first1;
            if (__len1 < __len2)
                return __last1;
            const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);
            while (true)
                {
                    while (true)
                        {
                            if (__first1 == __s)
                                return __last1;
                            if (__pred(*__first1, *__first2))
                                break;
                            ++__first1;
                        }
                    _RandomAccessIterator1 __m1 = __first1;
                    _RandomAccessIterator2 __m2 = __first2;
                    while (true)
                        {
                            if (++__m2 == __last2)
                                return __first1;
                            ++__m1;
                            if (!__pred(*__m1, *__m2)) {
                                ++__first1;
                                break;
                            }
                        }
                }
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>(__first1, __last1, __first2, __last2, __pred, typename std::iterator_traits<_ForwardIterator1>::iterator_category(), typename std::iterator_traits<_ForwardIterator2>::iterator_category());
        }

;
        template <class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;
            typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;
            return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
        }

;
        template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp> _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp &__value_, _BinaryPredicate __pred, std::__1::forward_iterator_tag)         {
            if (__count <= 0)
                return __first;
            while (true)
                {
                    while (true)
                        {
                            if (__first == __last)
                                return __last;
                            if (__pred(*__first, __value_))
                                break;
                            ++__first;
                        }
                    _ForwardIterator __m = __first;
                    _Size __c(0);
                    while (true)
                        {
                            if (++__c == __count)
                                return __first;
                            if (++__m == __last)
                                return __last;
                            if (!__pred(*__m, __value_)) {
                                __first = __m;
                                ++__first;
                                break;
                            }
                        }
                }
        }

;
        template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp> _RandomAccessIterator __search_n(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __count, const _Tp &__value_, _BinaryPredicate __pred, std::__1::random_access_iterator_tag)         {
            if (__count <= 0)
                return __first;
            _Size __len = static_cast<_Size>(__last - __first);
            if (__len < __count)
                return __last;
            const _RandomAccessIterator __s = __last - (__count - 1);
            while (true)
                {
                    while (true)
                        {
                            if (__first >= __s)
                                return __last;
                            if (__pred(*__first, __value_))
                                break;
                            ++__first;
                        }
                    _RandomAccessIterator __m = __first;
                    _Size __c(0);
                    while (true)
                        {
                            if (++__c == __count)
                                return __first;
                            ++__m;
                            if (!__pred(*__m, __value_)) {
                                __first = __m;
                                ++__first;
                                break;
                            }
                        }
                }
        }

;
        template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate> inline _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp &__value_, _BinaryPredicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>(__first, __last, __convert_to_integral(__count), __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
        }

;
        template <class _ForwardIterator, class _Size, class _Tp> inline _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_ForwardIterator>::value_type __v;
            return std::__1::search_n(__first, __last, __convert_to_integral(__count), __value_, __equal_to<__v, _Tp>());
        }

;
        template <class _Iter> struct __libcpp_is_trivial_iterator {
            static const bool value = is_pointer<_Iter>::value;
        };
        struct __libcpp_is_trivial_iterator {
            static const bool value = is_pointer<_Iter>::value;
        };
        struct __libcpp_is_trivial_iterator {
            static const bool value = is_pointer<_Iter>::value;
        };
        template <class _Iter> inline _Iter __unwrap_iter(_Iter __i) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __i;
        }

;
        template <class _Tp> inline typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(move_iterator<_Tp *> __i) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __i.base();
        }

;
        template <class _Tp> inline typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *> __i) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __i.base();
        }

;
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator __copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first , (void)++__result) 
                *__result = *__first;
            return __result;
        }

;
        template <class _Tp, class _Up> inline typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value && is_trivially_copy_assignable<_Up>::value, _Up *>::type __copy(_Tp *__first, _Tp *__last, _Up *__result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0)
                std::__1::memmove(__result, __first, __n * sizeof(_Up));
            return __result + __n;
        }

;
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
        }

;
        template <class _BidirectionalIterator, class _OutputIterator> inline _OutputIterator __copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }

;
        template <class _Tp, class _Up> inline typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value && is_trivially_copy_assignable<_Up>::value, _Up *>::type __copy_backward(_Tp *__first, _Tp *__last, _Up *__result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0) {
                __result -= __n;
                std::__1::memmove(__result, __first, __n * sizeof(_Up));
            }
            return __result;
        }

;
        template <class _BidirectionalIterator1, class _BidirectionalIterator2> inline _BidirectionalIterator2 copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, _BidirectionalIterator2 __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
        }

;
        template <class _InputIterator, class _OutputIterator, class _Predicate> inline _OutputIterator copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) {
                if (__pred(*__first)) {
                    *__result = *__first;
                    ++__result;
                }
            }
            return __result;
        }

;
        template <class _InputIterator, class _Size, class _OutputIterator> inline typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_random_access_iterator<_InputIterator>::value, _OutputIterator>::type copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
            _IntegralSize __n = __orig_n;
            if (__n > 0) {
                *__result = *__first;
                ++__result;
                for (--__n; __n > 0; --__n) {
                    ++__first;
                    *__result = *__first;
                    ++__result;
                }
            }
            return __result;
        }

;
        template <class _InputIterator, class _Size, class _OutputIterator> inline typename enable_if<__is_random_access_iterator<_InputIterator>::value, _OutputIterator>::type copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
            _IntegralSize __n = __orig_n;
            return std::__1::copy(__first, __first + __n, __result);
        }

;
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator __move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first , (void)++__result) 
                *__result = std::__1::move(*__first);
            return __result;
        }

;
        template <class _Tp, class _Up> inline typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value && is_trivially_copy_assignable<_Up>::value, _Up *>::type __move(_Tp *__first, _Tp *__last, _Up *__result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0)
                std::__1::memmove(__result, __first, __n * sizeof(_Up));
            return __result + __n;
        }

;
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
        }

;
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator __move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            while (__first != __last)
                *--__result = std::__1::move(*--__last);
            return __result;
        }

;
        template <class _Tp, class _Up> inline typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value && is_trivially_copy_assignable<_Up>::value, _Up *>::type __move_backward(_Tp *__first, _Tp *__last, _Up *__result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0) {
                __result -= __n;
                std::__1::memmove(__result, __first, __n * sizeof(_Up));
            }
            return __result;
        }

;
        template <class _BidirectionalIterator1, class _BidirectionalIterator2> inline _BidirectionalIterator2 move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, _BidirectionalIterator2 __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
        }

;
        template <class _InputIterator, class _OutputIterator, class _UnaryOperation> inline _OutputIterator transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first , (void)++__result) 
                *__result = __op(*__first);
            return __result;
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation> inline _OutputIterator transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2 , ++__result) 
                *__result = __binary_op(*__first1, *__first2);
            return __result;
        }

;
        template <class _ForwardIterator, class _Tp> inline void replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__old_value, const _Tp &__new_value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                if (*__first == __old_value)
                    *__first = __new_value;
        }

;
        template <class _ForwardIterator, class _Predicate, class _Tp> inline void replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &__new_value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                if (__pred(*__first))
                    *__first = __new_value;
        }

;
        template <class _InputIterator, class _OutputIterator, class _Tp> inline _OutputIterator replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__old_value, const _Tp &__new_value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first , (void)++__result) 
                if (*__first == __old_value)
                    *__result = __new_value;
                else
                    *__result = *__first;
            return __result;
        }

;
        template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp> inline _OutputIterator replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &__new_value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first , (void)++__result) 
                if (__pred(*__first))
                    *__result = __new_value;
                else
                    *__result = *__first;
            return __result;
        }

;
        template <class _OutputIterator, class _Size, class _Tp> inline _OutputIterator __fill_n(_OutputIterator __first, _Size __n, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __n > 0; ++__first , (void)--__n) 
                *__first = __value_;
            return __first;
        }

;
        template <class _Tp, class _Size, class _Up> inline typename enable_if<is_integral<_Tp>::value && sizeof(_Tp) == 1 && !is_same<_Tp, bool>::value && is_integral<_Up>::value && sizeof(_Up) == 1, _Tp *>::type __fill_n(_Tp *__first, _Size __n, _Up __value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__n > 0)
                std::__1::memset(__first, (unsigned char)__value_, (size_t)(__n));
            return __first + __n;
        }

;
        template <class _OutputIterator, class _Size, class _Tp> inline _OutputIterator fill_n(_OutputIterator __first, _Size __n, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__fill_n(__first, __convert_to_integral(__n), __value_);
        }

;
        template <class _ForwardIterator, class _Tp> inline void __fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, std::__1::forward_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                *__first = __value_;
        }

;
        template <class _RandomAccessIterator, class _Tp> inline void __fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__value_, std::__1::random_access_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::fill_n(__first, __last - __first, __value_);
        }

;
        template <class _ForwardIterator, class _Tp> inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
        }

;
        template <class _ForwardIterator, class _Generator> inline void generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) 
                *__first = __gen();
        }

;
        template <class _OutputIterator, class _Size, class _Generator> inline _OutputIterator generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
            _IntegralSize __n = __orig_n;
            for (; __n > 0; ++__first , (void)--__n) 
                *__first = __gen();
            return __first;
        }

;
        template <class _ForwardIterator, class _Tp> _ForwardIterator remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_)         {
            __first = std::__1::find(__first, __last, __value_);
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (!(*__i == __value_)) {
                            *__first = std::__1::move(*__i);
                            ++__first;
                        }
                    }
            }
            return __first;
        }

;
        template <class _ForwardIterator, class _Predicate> _ForwardIterator remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)         {
            __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred);
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (!__pred(*__i)) {
                            *__first = std::__1::move(*__i);
                            ++__first;
                        }
                    }
            }
            return __first;
        }

;
        template <class _InputIterator, class _OutputIterator, class _Tp> inline _OutputIterator remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) {
                if (!(*__first == __value_)) {
                    *__result = *__first;
                    ++__result;
                }
            }
            return __result;
        }

;
        template <class _InputIterator, class _OutputIterator, class _Predicate> inline _OutputIterator remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__first) {
                if (!__pred(*__first)) {
                    *__result = *__first;
                    ++__result;
                }
            }
            return __result;
        }

;
        template <class _ForwardIterator, class _BinaryPredicate> _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)         {
            __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>(__first, __last, __pred);
            if (__first != __last) {
                _ForwardIterator __i = __first;
                for (++__i; ++__i != __last;) 
                    if (!__pred(*__first, *__i))
                        *++__first = std::__1::move(*__i);
                ++__first;
            }
            return __first;
        }

;
        template <class _ForwardIterator> inline _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_ForwardIterator>::value_type __v;
            return std::__1::unique(__first, __last, __equal_to<__v>());
        }

;
        template <class _BinaryPredicate, class _InputIterator, class _OutputIterator> _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred, std::__1::input_iterator_tag, std::__1::output_iterator_tag)         {
            if (__first != __last) {
                typename iterator_traits<_InputIterator>::value_type __t(*__first);
                *__result = __t;
                ++__result;
                while (++__first != __last)
                    {
                        if (!__pred(__t, *__first)) {
                            __t = *__first;
                            *__result = __t;
                            ++__result;
                        }
                    }
            }
            return __result;
        }

;
        template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator> _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred, std::__1::forward_iterator_tag, std::__1::output_iterator_tag)         {
            if (__first != __last) {
                _ForwardIterator __i = __first;
                *__result = *__i;
                ++__result;
                while (++__first != __last)
                    {
                        if (!__pred(*__i, *__first)) {
                            *__result = *__first;
                            ++__result;
                            __i = __first;
                        }
                    }
            }
            return __result;
        }

;
        template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator> _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred, std::__1::input_iterator_tag, std::__1::forward_iterator_tag)         {
            if (__first != __last) {
                *__result = *__first;
                while (++__first != __last)
                    if (!__pred(*__result, *__first))
                        *++__result = *__first;
                ++__result;
            }
            return __result;
        }

;
        template <class _InputIterator, class _OutputIterator, class _BinaryPredicate> inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>(__first, __last, __result, __pred, typename iterator_traits<_InputIterator>::iterator_category(), typename iterator_traits<_OutputIterator>::iterator_category());
        }

;
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_InputIterator>::value_type __v;
            return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
        }

;
        template <class _BidirectionalIterator> inline void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, std::__1::bidirectional_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            while (__first != __last)
                {
                    if (__first == --__last)
                        break;
                    swap(*__first, *__last);
                    ++__first;
                }
        }

;
        template <class _RandomAccessIterator> inline void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, std::__1::random_access_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__first != __last)
                for (; __first < --__last; ++__first) 
                    swap(*__first, *__last);
        }

;
        template <class _BidirectionalIterator = char *> inline void reverse(char *__first, char *__last) __attribute__((always_inline))template <class _BidirectionalIterator> inline void reverse(_BidirectionalIterator __first, _BidirectionalIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
        }

;
        template <class _BidirectionalIterator, class _OutputIterator> inline _OutputIterator reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __first != __last; ++__result) 
                *__result = *--__last;
            return __result;
        }

;
        template <class _ForwardIterator> _ForwardIterator __rotate_left(_ForwardIterator __first, _ForwardIterator __last)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            value_type __tmp = std::__1::move(*__first);
            _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
            *__lm1 = std::__1::move(__tmp);
            return __lm1;
        }

;
        template <class _BidirectionalIterator> _BidirectionalIterator __rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)         {
            typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
            _BidirectionalIterator __lm1 = std::__1::prev(__last);
            value_type __tmp = std::__1::move(*__lm1);
            _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
            *__first = std::__1::move(__tmp);
            return __fp1;
        }

;
        template <class _ForwardIterator> _ForwardIterator __rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)         {
            _ForwardIterator __i = __middle;
            while (true)
                {
                    swap(*__first, *__i);
                    ++__first;
                    if (++__i == __last)
                        break;
                    if (__first == __middle)
                        __middle = __i;
                }
            _ForwardIterator __r = __first;
            if (__first != __middle) {
                __i = __middle;
                while (true)
                    {
                        swap(*__first, *__i);
                        ++__first;
                        if (++__i == __last) {
                            if (__first == __middle)
                                break;
                            __i = __middle;
                        } else if (__first == __middle)
                            __middle = __i;
                    }
            }
            return __r;
        }

;
        template <typename _Integral> inline _Integral __gcd(_Integral __x, _Integral __y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            do {
                _Integral __t = __x % __y;
                __x = __y;
                __y = __t;
            } while (__y);
            return __x;
        }

;
        template <typename _RandomAccessIterator> _RandomAccessIterator __rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            const difference_type __m1 = __middle - __first;
            const difference_type __m2 = __last - __middle;
            if (__m1 == __m2) {
                std::__1::swap_ranges(__first, __middle, __middle);
                return __middle;
            }
            const difference_type __g = std::__1::__gcd(__m1, __m2);
            for (_RandomAccessIterator __p = __first + __g; __p != __first;) {
                value_type __t(std::__1::move(*--__p));
                _RandomAccessIterator __p1 = __p;
                _RandomAccessIterator __p2 = __p1 + __m1;
                do {
                    *__p1 = std::__1::move(*__p2);
                    __p1 = __p2;
                    const difference_type __d = __last - __p2;
                    if (__m1 < __d)
                        __p2 += __m1;
                    else
                        __p2 = __first + (__m1 - __d);
                } while (__p2 != __p);
                *__p1 = std::__1::move(__t);
            }
            return __first + __m2;
        }

;
        template <class _ForwardIterator> inline _ForwardIterator __rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, std::__1::forward_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
            if (std::__1::is_trivially_move_assignable<value_type>::value) {
                if (std::__1::next(__first) == __middle)
                    return std::__1::__rotate_left(__first, __last);
            }
            return std::__1::__rotate_forward(__first, __middle, __last);
        }

;
        template <class _BidirectionalIterator> inline _BidirectionalIterator __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, std::__1::bidirectional_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type value_type;
            if (std::__1::is_trivially_move_assignable<value_type>::value) {
                if (std::__1::next(__first) == __middle)
                    return std::__1::__rotate_left(__first, __last);
                if (std::__1::next(__middle) == __last)
                    return std::__1::__rotate_right(__first, __last);
            }
            return std::__1::__rotate_forward(__first, __middle, __last);
        }

;
        template <class _RandomAccessIterator> inline _RandomAccessIterator __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, std::__1::random_access_iterator_tag) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type value_type;
            if (std::__1::is_trivially_move_assignable<value_type>::value) {
                if (std::__1::next(__first) == __middle)
                    return std::__1::__rotate_left(__first, __last);
                if (std::__1::next(__middle) == __last)
                    return std::__1::__rotate_right(__first, __last);
                return std::__1::__rotate_gcd(__first, __middle, __last);
            }
            return std::__1::__rotate_forward(__first, __middle, __last);
        }

;
        template <class _ForwardIterator> inline _ForwardIterator rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__first == __middle)
                return __last;
            if (__middle == __last)
                return __first;
            return std::__1::__rotate(__first, __middle, __last, typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
        }

;
        template <class _ForwardIterator, class _OutputIterator> inline _OutputIterator rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
        }

;
        template <class _ForwardIterator, class _Compare> inline _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    if (__comp(*__i, *__first))
                        __first = __i;
            }
            return __first;
        }

;
        template <class _ForwardIterator> inline _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::min_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }

;
        template <class _Tp, class _Compare> inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __comp(__b, __a) ? __b : __a;
        }

;
        template <class _Tp = unsigned long> inline const unsigned long &min(const unsigned long &__a, const unsigned long &__b) __attribute__((always_inline))template <class _Tp = long> inline const long &min(const long &__a, const long &__b) __attribute__((always_inline))template <class _Tp> inline const _Tp &min(const _Tp &__a, const _Tp &__b) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::min(__a, __b, __less<_Tp>());
        }

;
        template <class _Tp, class _Compare> inline _Tp min(initializer_list<_Tp> __t, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return *std::__1::min_element(__t.begin(), __t.end(), __comp);
        }

;
        template <class _Tp> inline _Tp min(initializer_list<_Tp> __t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return *std::__1::min_element(__t.begin(), __t.end(), __less<_Tp>());
        }

;
        template <class _ForwardIterator, class _Compare> inline _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    if (__comp(*__first, *__i))
                        __first = __i;
            }
            return __first;
        }

;
        template <class _ForwardIterator> inline _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::max_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }

;
        template <class _Tp, class _Compare> inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __comp(__a, __b) ? __b : __a;
        }

;
        template <class _Tp = long> inline const long &max(const long &__a, const long &__b) __attribute__((always_inline))template <class _Tp> inline const _Tp &max(const _Tp &__a, const _Tp &__b) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::max(__a, __b, __less<_Tp>());
        }

;
        template <class _Tp = long, class _Compare = unsigned long> inline long max(initializer_list<long> __t, unsigned long __comp) __attribute__((always_inline))template <class _Tp, class _Compare> inline _Tp max(initializer_list<_Tp> __t, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return *std::__1::max_element(__t.begin(), __t.end(), __comp);
        }

;
        template <class _Tp> inline _Tp max(initializer_list<_Tp> __t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return *std::__1::max_element(__t.begin(), __t.end(), __less<_Tp>());
        }

;
        template <class _ForwardIterator, class _Compare> std::pair<_ForwardIterator, _ForwardIterator> minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)         {
            std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
            if (__first != __last) {
                if (++__first != __last) {
                    if (__comp(*__first, *__result.first))
                        __result.first = __first;
                    else
                        __result.second = __first;
                    while (++__first != __last)
                        {
                            _ForwardIterator __i = __first;
                            if (++__first == __last) {
                                if (__comp(*__i, *__result.first))
                                    __result.first = __i;
                                else if (!__comp(*__i, *__result.second))
                                    __result.second = __i;
                                break;
                            } else {
                                if (__comp(*__first, *__i)) {
                                    if (__comp(*__first, *__result.first))
                                        __result.first = __first;
                                    if (!__comp(*__i, *__result.second))
                                        __result.second = __i;
                                } else {
                                    if (__comp(*__i, *__result.first))
                                        __result.first = __i;
                                    if (!__comp(*__first, *__result.second))
                                        __result.second = __first;
                                }
                            }
                        }
                }
            }
            return __result;
        }

;
        template <class _ForwardIterator> inline std::pair<_ForwardIterator, _ForwardIterator> minmax_element(_ForwardIterator __first, _ForwardIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::minmax_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }

;
        template <class _Tp, class _Compare> inline pair<const _Tp &, const _Tp &> minmax(const _Tp &__a, const _Tp &__b, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __comp(__b, __a) ? pair<const _Tp &, const _Tp &>(__b, __a) : pair<const _Tp &, const _Tp &>(__a, __b);
        }

;
        template <class _Tp> inline pair<const _Tp &, const _Tp &> minmax(const _Tp &__a, const _Tp &__b) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::minmax(__a, __b, __less<_Tp>());
        }

;
        template <class _Tp, class _Compare> inline pair<_Tp, _Tp> minmax(initializer_list<_Tp> __t, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename initializer_list<_Tp>::const_iterator _Iter;
            _Iter __first = __t.begin();
            _Iter __last = __t.end();
            std::pair<_Tp, _Tp> __result(*__first, *__first);
            ++__first;
            if (__t.size() % 2 == 0) {
                if (__comp(*__first, __result.first))
                    __result.first = *__first;
                else
                    __result.second = *__first;
                ++__first;
            }
            while (__first != __last)
                {
                    _Tp __prev = *__first++;
                    if (__comp(*__first, __prev)) {
                        if (__comp(*__first, __result.first))
                            __result.first = *__first;
                        if (!__comp(__prev, __result.second))
                            __result.second = __prev;
                    } else {
                        if (__comp(__prev, __result.first))
                            __result.first = __prev;
                        if (!__comp(*__first, __result.second))
                            __result.second = *__first;
                    }
                    __first++;
                }
            return __result;
        }

;
        template <class _Tp> inline pair<_Tp, _Tp> minmax(initializer_list<_Tp> __t) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::minmax(__t, __less<_Tp>());
        }

;
        template <unsigned long long _Xp, size_t _Rp> struct __log2_imp {
            static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp : __log2_imp<_Xp, _Rp - 1>::value;
        };
        struct __log2_imp {
            static const size_t value = 0;
        };
        struct __log2_imp {
            static const size_t value = _Rp + 1;
        };
        template <class _UI, _UI _Xp> struct __log2 {
            static const size_t value = __log2_imp<_Xp, sizeof(_UI) * 8 - 1>::value;
        };
        template <class _Engine, class _UIntType> class __independent_bits_engine {
        public:
            typedef _UIntType result_type;
        private:
            typedef typename _Engine::result_type _Engine_result_type;
            typedef typename conditional<sizeof(_Engine_result_type) <= sizeof(result_type), result_type, _Engine_result_type>::type _Working_result_type;
            _Engine &__e_;
            size_t __w_;
            size_t __w0_;
            size_t __n_;
            size_t __n0_;
            _Working_result_type __y0_;
            _Working_result_type __y1_;
            _Engine_result_type __mask0_;
            _Engine_result_type __mask1_;
            static const _Working_result_type _Rp = _Engine::max() - _Engine::min() + _Working_result_type(1);
            static const size_t __m = __log2<_Working_result_type, _Rp>::value;
            static const size_t _WDt = numeric_limits<_Working_result_type>::digits;
            static const size_t _EDt = numeric_limits<_Engine_result_type>::digits;
        public:
            __independent_bits_engine<_Engine, _UIntType>(_Engine &__e, size_t __w);
            result_type operator()()             {
                return __eval(integral_constant<bool, _Rp != 0>());
            }


        private:
            result_type __eval(false_type);
            result_type __eval(true_type);
        };
        __independent_bits_engine<_Engine, _UIntType>(_Engine &__e, size_t __w) : __e_(__e), __w_(__w)         {
            this->__n_ = this->__w_ / __m + (this->__w_ % __m != 0);
            this->__w0_ = this->__w_ / this->__n_;
            if (_Rp == 0)
                this->__y0_ = _Rp;
            else if (this->__w0_ < _WDt)
                this->__y0_ = (_Rp >> this->__w0_) << this->__w0_;
            else
                this->__y0_ = 0;
            if (_Rp - this->__y0_ > this->__y0_ / this->__n_) {
                ++this->__n_;
                this->__w0_ = this->__w_ / this->__n_;
                if (this->__w0_ < _WDt)
                    this->__y0_ = (_Rp >> this->__w0_) << this->__w0_;
                else
                    this->__y0_ = 0;
            }
            this->__n0_ = this->__n_ - this->__w_ % this->__n_;
            if (this->__w0_ < _WDt - 1)
                this->__y1_ = (_Rp >> (this->__w0_ + 1)) << (this->__w0_ + 1);
            else
                this->__y1_ = 0;
            this->__mask0_ = this->__w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - this->__w0_) : _Engine_result_type(0);
            this->__mask1_ = this->__w0_ < _EDt - 1 ? _Engine_result_type(~0) >> (_EDt - (this->__w0_ + 1)) : _Engine_result_type(~0);
        }


        inline _UIntType __eval(false_type)         {
            return static_cast<result_type>(this->__e_() & this->__mask0_);
        }


        _UIntType __eval(true_type)         {
            result_type _Sp = 0;
            for (size_t __k = 0; __k < this->__n0_; ++__k) {
                _Engine_result_type __u;
                do {
                    __u = this->__e_() - _Engine::min();
                } while (__u >= this->__y0_);
                if (this->__w0_ < _WDt)
                    _Sp <<= this->__w0_;
                else
                    _Sp = 0;
                _Sp += __u & this->__mask0_;
            }
            for (size_t __k = this->__n0_; __k < this->__n_; ++__k) {
                _Engine_result_type __u;
                do {
                    __u = this->__e_() - _Engine::min();
                } while (__u >= this->__y1_);
                if (this->__w0_ < _WDt - 1)
                    _Sp <<= this->__w0_ + 1;
                else
                    _Sp = 0;
                _Sp += __u & this->__mask1_;
            }
            return _Sp;
        }


        template <class _IntType = long> class uniform_int_distribution {
        public:
            typedef long result_type;
            class param_type {
                result_type __a_;
                result_type __b_;
            public:
                typedef std::__1::uniform_int_distribution<long> distribution_type;
                explicit param_type(result_type __a, result_type __b);
                result_type a() const;
                result_type b() const;
                friend bool operator==(const std::__1::uniform_int_distribution<long>::param_type &__x, const std::__1::uniform_int_distribution<long>::param_type &__y);
                friend bool operator!=(const std::__1::uniform_int_distribution<long>::param_type &__x, const std::__1::uniform_int_distribution<long>::param_type &__y);
            };
        private:
            std::__1::uniform_int_distribution<long>::param_type __p_;
        public:
            explicit uniform_int_distribution(result_type __a = 0, result_type __b = numeric_limits<result_type>::max());
            explicit uniform_int_distribution(const std::__1::uniform_int_distribution<long>::param_type &__p);
            void reset();
            template <class _URNG> result_type operator()(_URNG &__g);
            template <class _URNG = std::__1::__rs_default> result_type operator()(std::__1::__rs_default &__g, const std::__1::uniform_int_distribution<long>::param_type &__p)template <class _URNG> result_type operator()(_URNG &__g, const std::__1::uniform_int_distribution<long>::param_type &__p);
            result_type a() const;
            result_type b() const;
            std::__1::uniform_int_distribution<long>::param_type param() const;
            void param(const std::__1::uniform_int_distribution<long>::param_type &__p);
            result_type min() const;
            result_type max() const;
            friend bool operator==(const std::__1::uniform_int_distribution<long> &__x, const std::__1::uniform_int_distribution<long> &__y);
            friend bool operator!=(const std::__1::uniform_int_distribution<long> &__x, const std::__1::uniform_int_distribution<long> &__y);
        }
template <class _IntType = int> class uniform_int_distribution {
        public:
            typedef _IntType result_type;
            class param_type {
                result_type __a_;
                result_type __b_;
            public:
                typedef uniform_int_distribution<_IntType> distribution_type;
                explicit param_type(result_type __a = 0, result_type __b = numeric_limits<result_type>::max()) : __a_(__a), __b_(__b)                 {
                }


                result_type a() const                 {
                    return this->__a_;
                }


                result_type b() const                 {
                    return this->__b_;
                }


                friend bool operator==(const std::__1::uniform_int_distribution::param_type &__x, const std::__1::uniform_int_distribution::param_type &__y)                 {
                    return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;
                }

;
                friend bool operator!=(const std::__1::uniform_int_distribution::param_type &__x, const std::__1::uniform_int_distribution::param_type &__y)                 {
                    return !(__x == __y);
                }

;
            };
        private:
            std::__1::uniform_int_distribution::param_type __p_;
        public:
            explicit uniform_int_distribution<_IntType>(result_type __a = 0, result_type __b = numeric_limits<result_type>::max()) : __p_(std::__1::uniform_int_distribution::param_type(__a, __b))             {
            }


            explicit uniform_int_distribution<_IntType>(const std::__1::uniform_int_distribution::param_type &__p) : __p_(__p)             {
            }


            void reset()             {
            }


            template <class _URNG> result_type operator()(_URNG &__g)             {
                return (*this)(__g, this->__p_);
            }

;
            template <class _URNG> result_type operator()(_URNG &__g, const std::__1::uniform_int_distribution::param_type &__p);
            result_type a() const             {
                return this->__p_.a();
            }


            result_type b() const             {
                return this->__p_.b();
            }


            std::__1::uniform_int_distribution::param_type param() const             {
                return this->__p_;
            }


            void param(const std::__1::uniform_int_distribution::param_type &__p)             {
                this->__p_ = __p;
            }


            result_type min() const             {
                return this->a();
            }


            result_type max() const             {
                return this->b();
            }


            friend bool operator==(const uniform_int_distribution<_IntType> &__x, const uniform_int_distribution<_IntType> &__y)             {
                return __x.__p_ == __y.__p_;
            }

;
            friend bool operator!=(const uniform_int_distribution<_IntType> &__x, const uniform_int_distribution<_IntType> &__y)             {
                return !(__x == __y);
            }

;
        };
        template <class _URNG> typename uniform_int_distribution<_IntType>::result_type operator()(_URNG &__g, const std::__1::uniform_int_distribution::param_type &__p)         {
            typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t), uint32_t, uint64_t>::type _UIntType;
            const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
            if (_Rp == 1)
                return __p.a();
            const size_t _Dt = numeric_limits<_UIntType>::digits;
            typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
            if (_Rp == 0)
                return static_cast<result_type>(_Eng(__g, _Dt)());
            size_t __w = _Dt - __clz(_Rp) - 1;
            if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
                ++__w;
            _Eng __e(__g, __w);
            _UIntType __u;
            do {
                __u = __e();
            } while (__u >= _Rp);
            return static_cast<result_type>(__u + __p.a());
        }

;
        class __attribute__((type_visibility("default"))) __rs_default;
        std::__1::__rs_default __rs_get() __attribute__((visibility("default")));
        class __attribute__((type_visibility("default"))) __rs_default {
            static unsigned int __c_;
            __rs_default();
        public:
            typedef uint_fast32_t result_type;
            static const result_type _Min = 0;
            static const result_type _Max = 4294967295U;
            __rs_default(const std::__1::__rs_default &);
            ~std::__1::__rs_default();
            result_type operator()();
            static constexpr result_type min()             {
                return _Min;
            }


            static constexpr result_type max()             {
                return _Max;
            }


            friend std::__1::__rs_default __rs_get() __attribute__((visibility("default")));
        };
        std::__1::__rs_default __rs_get() __attribute__((visibility("default")));
        template <class _RandomAccessIterator> void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef uniform_int_distribution<ptrdiff_t> _Dp;
            typedef typename _Dp::param_type _Pp;
            difference_type __d = __last - __first;
            if (__d > 1) {
                _Dp __uid;
                std::__1::__rs_default __g = __rs_get();
                for (--__last , --__d; __first < __last; ++__first , --__d) {
                    difference_type __i = __uid(__g, _Pp(0, __d));
                    if (__i != difference_type(0))
                        swap(*__first, *(__first + __i));
                }
            }
        }

;
        template <class _RandomAccessIterator, class _RandomNumberGenerator> void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &&__rand)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            difference_type __d = __last - __first;
            if (__d > 1) {
                for (--__last; __first < __last; ++__first , --__d) {
                    difference_type __i = __rand(__d);
                    swap(*__first, *(__first + __i));
                }
            }
        }

;
        template <class _RandomAccessIterator, class _UniformRandomNumberGenerator> void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator &&__g)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef uniform_int_distribution<ptrdiff_t> _Dp;
            typedef typename _Dp::param_type _Pp;
            difference_type __d = __last - __first;
            if (__d > 1) {
                _Dp __uid;
                for (--__last , --__d; __first < __last; ++__first , --__d) {
                    difference_type __i = __uid(__g, _Pp(0, __d));
                    if (__i != difference_type(0))
                        swap(*__first, *(__first + __i));
                }
            }
        }

;
        template <class _InputIterator, class _Predicate> bool is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)         {
            for (; __first != __last; ++__first) 
                if (!__pred(*__first))
                    break;
            if (__first == __last)
                return true;
            ++__first;
            for (; __first != __last; ++__first) 
                if (__pred(*__first))
                    return false;
            return true;
        }

;
        template <class _Predicate, class _ForwardIterator> _ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, std::__1::forward_iterator_tag)         {
            while (true)
                {
                    if (__first == __last)
                        return __first;
                    if (!__pred(*__first))
                        break;
                    ++__first;
                }
            for (_ForwardIterator __p = __first; ++__p != __last;) {
                if (__pred(*__p)) {
                    swap(*__first, *__p);
                    ++__first;
                }
            }
            return __first;
        }

;
        template <class _Predicate, class _BidirectionalIterator> _BidirectionalIterator __partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, std::__1::bidirectional_iterator_tag)         {
            while (true)
                {
                    while (true)
                        {
                            if (__first == __last)
                                return __first;
                            if (!__pred(*__first))
                                break;
                            ++__first;
                        }
                    do {
                        if (__first == --__last)
                            return __first;
                    } while (!__pred(*__last));
                    swap(*__first, *__last);
                    ++__first;
                }
        }

;
        template <class _ForwardIterator, class _Predicate> inline _ForwardIterator partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
        }

;
        template <class _InputIterator, class _OutputIterator1, class _OutputIterator2, class _Predicate> pair<_OutputIterator1, _OutputIterator2> partition_copy(_InputIterator __first, _InputIterator __last, _OutputIterator1 __out_true, _OutputIterator2 __out_false, _Predicate __pred)         {
            for (; __first != __last; ++__first) {
                if (__pred(*__first)) {
                    *__out_true = *__first;
                    ++__out_true;
                } else {
                    *__out_false = *__first;
                    ++__out_false;
                }
            }
            return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
        }

;
        template <class _ForwardIterator, class _Predicate> _ForwardIterator partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)         {
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            difference_type __len = std::__1::distance(__first, __last);
            while (__len != 0)
                {
                    difference_type __l2 = __len / 2;
                    _ForwardIterator __m = __first;
                    std::__1::advance(__m, __l2);
                    if (__pred(*__m)) {
                        __first = ++__m;
                        __len -= __l2 + 1;
                    } else
                        __len = __l2;
                }
            return __first;
        }

;
        template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair> _ForwardIterator __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pair __p, std::__1::forward_iterator_tag __fit)         {
            if (__len == 1)
                return __first;
            if (__len == 2) {
                _ForwardIterator __m = __first;
                if (__pred(*++__m)) {
                    swap(*__first, *__m);
                    return __m;
                }
                return __first;
            }
            if (__len <= __p.second) {
                typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h(__p.first, __d);
                value_type *__t = __p.first;
                ::new (__t) value_type((std::__1::move(*__first)));
                __d.__incr((value_type *)0);
                ++__t;
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (__pred(*__i)) {
                            *__first = std::__1::move(*__i);
                            ++__first;
                        } else {
                            ::new (__t) value_type((std::__1::move(*__i)));
                            __d.__incr((value_type *)0);
                            ++__t;
                        }
                    }
                __i = __first;
                for (value_type *__t2 = __p.first; __t2 < __t; ++__t2 , ++__i) 
                    *__i = std::__1::move(*__t2);
                return __first;
            }
            _ForwardIterator __m = __first;
            _Distance __len2 = __len / 2;
            std::__1::advance(__m, __len2);
            typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
            _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);
            _ForwardIterator __m1 = __m;
            _ForwardIterator __second_false = __last;
            _Distance __len_half = __len - __len2;
            while (__pred(*__m1))
                {
                    if (++__m1 == __last)
                        goto __second_half_done;
                    --__len_half;
                }
            __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
          __second_half_done:
            return std::__1::rotate(__first_false, __m, __second_false);
        }

;
        struct __return_temporary_buffer {
            template <class _Tp> void operator()(_Tp *__p) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::return_temporary_buffer(__p);
            }

;
        };
        template <class _Predicate, class _ForwardIterator> _ForwardIterator __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, std::__1::forward_iterator_tag)         {
            const unsigned int __alloc_limit = 3;
            while (true)
                {
                    if (__first == __last)
                        return __first;
                    if (!__pred(*__first))
                        break;
                    ++__first;
                }
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            difference_type __len = std::__1::distance(__first, __last);
            pair<value_type *, ptrdiff_t> __p(0, 0);
            unique_ptr<value_type, std::__1::__return_temporary_buffer> __h;
            if (__len >= __alloc_limit) {
                __p = std::__1::get_temporary_buffer<value_type>(__len);
                __h.reset(__p.first);
            }
            return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred, __len, __p, std::__1::forward_iterator_tag());
        }

;
        template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair> _BidirectionalIterator __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, _Distance __len, _Pair __p, std::__1::bidirectional_iterator_tag __bit)         {
            if (__len == 2) {
                swap(*__first, *__last);
                return __last;
            }
            if (__len == 3) {
                _BidirectionalIterator __m = __first;
                if (__pred(*++__m)) {
                    swap(*__first, *__m);
                    swap(*__m, *__last);
                    return __last;
                }
                swap(*__m, *__last);
                swap(*__first, *__m);
                return __m;
            }
            if (__len <= __p.second) {
                typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h(__p.first, __d);
                value_type *__t = __p.first;
                ::new (__t) value_type((std::__1::move(*__first)));
                __d.__incr((value_type *)0);
                ++__t;
                _BidirectionalIterator __i = __first;
                while (++__i != __last)
                    {
                        if (__pred(*__i)) {
                            *__first = std::__1::move(*__i);
                            ++__first;
                        } else {
                            ::new (__t) value_type((std::__1::move(*__i)));
                            __d.__incr((value_type *)0);
                            ++__t;
                        }
                    }
                *__first = std::__1::move(*__i);
                __i = ++__first;
                for (value_type *__t2 = __p.first; __t2 < __t; ++__t2 , ++__i) 
                    *__i = std::__1::move(*__t2);
                return __first;
            }
            _BidirectionalIterator __m = __first;
            _Distance __len2 = __len / 2;
            std::__1::advance(__m, __len2);
            _BidirectionalIterator __m1 = __m;
            _BidirectionalIterator __first_false = __first;
            _Distance __len_half = __len2;
            while (!__pred(*--__m1))
                {
                    if (__m1 == __first)
                        goto __first_half_done;
                    --__len_half;
                }
            typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
            __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
          __first_half_done:
            __m1 = __m;
            _BidirectionalIterator __second_false = __last;
            ++__second_false;
            __len_half = __len - __len2;
            while (__pred(*__m1))
                {
                    if (++__m1 == __last)
                        goto __second_half_done;
                    --__len_half;
                }
            __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
          __second_half_done:
            return std::__1::rotate(__first_false, __m, __second_false);
        }

;
        template <class _Predicate, class _BidirectionalIterator> _BidirectionalIterator __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, std::__1::bidirectional_iterator_tag)         {
            typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
            typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
            const difference_type __alloc_limit = 4;
            while (true)
                {
                    if (__first == __last)
                        return __first;
                    if (!__pred(*__first))
                        break;
                    ++__first;
                }
            do {
                if (__first == --__last)
                    return __first;
            } while (!__pred(*__last));
            difference_type __len = std::__1::distance(__first, __last) + 1;
            pair<value_type *, ptrdiff_t> __p(0, 0);
            unique_ptr<value_type, std::__1::__return_temporary_buffer> __h;
            if (__len >= __alloc_limit) {
                __p = std::__1::get_temporary_buffer<value_type>(__len);
                __h.reset(__p.first);
            }
            return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred, __len, __p, std::__1::bidirectional_iterator_tag());
        }

;
        template <class _ForwardIterator, class _Predicate> inline _ForwardIterator stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
        }

;
        template <class _ForwardIterator, class _Compare> _ForwardIterator is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)         {
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (__comp(*__i, *__first))
                            return __i;
                        __first = __i;
                    }
            }
            return __last;
        }

;
        template <class _ForwardIterator> inline _ForwardIterator is_sorted_until(_ForwardIterator __first, _ForwardIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }

;
        template <class _ForwardIterator, class _Compare> inline bool is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::is_sorted_until(__first, __last, __comp) == __last;
        }

;
        template <class _ForwardIterator> inline bool is_sorted(_ForwardIterator __first, _ForwardIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }

;
        template <class _Compare, class _ForwardIterator> unsigned int __sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)         {
            unsigned int __r = 0;
            if (!__c(*__y, *__x)) {
                if (!__c(*__z, *__y))
                    return __r;
                swap(*__y, *__z);
                __r = 1;
                if (__c(*__y, *__x)) {
                    swap(*__x, *__y);
                    __r = 2;
                }
                return __r;
            }
            if (__c(*__z, *__y)) {
                swap(*__x, *__z);
                __r = 1;
                return __r;
            }
            swap(*__x, *__y);
            __r = 1;
            if (__c(*__z, *__y)) {
                swap(*__y, *__z);
                __r = 2;
            }
            return __r;
        }

;
        template <class _Compare, class _ForwardIterator> unsigned int __sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _Compare __c)         {
            unsigned int __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
            if (__c(*__x4, *__x3)) {
                swap(*__x3, *__x4);
                ++__r;
                if (__c(*__x3, *__x2)) {
                    swap(*__x2, *__x3);
                    ++__r;
                    if (__c(*__x2, *__x1)) {
                        swap(*__x1, *__x2);
                        ++__r;
                    }
                }
            }
            return __r;
        }

;
        template <class _Compare = std::__1::__less<long double, long double> &, class _ForwardIterator = long double *> unsigned int __sort5(long double *__x1, long double *__x2, long double *__x3, long double *__x4, long double *__x5, std::__1::__less<long double, long double> &__c) __attribute__((visibility("default")))template <class _Compare, class _ForwardIterator> unsigned int __sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)         {
            unsigned int __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
            if (__c(*__x5, *__x4)) {
                swap(*__x4, *__x5);
                ++__r;
                if (__c(*__x4, *__x3)) {
                    swap(*__x3, *__x4);
                    ++__r;
                    if (__c(*__x3, *__x2)) {
                        swap(*__x2, *__x3);
                        ++__r;
                        if (__c(*__x2, *__x1)) {
                            swap(*__x1, *__x2);
                            ++__r;
                        }
                    }
                }
            }
            return __r;
        }

;
        template <class _Compare, class _BirdirectionalIterator> void __selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)         {
            _BirdirectionalIterator __lm1 = __last;
            for (--__lm1; __first != __lm1; ++__first) {
                _BirdirectionalIterator __i = std::__1::min_element<_BirdirectionalIterator, typename add_lvalue_reference<_Compare>::type>(__first, __last, __comp);
                if (__i != __first)
                    swap(*__first, *__i);
            }
        }

;
        template <class _Compare, class _BirdirectionalIterator> void __insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
            if (__first != __last) {
                _BirdirectionalIterator __i = __first;
                for (++__i; __i != __last; ++__i) {
                    _BirdirectionalIterator __j = __i;
                    value_type __t(std::__1::move(*__j));
                    for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j) 
                        *__j = std::__1::move(*__k);
                    *__j = std::__1::move(__t);
                }
            }
        }

;
        template <class _Compare, class _RandomAccessIterator> void __insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            _RandomAccessIterator __j = __first + 2;
            __sort3<_Compare>(__first, __first + 1, __j, __comp);
            for (_RandomAccessIterator __i = __j + 1; __i != __last; ++__i) {
                if (__comp(*__i, *__j)) {
                    value_type __t(std::__1::move(*__i));
                    _RandomAccessIterator __k = __j;
                    __j = __i;
                    do {
                        *__j = std::__1::move(*__k);
                        __j = __k;
                    } while (__j != __first && __comp(__t, *--__k));
                    *__j = std::__1::move(__t);
                }
                __j = __i;
            }
        }

;
        template <class _Compare = std::__1::__less<char, char> &, class _RandomAccessIterator = char *> bool __insertion_sort_incomplete(char *__first, char *__last, std::__1::__less<char, char> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<wchar_t, wchar_t> &, class _RandomAccessIterator = wchar_t *> bool __insertion_sort_incomplete(wchar_t *__first, wchar_t *__last, std::__1::__less<wchar_t, wchar_t> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<signed char, signed char> &, class _RandomAccessIterator = signed char *> bool __insertion_sort_incomplete(signed char *__first, signed char *__last, std::__1::__less<signed char, signed char> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned char, unsigned char> &, class _RandomAccessIterator = unsigned char *> bool __insertion_sort_incomplete(unsigned char *__first, unsigned char *__last, std::__1::__less<unsigned char, unsigned char> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<short, short> &, class _RandomAccessIterator = short *> bool __insertion_sort_incomplete(short *__first, short *__last, std::__1::__less<short, short> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned short, unsigned short> &, class _RandomAccessIterator = unsigned short *> bool __insertion_sort_incomplete(unsigned short *__first, unsigned short *__last, std::__1::__less<unsigned short, unsigned short> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<int, int> &, class _RandomAccessIterator = int *> bool __insertion_sort_incomplete(int *__first, int *__last, std::__1::__less<int, int> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned int, unsigned int> &, class _RandomAccessIterator = unsigned int *> bool __insertion_sort_incomplete(unsigned int *__first, unsigned int *__last, std::__1::__less<unsigned int, unsigned int> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<long, long> &, class _RandomAccessIterator = long *> bool __insertion_sort_incomplete(long *__first, long *__last, std::__1::__less<long, long> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned long, unsigned long> &, class _RandomAccessIterator = unsigned long *> bool __insertion_sort_incomplete(unsigned long *__first, unsigned long *__last, std::__1::__less<unsigned long, unsigned long> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<long long, long long> &, class _RandomAccessIterator = long long *> bool __insertion_sort_incomplete(long long *__first, long long *__last, std::__1::__less<long long, long long> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned long long, unsigned long long> &, class _RandomAccessIterator = unsigned long long *> bool __insertion_sort_incomplete(unsigned long long *__first, unsigned long long *__last, std::__1::__less<unsigned long long, unsigned long long> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<float, float> &, class _RandomAccessIterator = float *> bool __insertion_sort_incomplete(float *__first, float *__last, std::__1::__less<float, float> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<double, double> &, class _RandomAccessIterator = double *> bool __insertion_sort_incomplete(double *__first, double *__last, std::__1::__less<double, double> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<long double, long double> &, class _RandomAccessIterator = long double *> bool __insertion_sort_incomplete(long double *__first, long double *__last, std::__1::__less<long double, long double> &__comp) __attribute__((visibility("default")))template <class _Compare, class _RandomAccessIterator> bool __insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            switch (__last - __first) {
              case 0:
              case 1:
                return true;
              case 2:
                if (__comp(*--__last, *__first))
                    swap(*__first, *__last);
                return true;
              case 3:
                std::__1::__sort3<_Compare>(__first, __first + 1, --__last, __comp);
                return true;
              case 4:
                std::__1::__sort4<_Compare>(__first, __first + 1, __first + 2, --__last, __comp);
                return true;
              case 5:
                std::__1::__sort5<_Compare>(__first, __first + 1, __first + 2, __first + 3, --__last, __comp);
                return true;
            }
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            _RandomAccessIterator __j = __first + 2;
            __sort3<_Compare>(__first, __first + 1, __j, __comp);
            const unsigned int __limit = 8;
            unsigned int __count = 0;
            for (_RandomAccessIterator __i = __j + 1; __i != __last; ++__i) {
                if (__comp(*__i, *__j)) {
                    value_type __t(std::__1::move(*__i));
                    _RandomAccessIterator __k = __j;
                    __j = __i;
                    do {
                        *__j = std::__1::move(*__k);
                        __j = __k;
                    } while (__j != __first && __comp(__t, *--__k));
                    *__j = std::__1::move(__t);
                    if (++__count == __limit)
                        return ++__i == __last;
                }
                __j = __i;
            }
            return true;
        }

;
        template <class _Compare, class _BirdirectionalIterator> void __insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1, typename iterator_traits<_BirdirectionalIterator>::value_type *__first2, _Compare __comp)         {
            typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
            if (__first1 != __last1) {
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h(__first2, __d);
                value_type *__last2 = __first2;
                ::new (__last2) value_type((std::__1::move(*__first1)));
                __d.__incr((value_type *)0);
                for (++__last2; ++__first1 != __last1; ++__last2) {
                    value_type *__j2 = __last2;
                    value_type *__i2 = __j2;
                    if (__comp(*__first1, *--__i2)) {
                        ::new (__j2) value_type((std::__1::move(*__i2)));
                        __d.__incr((value_type *)0);
                        for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2) 
                            *__j2 = std::__1::move(*__i2);
                        *__j2 = std::__1::move(*__first1);
                    } else {
                        ::new (__j2) value_type((std::__1::move(*__first1)));
                        __d.__incr((value_type *)0);
                    }
                }
                __h.release();
            }
        }

;
        template <class _Compare = std::__1::__less<char, char> &, class _RandomAccessIterator = char *> void __sort(char *__first, char *__last, std::__1::__less<char, char> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<wchar_t, wchar_t> &, class _RandomAccessIterator = wchar_t *> void __sort(wchar_t *__first, wchar_t *__last, std::__1::__less<wchar_t, wchar_t> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<signed char, signed char> &, class _RandomAccessIterator = signed char *> void __sort(signed char *__first, signed char *__last, std::__1::__less<signed char, signed char> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned char, unsigned char> &, class _RandomAccessIterator = unsigned char *> void __sort(unsigned char *__first, unsigned char *__last, std::__1::__less<unsigned char, unsigned char> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<short, short> &, class _RandomAccessIterator = short *> void __sort(short *__first, short *__last, std::__1::__less<short, short> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned short, unsigned short> &, class _RandomAccessIterator = unsigned short *> void __sort(unsigned short *__first, unsigned short *__last, std::__1::__less<unsigned short, unsigned short> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<int, int> &, class _RandomAccessIterator = int *> void __sort(int *__first, int *__last, std::__1::__less<int, int> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned int, unsigned int> &, class _RandomAccessIterator = unsigned int *> void __sort(unsigned int *__first, unsigned int *__last, std::__1::__less<unsigned int, unsigned int> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<long, long> &, class _RandomAccessIterator = long *> void __sort(long *__first, long *__last, std::__1::__less<long, long> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned long, unsigned long> &, class _RandomAccessIterator = unsigned long *> void __sort(unsigned long *__first, unsigned long *__last, std::__1::__less<unsigned long, unsigned long> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<long long, long long> &, class _RandomAccessIterator = long long *> void __sort(long long *__first, long long *__last, std::__1::__less<long long, long long> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<unsigned long long, unsigned long long> &, class _RandomAccessIterator = unsigned long long *> void __sort(unsigned long long *__first, unsigned long long *__last, std::__1::__less<unsigned long long, unsigned long long> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<float, float> &, class _RandomAccessIterator = float *> void __sort(float *__first, float *__last, std::__1::__less<float, float> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<double, double> &, class _RandomAccessIterator = double *> void __sort(double *__first, double *__last, std::__1::__less<double, double> &__comp) __attribute__((visibility("default")))template <class _Compare = std::__1::__less<long double, long double> &, class _RandomAccessIterator = long double *> void __sort(long double *__first, long double *__last, std::__1::__less<long double, long double> &__comp) __attribute__((visibility("default")))template <class _Compare, class _RandomAccessIterator> void __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            const difference_type __limit = is_trivially_copy_constructible<value_type>::value && is_trivially_copy_assignable<value_type>::value ? 30 : 6;
            while (true)
                {
                  __restart:
                    difference_type __len = __last - __first;
                    switch (__len) {
                      case 0:
                      case 1:
                        return;
                      case 2:
                        if (__comp(*--__last, *__first))
                            swap(*__first, *__last);
                        return;
                      case 3:
                        std::__1::__sort3<_Compare>(__first, __first + 1, --__last, __comp);
                        return;
                      case 4:
                        std::__1::__sort4<_Compare>(__first, __first + 1, __first + 2, --__last, __comp);
                        return;
                      case 5:
                        std::__1::__sort5<_Compare>(__first, __first + 1, __first + 2, __first + 3, --__last, __comp);
                        return;
                    }
                    if (__len <= __limit) {
                        std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
                        return;
                    }
                    _RandomAccessIterator __m = __first;
                    _RandomAccessIterator __lm1 = __last;
                    --__lm1;
                    unsigned int __n_swaps;
                    {
                        difference_type __delta;
                        if (__len >= 1000) {
                            __delta = __len / 2;
                            __m += __delta;
                            __delta /= 2;
                            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m + __delta, __lm1, __comp);
                        } else {
                            __delta = __len / 2;
                            __m += __delta;
                            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
                        }
                    }
                    _RandomAccessIterator __i = __first;
                    _RandomAccessIterator __j = __lm1;
                    if (!__comp(*__i, *__m)) {
                        while (true)
                            {
                                if (__i == --__j) {
                                    ++__i;
                                    __j = __last;
                                    if (!__comp(*__first, *--__j)) {
                                        while (true)
                                            {
                                                if (__i == __j)
                                                    return;
                                                if (__comp(*__first, *__i)) {
                                                    swap(*__i, *__j);
                                                    ++__n_swaps;
                                                    ++__i;
                                                    break;
                                                }
                                                ++__i;
                                            }
                                    }
                                    if (__i == __j)
                                        return;
                                    while (true)
                                        {
                                            while (!__comp(*__first, *__i))
                                                ++__i;
                                            while (__comp(*__first, *--__j))
                                                ;
                                            if (__i >= __j)
                                                break;
                                            swap(*__i, *__j);
                                            ++__n_swaps;
                                            ++__i;
                                        }
                                    __first = __i;
                                    goto __restart;
                                }
                                if (__comp(*__j, *__m)) {
                                    swap(*__i, *__j);
                                    ++__n_swaps;
                                    break;
                                }
                            }
                    }
                    ++__i;
                    if (__i < __j) {
                        while (true)
                            {
                                while (__comp(*__i, *__m))
                                    ++__i;
                                while (!__comp(*--__j, *__m))
                                    ;
                                if (__i > __j)
                                    break;
                                swap(*__i, *__j);
                                ++__n_swaps;
                                if (__m == __i)
                                    __m = __j;
                                ++__i;
                            }
                    }
                    if (__i != __m && __comp(*__m, *__i)) {
                        swap(*__i, *__m);
                        ++__n_swaps;
                    }
                    if (__n_swaps == 0) {
                        bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
                        if (std::__1::__insertion_sort_incomplete<_Compare>(__i + 1, __last, __comp)) {
                            if (__fs)
                                return;
                            __last = __i;
                            continue;
                        } else {
                            if (__fs) {
                                __first = ++__i;
                                continue;
                            }
                        }
                    }
                    if (__i - __first < __last - __i) {
                        std::__1::__sort<_Compare>(__first, __i, __comp);
                        __first = ++__i;
                    } else {
                        std::__1::__sort<_Compare>(__i + 1, __last, __comp);
                        __last = __i;
                    }
                }
        }

;
        template <class _RandomAccessIterator = unsigned long *, class _Compare = std::__1::__less<unsigned long, unsigned long>> inline void sort(unsigned long *__first, unsigned long *__last, std::__1::__less<unsigned long, unsigned long> __comp) __attribute__((always_inline))template <class _RandomAccessIterator, class _Compare> inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            __sort<_Comp_ref>(__first, __last, __comp);
        }

;
        template <class _RandomAccessIterator> inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _Tp> inline void sort(_Tp **__first, _Tp **__last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::sort((size_t *)__first, (size_t *)__last, __less<size_t>());
        }

;
        template <class _Tp> inline void sort(__wrap_iter<_Tp *> __first, __wrap_iter<_Tp *> __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::sort(__first.base(), __last.base());
        }

;
        template <class _Tp, class _Compare> inline void sort(__wrap_iter<_Tp *> __first, __wrap_iter<_Tp *> __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            std::__1::sort<_Tp *, _Comp_ref>(__first.base(), __last.base(), __comp);
        }

;
        template <class _Compare, class _ForwardIterator, class _Tp> _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp)         {
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            difference_type __len = std::__1::distance(__first, __last);
            while (__len != 0)
                {
                    difference_type __l2 = __len / 2;
                    _ForwardIterator __m = __first;
                    std::__1::advance(__m, __l2);
                    if (__comp(*__m, __value_)) {
                        __first = ++__m;
                        __len -= __l2 + 1;
                    } else
                        __len = __l2;
                }
            return __first;
        }

;
        template <class _ForwardIterator, class _Tp, class _Compare> inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);
        }

;
        template <class _ForwardIterator, class _Tp> inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::lower_bound(__first, __last, __value_, __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
        }

;
        template <class _Compare, class _ForwardIterator, class _Tp> _ForwardIterator __upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp)         {
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            difference_type __len = std::__1::distance(__first, __last);
            while (__len != 0)
                {
                    difference_type __l2 = __len / 2;
                    _ForwardIterator __m = __first;
                    std::__1::advance(__m, __l2);
                    if (__comp(__value_, *__m))
                        __len = __l2;
                    else {
                        __first = ++__m;
                        __len -= __l2 + 1;
                    }
                }
            return __first;
        }

;
        template <class _ForwardIterator, class _Tp, class _Compare> inline _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);
        }

;
        template <class _ForwardIterator, class _Tp> inline _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::upper_bound(__first, __last, __value_, __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
        }

;
        template <class _Compare, class _ForwardIterator, class _Tp> pair<_ForwardIterator, _ForwardIterator> __equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp)         {
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            difference_type __len = std::__1::distance(__first, __last);
            while (__len != 0)
                {
                    difference_type __l2 = __len / 2;
                    _ForwardIterator __m = __first;
                    std::__1::advance(__m, __l2);
                    if (__comp(*__m, __value_)) {
                        __first = ++__m;
                        __len -= __l2 + 1;
                    } else if (__comp(__value_, *__m)) {
                        __last = __m;
                        __len = __l2;
                    } else {
                        _ForwardIterator __mp1 = __m;
                        return pair<_ForwardIterator, _ForwardIterator>(__lower_bound<_Compare>(__first, __m, __value_, __comp), __upper_bound<_Compare>(++__mp1, __last, __value_, __comp));
                    }
                }
            return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
        }

;
        template <class _ForwardIterator, class _Tp, class _Compare> inline pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);
        }

;
        template <class _ForwardIterator, class _Tp> inline pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::equal_range(__first, __last, __value_, __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
        }

;
        template <class _Compare, class _ForwardIterator, class _Tp> inline bool __binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
            return __first != __last && !__comp(__value_, *__first);
        }

;
        template <class _ForwardIterator, class _Tp, class _Compare> inline bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);
        }

;
        template <class _ForwardIterator, class _Tp> inline bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::binary_search(__first, __last, __value_, __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            for (; __first1 != __last1; ++__result) {
                if (__first2 == __last2)
                    return std::__1::copy(__first1, __last1, __result);
                if (__comp(*__first2, *__first1)) {
                    *__result = *__first2;
                    ++__first2;
                } else {
                    *__result = *__first1;
                    ++__first1;
                }
            }
            return std::__1::copy(__first2, __last2, __result);
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_InputIterator1>::value_type __v1;
            typedef typename iterator_traits<_InputIterator2>::value_type __v2;
            return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            for (; __first1 != __last1; ++__result) {
                if (__first2 == __last2) {
                    std::__1::move(__first1, __last1, __result);
                    return;
                }
                if (__comp(*__first2, *__first1)) {
                    *__result = std::__1::move(*__first2);
                    ++__first2;
                } else {
                    *__result = std::__1::move(*__first1);
                    ++__first1;
                }
            }
        }

;
        template <class _Compare, class _BidirectionalIterator> void __buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1, typename iterator_traits<_BidirectionalIterator>::difference_type __len2, typename iterator_traits<_BidirectionalIterator>::value_type *__buff)         {
            typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
            std::__1::__destruct_n __d(0);
            unique_ptr<value_type, std::__1::__destruct_n &> __h2(__buff, __d);
            if (__len1 <= __len2) {
                value_type *__p = __buff;
                for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type *)0) , (void)++__i , ++__p) 
                    ::new (__p) value_type((std::__1::move(*__i)));
                __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);
            } else {
                value_type *__p = __buff;
                for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type *)0) , (void)++__i , ++__p) 
                    ::new (__p) value_type((std::__1::move(*__i)));
                typedef reverse_iterator<_BidirectionalIterator> _RBi;
                typedef reverse_iterator<value_type *> _Rv;
                __half_inplace_merge(_Rv(__p), _Rv(__buff), _RBi(__middle), _RBi(__first), _RBi(__last), __negate<_Compare>(__comp));
            }
        }

;
        template <class _Compare, class _BidirectionalIterator> void __inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1, typename iterator_traits<_BidirectionalIterator>::difference_type __len2, typename iterator_traits<_BidirectionalIterator>::value_type *__buff, ptrdiff_t __buff_size)         {
            typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
            while (true)
                {
                    if (__len2 == 0)
                        return;
                    if (__len1 <= __buff_size || __len2 <= __buff_size)
                        return __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);
                    for (; true; ++__first , (void)--__len1) {
                        if (__len1 == 0)
                            return;
                        if (__comp(*__middle, *__first))
                            break;
                    }
                    _BidirectionalIterator __m1;
                    _BidirectionalIterator __m2;
                    difference_type __len11;
                    difference_type __len21;
                    if (__len1 < __len2) {
                        __len21 = __len2 / 2;
                        __m2 = __middle;
                        std::__1::advance(__m2, __len21);
                        __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
                        __len11 = std::__1::distance(__first, __m1);
                    } else {
                        if (__len1 == 1) {
                            swap(*__first, *__middle);
                            return;
                        }
                        __len11 = __len1 / 2;
                        __m1 = __first;
                        std::__1::advance(__m1, __len11);
                        __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
                        __len21 = std::__1::distance(__middle, __m2);
                    }
                    difference_type __len12 = __len1 - __len11;
                    difference_type __len22 = __len2 - __len21;
                    __middle = std::__1::rotate(__m1, __middle, __m2);
                    if (__len11 + __len21 < __len12 + __len22) {
                        __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
                        __first = __middle;
                        __middle = __m2;
                        __len1 = __len12;
                        __len2 = __len22;
                    } else {
                        __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
                        __last = __middle;
                        __middle = __m1;
                        __len1 = __len11;
                        __len2 = __len21;
                    }
                }
        }

;
        template <class _BidirectionalIterator, class _Compare> inline void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
            typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
            difference_type __len1 = std::__1::distance(__first, __middle);
            difference_type __len2 = std::__1::distance(__middle, __last);
            difference_type __buf_size = std::__1::min(__len1, __len2);
            pair<value_type *, ptrdiff_t> __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
            unique_ptr<value_type, std::__1::__return_temporary_buffer> __h(__buf.first);
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2, __buf.first, __buf.second);
        }

;
        template <class _BidirectionalIterator> inline void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::inplace_merge(__first, __middle, __last, __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2> void __merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, typename iterator_traits<_InputIterator1>::value_type *__result, _Compare __comp)         {
            typedef typename iterator_traits<_InputIterator1>::value_type value_type;
            std::__1::__destruct_n __d(0);
            unique_ptr<value_type, std::__1::__destruct_n &> __h(__result, __d);
            for (; true; ++__result) {
                if (__first1 == __last1) {
                    for (; __first2 != __last2; ++__first2 , ++__result , __d.__incr((value_type *)0)) 
                        ::new (__result) value_type((std::__1::move(*__first2)));
                    __h.release();
                    return;
                }
                if (__first2 == __last2) {
                    for (; __first1 != __last1; ++__first1 , ++__result , __d.__incr((value_type *)0)) 
                        ::new (__result) value_type((std::__1::move(*__first1)));
                    __h.release();
                    return;
                }
                if (__comp(*__first2, *__first1)) {
                    ::new (__result) value_type((std::__1::move(*__first2)));
                    __d.__incr((value_type *)0);
                    ++__first2;
                } else {
                    ::new (__result) value_type((std::__1::move(*__first1)));
                    __d.__incr((value_type *)0);
                    ++__first1;
                }
            }
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> void __merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            for (; __first1 != __last1; ++__result) {
                if (__first2 == __last2) {
                    for (; __first1 != __last1; ++__first1 , ++__result) 
                        *__result = std::__1::move(*__first1);
                    return;
                }
                if (__comp(*__first2, *__first1)) {
                    *__result = std::__1::move(*__first2);
                    ++__first2;
                } else {
                    *__result = std::__1::move(*__first1);
                    ++__first1;
                }
            }
            for (; __first2 != __last2; ++__first2 , ++__result) 
                *__result = std::__1::move(*__first2);
        }

;
        template <class _Compare, class _RandomAccessIterator> void __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len, typename iterator_traits<_RandomAccessIterator>::value_type *__buff, ptrdiff_t __buff_size);
        template <class _Compare, class _RandomAccessIterator> void __stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len, typename iterator_traits<_RandomAccessIterator>::value_type *__first2)         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            switch (__len) {
              case 0:
                return;
              case 1:
                ::new (__first2) value_type((std::__1::move(*__first1)));
                return;
              case 2:
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h2(__first2, __d);
                if (__comp(*--__last1, *__first1)) {
                    ::new (__first2) value_type((std::__1::move(*__last1)));
                    __d.__incr((value_type *)0);
                    ++__first2;
                    ::new (__first2) value_type((std::__1::move(*__first1)));
                } else {
                    ::new (__first2) value_type((std::__1::move(*__first1)));
                    __d.__incr((value_type *)0);
                    ++__first2;
                    ::new (__first2) value_type((std::__1::move(*__last1)));
                }
                __h2.release();
                return;
            }
            if (__len <= 8) {
                __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
                return;
            }
            typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
            _RandomAccessIterator __m = __first1 + __l2;
            __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
            __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
            __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
        }

;
        template <class _Tp> struct __stable_sort_switch {
            static const unsigned int value = 128 * is_trivially_copy_assignable<_Tp>::value;
        };
        template <class _Compare, class _RandomAccessIterator> void __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len, typename iterator_traits<_RandomAccessIterator>::value_type *__buff, ptrdiff_t __buff_size)         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            switch (__len) {
              case 0:
              case 1:
                return;
              case 2:
                if (__comp(*--__last, *__first))
                    swap(*__first, *__last);
                return;
            }
            if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
                __insertion_sort<_Compare>(__first, __last, __comp);
                return;
            }
            typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
            _RandomAccessIterator __m = __first + __l2;
            if (__len <= __buff_size) {
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h2(__buff, __d);
                __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
                __d.__set(__l2, (value_type *)0);
                __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
                __d.__set(__len, (value_type *)0);
                __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);
                return;
            }
            __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
            __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
            __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
        }

;
        template <class _RandomAccessIterator, class _Compare> inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            difference_type __len = __last - __first;
            pair<value_type *, ptrdiff_t> __buf(0, 0);
            unique_ptr<value_type, std::__1::__return_temporary_buffer> __h;
            if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
                __buf = std::__1::get_temporary_buffer<value_type>(__len);
                __h.reset(__buf.first);
            }
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
        }

;
        template <class _RandomAccessIterator> inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _RandomAccessIterator, class _Compare> _RandomAccessIterator is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            difference_type __len = __last - __first;
            difference_type __p = 0;
            difference_type __c = 1;
            _RandomAccessIterator __pp = __first;
            while (__c < __len)
                {
                    _RandomAccessIterator __cp = __first + __c;
                    if (__comp(*__pp, *__cp))
                        return __cp;
                    ++__c;
                    ++__cp;
                    if (__c == __len)
                        return __last;
                    if (__comp(*__pp, *__cp))
                        return __cp;
                    ++__p;
                    ++__pp;
                    __c = 2 * __p + 1;
                }
            return __last;
        }

;
        template <class _RandomAccessIterator> inline _RandomAccessIterator is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _RandomAccessIterator, class _Compare> inline bool is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::is_heap_until(__first, __last, __comp) == __last;
        }

;
        template <class _RandomAccessIterator> inline bool is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _Compare, class _RandomAccessIterator> void __sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len)         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            if (__len > 1) {
                __len = (__len - 2) / 2;
                _RandomAccessIterator __ptr = __first + __len;
                if (__comp(*__ptr, *--__last)) {
                    value_type __t(std::__1::move(*__last));
                    do {
                        *__last = std::__1::move(*__ptr);
                        __last = __ptr;
                        if (__len == 0)
                            break;
                        __len = (__len - 1) / 2;
                        __ptr = __first + __len;
                    } while (__comp(*__ptr, __t));
                    *__last = std::__1::move(__t);
                }
            }
        }

;
        template <class _RandomAccessIterator, class _Compare> inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);
        }

;
        template <class _RandomAccessIterator> inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _Compare, class _RandomAccessIterator> void __sift_down(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len, _RandomAccessIterator __start)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            difference_type __child = __start - __first;
            if (__len < 2 || (__len - 2) / 2 < __child)
                return;
            __child = 2 * __child + 1;
            _RandomAccessIterator __child_i = __first + __child;
            if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {
                ++__child_i;
                ++__child;
            }
            if (__comp(*__child_i, *__start))
                return;
            value_type __top(std::__1::move(*__start));
            do {
                *__start = std::__1::move(*__child_i);
                __start = __child_i;
                if ((__len - 2) / 2 < __child)
                    break;
                __child = 2 * __child + 1;
                __child_i = __first + __child;
                if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {
                    ++__child_i;
                    ++__child;
                }
            } while (!__comp(*__child_i, __top));
            *__start = std::__1::move(__top);
        }

;
        template <class _Compare, class _RandomAccessIterator> inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__len > 1) {
                swap(*__first, *--__last);
                __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
            }
        }

;
        template <class _RandomAccessIterator, class _Compare> inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);
        }

;
        template <class _RandomAccessIterator> inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _Compare, class _RandomAccessIterator> void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            difference_type __n = __last - __first;
            if (__n > 1) {
                for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start) {
                    __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
                }
            }
        }

;
        template <class _RandomAccessIterator, class _Compare> inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            __make_heap<_Comp_ref>(__first, __last, __comp);
        }

;
        template <class _RandomAccessIterator> inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _Compare, class _RandomAccessIterator> void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            for (difference_type __n = __last - __first; __n > 1; --__last , --__n) 
                __pop_heap<_Compare>(__first, __last, __comp, __n);
        }

;
        template <class _RandomAccessIterator, class _Compare> inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            __sort_heap<_Comp_ref>(__first, __last, __comp);
        }

;
        template <class _RandomAccessIterator> inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _Compare, class _RandomAccessIterator> void __partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)         {
            __make_heap<_Compare>(__first, __middle, __comp);
            typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
            for (_RandomAccessIterator __i = __middle; __i != __last; ++__i) {
                if (__comp(*__i, *__first)) {
                    swap(*__i, *__first);
                    __sift_down<_Compare>(__first, __middle, __comp, __len, __first);
                }
            }
            __sort_heap<_Compare>(__first, __middle, __comp);
        }

;
        template <class _RandomAccessIterator, class _Compare> inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);
        }

;
        template <class _RandomAccessIterator> inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::partial_sort(__first, __middle, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _Compare, class _InputIterator, class _RandomAccessIterator> _RandomAccessIterator __partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)         {
            _RandomAccessIterator __r = __result_first;
            if (__r != __result_last) {
                for (; __first != __last && __r != __result_last; (void)++__first , ++__r) 
                    *__r = *__first;
                __make_heap<_Compare>(__result_first, __r, __comp);
                typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
                for (; __first != __last; ++__first) 
                    if (__comp(*__first, *__result_first)) {
                        *__result_first = *__first;
                        __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);
                    }
                __sort_heap<_Compare>(__result_first, __r, __comp);
            }
            return __r;
        }

;
        template <class _InputIterator, class _RandomAccessIterator, class _Compare> inline _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);
        }

;
        template <class _InputIterator, class _RandomAccessIterator> inline _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _Compare, class _RandomAccessIterator> void __nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            const difference_type __limit = 7;
            while (true)
                {
                  __restart:
                    if (__nth == __last)
                        return;
                    difference_type __len = __last - __first;
                    switch (__len) {
                      case 0:
                      case 1:
                        return;
                      case 2:
                        if (__comp(*--__last, *__first))
                            swap(*__first, *__last);
                        return;
                      case 3:
                        {
                            _RandomAccessIterator __m = __first;
                            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
                            return;
                        }
                    }
                    if (__len <= __limit) {
                        __selection_sort<_Compare>(__first, __last, __comp);
                        return;
                    }
                    _RandomAccessIterator __m = __first + __len / 2;
                    _RandomAccessIterator __lm1 = __last;
                    unsigned int __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);
                    _RandomAccessIterator __i = __first;
                    _RandomAccessIterator __j = __lm1;
                    if (!__comp(*__i, *__m)) {
                        while (true)
                            {
                                if (__i == --__j) {
                                    ++__i;
                                    __j = __last;
                                    if (!__comp(*__first, *--__j)) {
                                        while (true)
                                            {
                                                if (__i == __j)
                                                    return;
                                                if (__comp(*__first, *__i)) {
                                                    swap(*__i, *__j);
                                                    ++__n_swaps;
                                                    ++__i;
                                                    break;
                                                }
                                                ++__i;
                                            }
                                    }
                                    if (__i == __j)
                                        return;
                                    while (true)
                                        {
                                            while (!__comp(*__first, *__i))
                                                ++__i;
                                            while (__comp(*__first, *--__j))
                                                ;
                                            if (__i >= __j)
                                                break;
                                            swap(*__i, *__j);
                                            ++__n_swaps;
                                            ++__i;
                                        }
                                    if (__nth < __i)
                                        return;
                                    __first = __i;
                                    goto __restart;
                                }
                                if (__comp(*__j, *__m)) {
                                    swap(*__i, *__j);
                                    ++__n_swaps;
                                    break;
                                }
                            }
                    }
                    ++__i;
                    if (__i < __j) {
                        while (true)
                            {
                                while (__comp(*__i, *__m))
                                    ++__i;
                                while (!__comp(*--__j, *__m))
                                    ;
                                if (__i >= __j)
                                    break;
                                swap(*__i, *__j);
                                ++__n_swaps;
                                if (__m == __i)
                                    __m = __j;
                                ++__i;
                            }
                    }
                    if (__i != __m && __comp(*__m, *__i)) {
                        swap(*__i, *__m);
                        ++__n_swaps;
                    }
                    if (__nth == __i)
                        return;
                    if (__n_swaps == 0) {
                        if (__nth < __i) {
                            __j = __m = __first;
                            while (++__j != __i)
                                {
                                    if (__comp(*__j, *__m))
                                        goto not_sorted;
                                    __m = __j;
                                }
                            return;
                        } else {
                            __j = __m = __i;
                            while (++__j != __last)
                                {
                                    if (__comp(*__j, *__m))
                                        goto not_sorted;
                                    __m = __j;
                                }
                            return;
                        }
                    }
                  not_sorted:
                    if (__nth < __i) {
                        __last = __i;
                    } else {
                        __first = ++__i;
                    }
                }
        }

;
        template <class _RandomAccessIterator, class _Compare> inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            __nth_element<_Comp_ref>(__first, __nth, __last, __comp);
        }

;
        template <class _RandomAccessIterator> inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2> bool __includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)         {
            for (; __first2 != __last2; ++__first1) {
                if (__first1 == __last1 || __comp(*__first2, *__first1))
                    return false;
                if (!__comp(*__first1, *__first2))
                    ++__first2;
            }
            return true;
        }

;
        template <class _InputIterator1, class _InputIterator2, class _Compare> inline bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
        }

;
        template <class _InputIterator1, class _InputIterator2> inline bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::includes(__first1, __last1, __first2, __last2, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            for (; __first1 != __last1; ++__result) {
                if (__first2 == __last2)
                    return std::__1::copy(__first1, __last1, __result);
                if (__comp(*__first2, *__first1)) {
                    *__result = *__first2;
                    ++__first2;
                } else {
                    *__result = *__first1;
                    if (!__comp(*__first1, *__first2))
                        ++__first2;
                    ++__first1;
                }
            }
            return std::__1::copy(__first2, __last2, __result);
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::set_union(__first1, __last1, __first2, __last2, __result, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            while (__first1 != __last1 && __first2 != __last2)
                {
                    if (__comp(*__first1, *__first2))
                        ++__first1;
                    else {
                        if (!__comp(*__first2, *__first1)) {
                            *__result = *__first1;
                            ++__result;
                            ++__first1;
                        }
                        ++__first2;
                    }
                }
            return __result;
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            while (__first1 != __last1)
                {
                    if (__first2 == __last2)
                        return std::__1::copy(__first1, __last1, __result);
                    if (__comp(*__first1, *__first2)) {
                        *__result = *__first1;
                        ++__result;
                        ++__first1;
                    } else {
                        if (!__comp(*__first2, *__first1))
                            ++__first1;
                        ++__first2;
                    }
                }
            return __result;
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::set_difference(__first1, __last1, __first2, __last2, __result, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            while (__first1 != __last1)
                {
                    if (__first2 == __last2)
                        return std::__1::copy(__first1, __last1, __result);
                    if (__comp(*__first1, *__first2)) {
                        *__result = *__first1;
                        ++__result;
                        ++__first1;
                    } else {
                        if (__comp(*__first2, *__first1)) {
                            *__result = *__first2;
                            ++__result;
                        } else
                            ++__first1;
                        ++__first2;
                    }
                }
            return std::__1::copy(__first2, __last2, __result);
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }

;
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }

;
        template <class _Compare, class _InputIterator1, class _InputIterator2> bool __lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)         {
            for (; __first2 != __last2; ++__first1 , (void)++__first2) {
                if (__first1 == __last1 || __comp(*__first1, *__first2))
                    return true;
                if (__comp(*__first2, *__first1))
                    return false;
            }
            return false;
        }

;
        template <class _InputIterator1, class _InputIterator2, class _Compare> inline bool lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
        }

;
        template <class _InputIterator1, class _InputIterator2> inline bool lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }

;
        template <class _Compare, class _BidirectionalIterator> bool __next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)         {
            _BidirectionalIterator __i = __last;
            if (__first == __last || __first == --__i)
                return false;
            while (true)
                {
                    _BidirectionalIterator __ip1 = __i;
                    if (__comp(*--__i, *__ip1)) {
                        _BidirectionalIterator __j = __last;
                        while (!__comp(*__i, *--__j))
                            ;
                        swap(*__i, *__j);
                        std::__1::reverse(__ip1, __last);
                        return true;
                    }
                    if (__i == __first) {
                        std::__1::reverse(__first, __last);
                        return false;
                    }
                }
        }

;
        template <class _BidirectionalIterator, class _Compare> inline bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __next_permutation<_Comp_ref>(__first, __last, __comp);
        }

;
        template <class _BidirectionalIterator> inline bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::next_permutation(__first, __last, __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
        }

;
        template <class _Compare, class _BidirectionalIterator> bool __prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)         {
            _BidirectionalIterator __i = __last;
            if (__first == __last || __first == --__i)
                return false;
            while (true)
                {
                    _BidirectionalIterator __ip1 = __i;
                    if (__comp(*__ip1, *--__i)) {
                        _BidirectionalIterator __j = __last;
                        while (!__comp(*--__j, *__i))
                            ;
                        swap(*__i, *__j);
                        std::__1::reverse(__ip1, __last);
                        return true;
                    }
                    if (__i == __first) {
                        std::__1::reverse(__first, __last);
                        return false;
                    }
                }
        }

;
        template <class _BidirectionalIterator, class _Compare> inline bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __prev_permutation<_Comp_ref>(__first, __last, __comp);
        }

;
        template <class _BidirectionalIterator> inline bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::prev_permutation(__first, __last, __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value, _Tp>::type __rotate_left(_Tp __t, _Tp __n = 1) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            const unsigned int __bits = static_cast<unsigned int>(sizeof(_Tp) * 8 - 1);
            __n &= __bits;
            return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));
        }

;
        template <class _Tp> inline typename enable_if<is_integral<_Tp>::value, _Tp>::type __rotate_right(_Tp __t, _Tp __n = 1) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            const unsigned int __bits = static_cast<unsigned int>(sizeof(_Tp) * 8 - 1);
            __n &= __bits;
            return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));
        }

;
    }
}
namespace std {
    inline namespace __1 {
        class __attribute__((visibility("hidden"))) __libcpp_refstring {
            const char *__imp_ __attribute__((unused));
        };
    }
}
namespace std {
    class __attribute__((visibility("default"))) logic_error : public std::exception {
    private:
        std::__1::__libcpp_refstring __imp_;
    public:
        explicit logic_error(const string &);
        explicit logic_error(const char *);
        logic_error(const std::logic_error &) noexcept;
        std::logic_error &operator=(const std::logic_error &) noexcept;
        virtual ~std::logic_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class __attribute__((visibility("default"))) runtime_error : public std::exception {
    private:
        std::__1::__libcpp_refstring __imp_;
    public:
        explicit runtime_error(const string &);
        explicit runtime_error(const char *);
        runtime_error(const std::runtime_error &) noexcept;
        std::runtime_error &operator=(const std::runtime_error &) noexcept;
        virtual ~std::runtime_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class __attribute__((visibility("default"))) domain_error : public std::logic_error {
    public:
        explicit domain_error(const string &__s) : std::logic_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        explicit domain_error(const char *__s) : std::logic_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        virtual ~std::domain_error() noexcept;
    };
    class __attribute__((visibility("default"))) invalid_argument : public std::logic_error {
    public:
        explicit invalid_argument(const string &__s) : std::logic_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        explicit invalid_argument(const char *__s) : std::logic_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        virtual ~std::invalid_argument() noexcept;
    };
    class __attribute__((visibility("default"))) length_error : public std::logic_error {
    public:
        explicit length_error(const string &__s) : std::logic_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        explicit length_error(const char *__s) : std::logic_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        virtual ~std::length_error() noexcept;
    };
    class __attribute__((visibility("default"))) out_of_range : public std::logic_error {
    public:
        explicit out_of_range(const string &__s) : std::logic_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        explicit out_of_range(const char *__s) : std::logic_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        virtual ~std::out_of_range() noexcept;
    };
    class __attribute__((visibility("default"))) range_error : public std::runtime_error {
    public:
        explicit range_error(const string &__s) : std::runtime_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        explicit range_error(const char *__s) : std::runtime_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        virtual ~std::range_error() noexcept;
    };
    class __attribute__((visibility("default"))) overflow_error : public std::runtime_error {
    public:
        explicit overflow_error(const string &__s) : std::runtime_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        explicit overflow_error(const char *__s) : std::runtime_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        virtual ~std::overflow_error() noexcept;
    };
    class __attribute__((visibility("default"))) underflow_error : public std::runtime_error {
    public:
        explicit underflow_error(const string &__s) : std::runtime_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        explicit underflow_error(const char *__s) : std::runtime_error(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        virtual ~std::underflow_error() noexcept;
    };
}
namespace std {
    inline namespace __1 {
        template <class _StateT = __mbstate_t> class fpos
template <class _StateT> class __attribute__((type_visibility("default"))) fpos {
        private:
            _StateT __st_;
            streamoff __off_;
        public:
            fpos<_State>(streamoff __off = streamoff()) : __st_(), __off_(__off) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            operator streamoff() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__off_;
            }


            _StateT state() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__st_;
            }


            void state(_StateT __st) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__st_ = __st;
            }


            fpos<_State> &operator+=(streamoff __off) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__off_ += __off;
                return *this;
            }


            fpos<_State> operator+(streamoff __off) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                fpos<_State> __t(*this);
                __t += __off;
                return __t;
            }


            fpos<_State> &operator-=(streamoff __off) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__off_ -= __off;
                return *this;
            }


            fpos<_State> operator-(streamoff __off) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                fpos<_State> __t(*this);
                __t -= __off;
                return __t;
            }


        };
        template <class _StateT> inline streamoff operator-(const fpos<_StateT> &__x, const fpos<_StateT> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return streamoff(__x) - streamoff(__y);
        }

;
        template <class _StateT> inline bool operator==(const fpos<_StateT> &__x, const fpos<_StateT> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return streamoff(__x) == streamoff(__y);
        }

;
        template <class _StateT> inline bool operator!=(const fpos<_StateT> &__x, const fpos<_StateT> &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return streamoff(__x) != streamoff(__y);
        }

;
        template <class _CharT = char> struct __attribute__((type_visibility("default"))) char_traits {
            typedef char char_type;
            typedef int int_type;
            typedef streamoff off_type;
            typedef streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return (unsigned char)__c1 < (unsigned char)__c2;
            }


            static inline int compare(const char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? 0 : memcmp(__s1, __s2, __n);
            }


            static inline size_t length(const char_type *__s)             {
                return strlen(__s);
            }


            static inline const char_type *find(const char_type *__s, size_t __n, const char_type &__a)             {
                return __n == 0 ? __null : (const char_type *)memchr(__s, to_int_type(__a), __n);
            }


            static inline char_type *move(char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? __s1 : (char_type *)memmove(__s1, __s2, __n);
            }


            static inline char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)             {
                ((void)0);
                return __n == 0 ? __s1 : (char_type *)memcpy(__s1, __s2, __n);
            }


            static inline char_type *assign(char_type *__s, size_t __n, char_type __a)             {
                return __n == 0 ? __s : (char_type *)memset(__s, to_int_type(__a), __n);
            }


            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type((unsigned char)__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type((-1));
            }


        }
template <class _CharT = wchar_t> struct __attribute__((type_visibility("default"))) char_traits {
            typedef wchar_t char_type;
            typedef wint_t int_type;
            typedef streamoff off_type;
            typedef streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static inline int compare(const char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? 0 : wmemcmp(__s1, __s2, __n);
            }


            static inline size_t length(const char_type *__s)             {
                return wcslen(__s);
            }


            static inline const char_type *find(const char_type *__s, size_t __n, const char_type &__a)             {
                return __n == 0 ? __null : (const char_type *)wmemchr(__s, __a, __n);
            }


            static inline char_type *move(char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? __s1 : (char_type *)wmemmove(__s1, __s2, __n);
            }


            static inline char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)             {
                ((void)0);
                return __n == 0 ? __s1 : (char_type *)wmemcpy(__s1, __s2, __n);
            }


            static inline char_type *assign(char_type *__s, size_t __n, char_type __a)             {
                return __n == 0 ? __s : (char_type *)wmemset(__s, __a, __n);
            }


            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type(((__darwin_wint_t)-1));
            }


        }
template <class _CharT = char16_t> struct __attribute__((type_visibility("default"))) char_traits {
            typedef char16_t char_type;
            typedef uint_least16_t int_type;
            typedef streamoff off_type;
            typedef u16streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static int compare(const char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type(65535);
            }


        }
template <class _CharT = char32_t> struct __attribute__((type_visibility("default"))) char_traits {
            typedef char32_t char_type;
            typedef uint_least32_t int_type;
            typedef streamoff off_type;
            typedef u32streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static int compare(const char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type(4294967295U);
            }


        }
template <class _CharT> struct __attribute__((type_visibility("default"))) char_traits {
            typedef _CharT char_type;
            typedef int int_type;
            typedef streamoff off_type;
            typedef streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static int compare(const char_type *__s1, const char_type *__s2, size_t __n);
            static size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *move(char_type *__s1, const char_type *__s2, size_t __n);
            static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type((-1));
            }


        };
        int compare(const char_type *__s1, const char_type *__s2, size_t __n)         {
            for (; __n; --__n , ++__s1 , ++__s2) {
                if (lt(*__s1, *__s2))
                    return -1;
                if (lt(*__s2, *__s1))
                    return 1;
            }
            return 0;
        }


        inline size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            size_t __len = 0;
            for (; !eq(*__s, char_type(0)); ++__s) 
                ++__len;
            return __len;
        }


        inline const _CharT *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __n; --__n) {
                if (eq(*__s, __a))
                    return __s;
                ++__s;
            }
            return 0;
        }


        _CharT *move(char_type *__s1, const char_type *__s2, size_t __n)         {
            char_type *__r = __s1;
            if (__s1 < __s2) {
                for (; __n; --__n , ++__s1 , ++__s2) 
                    assign(*__s1, *__s2);
            } else if (__s2 < __s1) {
                __s1 += __n;
                __s2 += __n;
                for (; __n; --__n) 
                    assign(*--__s1, *--__s2);
            }
            return __r;
        }


        inline _CharT *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            char_type *__r = __s1;
            for (; __n; --__n , ++__s1 , ++__s2) 
                assign(*__s1, *__s2);
            return __r;
        }


        inline _CharT *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            char_type *__r = __s;
            for (; __n; --__n , ++__s) 
                assign(*__s, __a);
            return __r;
        }


        struct __attribute__((type_visibility("default"))) char_traits {
            typedef char char_type;
            typedef int int_type;
            typedef streamoff off_type;
            typedef streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return (unsigned char)__c1 < (unsigned char)__c2;
            }


            static inline int compare(const char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? 0 : memcmp(__s1, __s2, __n);
            }


            static inline size_t length(const char_type *__s)             {
                return strlen(__s);
            }


            static inline const char_type *find(const char_type *__s, size_t __n, const char_type &__a)             {
                return __n == 0 ? __null : (const char_type *)memchr(__s, to_int_type(__a), __n);
            }


            static inline char_type *move(char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? __s1 : (char_type *)memmove(__s1, __s2, __n);
            }


            static inline char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)             {
                ((void)0);
                return __n == 0 ? __s1 : (char_type *)memcpy(__s1, __s2, __n);
            }


            static inline char_type *assign(char_type *__s, size_t __n, char_type __a)             {
                return __n == 0 ? __s : (char_type *)memset(__s, to_int_type(__a), __n);
            }


            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type((unsigned char)__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type((-1));
            }


        };
        struct __attribute__((type_visibility("default"))) char_traits {
            typedef wchar_t char_type;
            typedef wint_t int_type;
            typedef streamoff off_type;
            typedef streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static inline int compare(const char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? 0 : wmemcmp(__s1, __s2, __n);
            }


            static inline size_t length(const char_type *__s)             {
                return wcslen(__s);
            }


            static inline const char_type *find(const char_type *__s, size_t __n, const char_type &__a)             {
                return __n == 0 ? __null : (const char_type *)wmemchr(__s, __a, __n);
            }


            static inline char_type *move(char_type *__s1, const char_type *__s2, size_t __n)             {
                return __n == 0 ? __s1 : (char_type *)wmemmove(__s1, __s2, __n);
            }


            static inline char_type *copy(char_type *__s1, const char_type *__s2, size_t __n)             {
                ((void)0);
                return __n == 0 ? __s1 : (char_type *)wmemcpy(__s1, __s2, __n);
            }


            static inline char_type *assign(char_type *__s, size_t __n, char_type __a)             {
                return __n == 0 ? __s : (char_type *)wmemset(__s, __a, __n);
            }


            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type(((__darwin_wint_t)-1));
            }


        };
        struct __attribute__((type_visibility("default"))) char_traits {
            typedef char16_t char_type;
            typedef uint_least16_t int_type;
            typedef streamoff off_type;
            typedef u16streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static int compare(const char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type(65535);
            }


        };
        inline int compare(const char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __n; --__n , ++__s1 , ++__s2) {
                if (lt(*__s1, *__s2))
                    return -1;
                if (lt(*__s2, *__s1))
                    return 1;
            }
            return 0;
        }


        inline size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            size_t __len = 0;
            for (; !eq(*__s, char_type(0)); ++__s) 
                ++__len;
            return __len;
        }


        inline const char16_t *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __n; --__n) {
                if (eq(*__s, __a))
                    return __s;
                ++__s;
            }
            return 0;
        }


        inline char16_t *move(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            char_type *__r = __s1;
            if (__s1 < __s2) {
                for (; __n; --__n , ++__s1 , ++__s2) 
                    assign(*__s1, *__s2);
            } else if (__s2 < __s1) {
                __s1 += __n;
                __s2 += __n;
                for (; __n; --__n) 
                    assign(*--__s1, *--__s2);
            }
            return __r;
        }


        inline char16_t *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            char_type *__r = __s1;
            for (; __n; --__n , ++__s1 , ++__s2) 
                assign(*__s1, *__s2);
            return __r;
        }


        inline char16_t *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            char_type *__r = __s;
            for (; __n; --__n , ++__s) 
                assign(*__s, __a);
            return __r;
        }


        struct __attribute__((type_visibility("default"))) char_traits {
            typedef char32_t char_type;
            typedef uint_least32_t int_type;
            typedef streamoff off_type;
            typedef u32streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(char_type &__c1, const char_type &__c2) noexcept             {
                __c1 = __c2;
            }


            static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept             {
                return __c1 < __c2;
            }


            static int compare(const char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static char_type *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            static inline constexpr int_type not_eof(int_type __c) noexcept             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }


            static inline constexpr char_type to_char_type(int_type __c) noexcept             {
                return char_type(__c);
            }


            static inline constexpr int_type to_int_type(char_type __c) noexcept             {
                return int_type(__c);
            }


            static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept             {
                return __c1 == __c2;
            }


            static inline constexpr int_type eof() noexcept             {
                return int_type(4294967295U);
            }


        };
        inline int compare(const char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __n; --__n , ++__s1 , ++__s2) {
                if (lt(*__s1, *__s2))
                    return -1;
                if (lt(*__s2, *__s1))
                    return 1;
            }
            return 0;
        }


        inline size_t length(const char_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            size_t __len = 0;
            for (; !eq(*__s, char_type(0)); ++__s) 
                ++__len;
            return __len;
        }


        inline const char32_t *find(const char_type *__s, size_t __n, const char_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (; __n; --__n) {
                if (eq(*__s, __a))
                    return __s;
                ++__s;
            }
            return 0;
        }


        inline char32_t *move(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            char_type *__r = __s1;
            if (__s1 < __s2) {
                for (; __n; --__n , ++__s1 , ++__s2) 
                    assign(*__s1, *__s2);
            } else if (__s2 < __s1) {
                __s1 += __n;
                __s2 += __n;
                for (; __n; --__n) 
                    assign(*--__s1, *--__s2);
            }
            return __r;
        }


        inline char32_t *copy(char_type *__s1, const char_type *__s2, size_t __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            char_type *__r = __s1;
            for (; __n; --__n , ++__s1 , ++__s2) 
                assign(*__s1, *__s2);
            return __r;
        }


        inline char32_t *assign(char_type *__s, size_t __n, char_type __a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            char_type *__r = __s;
            for (; __n; --__n , ++__s) 
                assign(*__s, __a);
            return __r;
        }


        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_find(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__pos >= __sz)
                return __npos;
            const _CharT *__r = _Traits::find(__p + __pos, __sz - __pos, __c);
            if (__r == 0)
                return __npos;
            return static_cast<_SizeT>(__r - __p);
        }

;
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_find(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__pos > __sz || __sz - __pos < __n)
                return __npos;
            if (__n == 0)
                return __pos;
            const _CharT *__r = std::__1::__search(__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq, std::__1::random_access_iterator_tag(), std::__1::random_access_iterator_tag());
            if (__r == __p + __sz)
                return __npos;
            return static_cast<_SizeT>(__r - __p);
        }

;
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_rfind(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__sz < 1)
                return __npos;
            if (__pos < __sz)
                ++__pos;
            else
                __pos = __sz;
            for (const _CharT *__ps = __p + __pos; __ps != __p;) {
                if (_Traits::eq(*--__ps, __c))
                    return static_cast<_SizeT>(__ps - __p);
            }
            return __npos;
        }

;
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_rfind(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __pos = std::__1::min(__pos, __sz);
            if (__n < __sz - __pos)
                __pos += __n;
            else
                __pos = __sz;
            const _CharT *__r = std::__1::__find_end(__p, __p + __pos, __s, __s + __n, _Traits::eq, std::__1::random_access_iterator_tag(), std::__1::random_access_iterator_tag());
            if (__n > 0 && __r == __p + __pos)
                return __npos;
            return static_cast<_SizeT>(__r - __p);
        }

;
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_find_first_of(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__pos >= __sz || __n == 0)
                return __npos;
            const _CharT *__r = std::__1::__find_first_of_ce(__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq);
            if (__r == __p + __sz)
                return __npos;
            return static_cast<_SizeT>(__r - __p);
        }

;
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_find_last_of(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__n != 0) {
                if (__pos < __sz)
                    ++__pos;
                else
                    __pos = __sz;
                for (const _CharT *__ps = __p + __pos; __ps != __p;) {
                    const _CharT *__r = _Traits::find(__s, __n, *--__ps);
                    if (__r)
                        return static_cast<_SizeT>(__ps - __p);
                }
            }
            return __npos;
        }

;
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_find_first_not_of(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__pos < __sz) {
                const _CharT *__pe = __p + __sz;
                for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps) 
                    if (_Traits::find(__s, __n, *__ps) == 0)
                        return static_cast<_SizeT>(__ps - __p);
            }
            return __npos;
        }

;
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_find_first_not_of(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__pos < __sz) {
                const _CharT *__pe = __p + __sz;
                for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps) 
                    if (!_Traits::eq(*__ps, __c))
                        return static_cast<_SizeT>(__ps - __p);
            }
            return __npos;
        }

;
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_find_last_not_of(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__pos < __sz)
                ++__pos;
            else
                __pos = __sz;
            for (const _CharT *__ps = __p + __pos; __ps != __p;) 
                if (_Traits::find(__s, __n, *--__ps) == 0)
                    return static_cast<_SizeT>(__ps - __p);
            return __npos;
        }

;
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> _SizeT __str_find_last_not_of(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__pos < __sz)
                ++__pos;
            else
                __pos = __sz;
            for (const _CharT *__ps = __p + __pos; __ps != __p;) 
                if (!_Traits::eq(*--__ps, __c))
                    return static_cast<_SizeT>(__ps - __p);
            return __npos;
        }

;
        template <class _Ptr> size_t __do_string_hash(_Ptr __p, _Ptr __e) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_Ptr>::value_type value_type;
            return __murmur2_or_cityhash<size_t>()(__p, (__e - __p) * sizeof(value_type));
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const std::__1::basic_string<char> &)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const std::__1::basic_string<wchar_t> &)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, const basic_string<_CharT, _Traits, _Allocator> &__y);
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(const value_type *, const std::__1::basic_string<char> &)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(const value_type *, const std::__1::basic_string<wchar_t> &)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const _CharT *__x, const basic_string<_CharT, _Traits, _Allocator> &__y);
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(value_type, const std::__1::basic_string<char> &)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(value_type, const std::__1::basic_string<wchar_t> &)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(_CharT __x, const basic_string<_CharT, _Traits, _Allocator> &__y);
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const value_type *)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const value_type *)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, const _CharT *__y);
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, value_type)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, value_type)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, _CharT __y);
        template <bool = true> class __attribute__((type_visibility("default"))) __basic_string_common {
        protected:
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        }
template <bool> class __attribute__((type_visibility("default"))) __basic_string_common {
        protected:
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
        void __throw_length_error() const         {
            throw std::length_error("basic_string");
        }


        void __throw_out_of_range() const         {
            throw std::out_of_range("basic_string");
        }


        class __attribute__((type_visibility("default"))) __basic_string_common {
        protected:
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> class __attribute__((type_visibility("default"))) basic_string : private __basic_string_common<true> {
        public:
            typedef std::__1::basic_string<char> __self;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::char_type value_type;
            typedef std::__1::allocator<char> allocator_type;
            typedef allocator_traits<allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef value_type &reference;
            typedef const value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
            static_assert((is_same<char, value_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<pointer> iterator;
            typedef __wrap_iter<const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                size_type __cap_;
                size_type __size_;
                pointer __data_;
            };
            enum  {
                __short_mask = 1
            };
            enum  {
                __long_mask = 1UL
            };
            enum  {
                __min_cap = (sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long) - 1) / sizeof(value_type) > 2 ? (sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long) - 1) / sizeof(value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    value_type __lx;
                };
                value_type __data_[23];
            };
            union __ulx {
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long __lx;
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__ulx) / sizeof(size_type)
            };
            struct __raw {
                size_type __words[3];
            };
            struct __rep {
                union {
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long __l;
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__short __s;
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, allocator_type> __r_;
        public:
            static const size_type npos = -1;
            basic_string() __attribute__((always_inline));
            explicit basic_string(const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<char> &__str);
            basic_string(const std::__1::basic_string<char> &__str, const allocator_type &__a);
            basic_string(std::__1::basic_string<char> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::valuebasic_string(std::__1::basic_string<char> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::value) : __basic_string_common<true>(), __r_(std::__1::move(__str.__r_)) __attribute__((always_inline))             {
                __str.__zero();
            }


            basic_string(std::__1::basic_string<char> &&__str, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s) __attribute__((always_inline));
            basic_string(const value_type *__s, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n, const allocator_type &__a) __attribute__((always_inline));
            basic_string(size_type __n, value_type __c) : __basic_string_common<true>(), __r_() __attribute__((always_inline))             {
                this->__init(__n, __c);
            }


            basic_string(size_type __n, value_type __c, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<char> &__str, size_type __pos, size_type __n, const allocator_type &__a);
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last) __attribute__((always_inline));
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last, const allocator_type &__a) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il, const allocator_type &__a) __attribute__((always_inline));
            ~std::__1::basic_string<char>() noexcept;
            std::__1::basic_string<char> &operator=(const std::__1::basic_string<char> &__str);
            std::__1::basic_string<char> &operator=(std::__1::basic_string<char> &&__str) __attribute__((always_inline));
            std::__1::basic_string<char> &operator=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<char> &operator=(value_type __c);
            std::__1::basic_string<char> &operator=(initializer_list<value_type> __il) __attribute__((always_inline));
            iterator begin() noexcept __attribute__((always_inline));
            const_iterator begin() const noexcept __attribute__((always_inline));
            iterator end() noexcept __attribute__((always_inline));
            const_iterator end() const noexcept __attribute__((always_inline));
            reverse_iterator rbegin() noexcept __attribute__((always_inline));
            const_reverse_iterator rbegin() const noexcept __attribute__((always_inline));
            reverse_iterator rend() noexcept __attribute__((always_inline));
            const_reverse_iterator rend() const noexcept __attribute__((always_inline));
            const_iterator cbegin() const noexcept __attribute__((always_inline));
            const_iterator cend() const noexcept __attribute__((always_inline));
            const_reverse_iterator crbegin() const noexcept __attribute__((always_inline));
            const_reverse_iterator crend() const noexcept __attribute__((always_inline));
            size_type size() const noexcept __attribute__((always_inline));
            size_type length() const noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            size_type capacity() const noexcept __attribute__((always_inline));
            void resize(size_type __n, value_type __c);
            void resize(size_type __n) __attribute__((always_inline));
            void reserve(size_type res_arg);
            void shrink_to_fit() noexcept __attribute__((always_inline));
            void clear() noexcept __attribute__((always_inline));
            bool empty() const noexcept __attribute__((always_inline));
            const_reference operator[](size_type __pos) const __attribute__((always_inline));
            reference operator[](size_type __pos) __attribute__((always_inline));
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__1::basic_string<char> &operator+=(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &operator+=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<char> &operator+=(value_type __c) __attribute__((always_inline));
            std::__1::basic_string<char> &operator+=(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<char> &append(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &append(const std::__1::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<char> &append(const value_type *__s, size_type __n);
            std::__1::basic_string<char> &append(const value_type *__s);
            std::__1::basic_string<char> &append(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<char> &>::type append(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<char> &>::type append(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<char> &append(initializer_list<value_type> __il) __attribute__((always_inline));
            void push_back(value_type __c);
            void pop_back() __attribute__((always_inline));
            reference front() __attribute__((always_inline));
            const_reference front() const __attribute__((always_inline));
            reference back() __attribute__((always_inline));
            const_reference back() const __attribute__((always_inline));
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &assign(std::__1::basic_string<char> &&str) __attribute__((always_inline));
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<char> &assign(const value_type *__s, size_type __n);
            std::__1::basic_string<char> &assign(const value_type *__s);
            std::__1::basic_string<char> &assign(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<char> &>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<char> &>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<char> &assign(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<char> &insert(size_type __pos1, const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &insert(size_type __pos1, const std::__1::basic_string<char> &__str, size_type __pos2, size_type __n);
            std::__1::basic_string<char> &insert(size_type __pos, const value_type *__s, size_type __n);
            std::__1::basic_string<char> &insert(size_type __pos, const value_type *__s);
            std::__1::basic_string<char> &insert(size_type __pos, size_type __n, value_type __c);
            iterator insert(const_iterator __pos, value_type __c);
            iterator insert(const_iterator __pos, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, iterator>::type insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, iterator>::type insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
            iterator insert(const_iterator __pos, initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<char> &erase(size_type __pos, size_type __n);
            iterator erase(const_iterator __pos) __attribute__((always_inline));
            iterator erase(const_iterator __first, const_iterator __last) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str, size_type __pos2, size_type __n2);
            std::__1::basic_string<char> &replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2);
            std::__1::basic_string<char> &replace(size_type __pos, size_type __n1, const value_type *__s);
            std::__1::basic_string<char> &replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value, basic_string<char> &>::type replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il) __attribute__((always_inline));
            size_type copy(value_type *__s, size_type __n, size_type __pos) const;
            std::__1::basic_string<char> substr(size_type __pos, size_type __n) const __attribute__((always_inline));
            void swap(std::__1::basic_string<char> &__str) __attribute__((always_inline));
            const value_type *c_str() const noexcept __attribute__((always_inline));
            const value_type *data() const noexcept __attribute__((always_inline))             {
                return std::__1::__to_raw_pointer(this->__get_pointer());
            }


            allocator_type get_allocator() const noexcept __attribute__((always_inline));
            size_type find(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(value_type __c, size_type __pos) const noexcept;
            size_type rfind(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type rfind(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(value_type __c, size_type __pos) const noexcept;
            size_type find_first_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            int compare(const std::__1::basic_string<char> &__str) const noexcept __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str) const __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str, size_type __pos2, size_type __n2) const;
            int compare(const value_type *__s) const noexcept;
            int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
            int compare(size_type __pos1, size_type __n1, const value_type *__s, size_type __n2) const;
            bool __invariants() const __attribute__((always_inline));
            bool __is_long() const noexcept __attribute__((always_inline))             {
                return bool(this->__r_.first().__s.__size_ & __short_mask);
            }


        private:
            allocator_type &__alloc() noexcept __attribute__((always_inline));
            const allocator_type &__alloc() const noexcept __attribute__((always_inline));
            void __set_short_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_short_size() const noexcept __attribute__((always_inline));
            void __set_long_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_size() const noexcept __attribute__((always_inline));
            void __set_size(size_type __s) noexcept __attribute__((always_inline));
            void __set_long_cap(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_cap() const noexcept __attribute__((always_inline));
            void __set_long_pointer(pointer __p) noexcept __attribute__((always_inline));
            pointer __get_long_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_long_pointer() const noexcept __attribute__((always_inline))             {
                return this->__r_.first().__l.__data_;
            }


            pointer __get_short_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_short_pointer() const noexcept __attribute__((always_inline))             {
                return pointer_traits<const_pointer>::pointer_to(this->__r_.first().__s.__data_[0]);
            }


            pointer __get_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_pointer() const noexcept __attribute__((always_inline))             {
                return this->__is_long() ? this->__get_long_pointer() : this->__get_short_pointer();
            }


            void __zero() noexcept __attribute__((always_inline))             {
                size_type (&__a)[3] = this->__r_.first().__r.__words;
                for (unsigned int __i = 0; __i < __n_words; ++__i) 
                    __a[__i] = 0;
            }


            template <size_type __a> static size_type __align_it(size_type __s) noexcept __attribute__((always_inline));
            enum  {
                __alignment = 16
            };
            static size_type __recommend(size_type __s) noexcept __attribute__((always_inline));
            void __init(const value_type *__s, size_type __sz, size_type __reserve);
            void __init(const value_type *__s, size_type __sz);
            void __init(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add);
            void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add, const value_type *__p_new_stuff);
            void __erase_to_end(size_type __pos) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<char> &__str, true_type) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<char> &, false_type) noexcept __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<char> &__str, false_type) __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<char> &__str, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<char> &__str) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<char> &__c, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<char> &, false_type) noexcept __attribute__((always_inline));
            void __invalidate_all_iterators() __attribute__((always_inline));
            void __invalidate_iterators_past(size_type) __attribute__((always_inline));
            friend std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const std::__1::basic_string<char> &);
            friend std::__1::basic_string<char> operator+(const value_type *, const std::__1::basic_string<char> &);
            friend std::__1::basic_string<char> operator+(value_type, const std::__1::basic_string<char> &);
            friend std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const value_type *);
            friend std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, value_type);
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> class __attribute__((type_visibility("default"))) basic_string : private __basic_string_common<true> {
        public:
            typedef std::__1::basic_string<wchar_t> __self;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::char_type value_type;
            typedef std::__1::allocator<wchar_t> allocator_type;
            typedef allocator_traits<allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef value_type &reference;
            typedef const value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
            static_assert((is_same<wchar_t, value_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<pointer> iterator;
            typedef __wrap_iter<const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                size_type __cap_;
                size_type __size_;
                pointer __data_;
            };
            enum  {
                __short_mask = 1
            };
            enum  {
                __long_mask = 1UL
            };
            enum  {
                __min_cap = (sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long) - 1) / sizeof(value_type) > 2 ? (sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long) - 1) / sizeof(value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    value_type __lx;
                };
                value_type __data_[5];
            };
            union __ulx {
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long __lx;
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__ulx) / sizeof(size_type)
            };
            struct __raw {
                size_type __words[3];
            };
            struct __rep {
                union {
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long __l;
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__short __s;
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, allocator_type> __r_;
        public:
            static const size_type npos = -1;
            basic_string() __attribute__((always_inline));
            explicit basic_string(const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<wchar_t> &__str);
            basic_string(const std::__1::basic_string<wchar_t> &__str, const allocator_type &__a);
            basic_string(std::__1::basic_string<wchar_t> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::valuebasic_string(std::__1::basic_string<wchar_t> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::value) : __basic_string_common<true>(), __r_(std::__1::move(__str.__r_)) __attribute__((always_inline))             {
                __str.__zero();
            }


            basic_string(std::__1::basic_string<wchar_t> &&__str, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s) __attribute__((always_inline));
            basic_string(const value_type *__s, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n, const allocator_type &__a) __attribute__((always_inline));
            basic_string(size_type __n, value_type __c) __attribute__((always_inline));
            basic_string(size_type __n, value_type __c, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<wchar_t> &__str, size_type __pos, size_type __n, const allocator_type &__a);
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last) __attribute__((always_inline));
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last, const allocator_type &__a) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il, const allocator_type &__a) __attribute__((always_inline));
            ~std::__1::basic_string<wchar_t>() noexcept;
            std::__1::basic_string<wchar_t> &operator=(const std::__1::basic_string<wchar_t> &__str);
            std::__1::basic_string<wchar_t> &operator=(std::__1::basic_string<wchar_t> &&__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator=(value_type __c);
            std::__1::basic_string<wchar_t> &operator=(initializer_list<value_type> __il) __attribute__((always_inline));
            iterator begin() noexcept __attribute__((always_inline));
            const_iterator begin() const noexcept __attribute__((always_inline));
            iterator end() noexcept __attribute__((always_inline));
            const_iterator end() const noexcept __attribute__((always_inline));
            reverse_iterator rbegin() noexcept __attribute__((always_inline));
            const_reverse_iterator rbegin() const noexcept __attribute__((always_inline));
            reverse_iterator rend() noexcept __attribute__((always_inline));
            const_reverse_iterator rend() const noexcept __attribute__((always_inline));
            const_iterator cbegin() const noexcept __attribute__((always_inline));
            const_iterator cend() const noexcept __attribute__((always_inline));
            const_reverse_iterator crbegin() const noexcept __attribute__((always_inline));
            const_reverse_iterator crend() const noexcept __attribute__((always_inline));
            size_type size() const noexcept __attribute__((always_inline));
            size_type length() const noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            size_type capacity() const noexcept __attribute__((always_inline));
            void resize(size_type __n, value_type __c);
            void resize(size_type __n) __attribute__((always_inline));
            void reserve(size_type res_arg);
            void shrink_to_fit() noexcept __attribute__((always_inline));
            void clear() noexcept __attribute__((always_inline));
            bool empty() const noexcept __attribute__((always_inline));
            const_reference operator[](size_type __pos) const __attribute__((always_inline));
            reference operator[](size_type __pos) __attribute__((always_inline));
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__1::basic_string<wchar_t> &operator+=(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator+=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator+=(value_type __c) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator+=(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<wchar_t> &append(const value_type *__s, size_type __n);
            std::__1::basic_string<wchar_t> &append(const value_type *__s);
            std::__1::basic_string<wchar_t> &append(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type append(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<wchar_t> &>::type append(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<wchar_t> &append(initializer_list<value_type> __il) __attribute__((always_inline));
            void push_back(value_type __c);
            void pop_back() __attribute__((always_inline));
            reference front() __attribute__((always_inline));
            const_reference front() const __attribute__((always_inline));
            reference back() __attribute__((always_inline));
            const_reference back() const __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &assign(std::__1::basic_string<wchar_t> &&str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<wchar_t> &assign(const value_type *__s, size_type __n);
            std::__1::basic_string<wchar_t> &assign(const value_type *__s);
            std::__1::basic_string<wchar_t> &assign(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<wchar_t> &>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<wchar_t> &assign(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &insert(size_type __pos1, const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &insert(size_type __pos1, const std::__1::basic_string<wchar_t> &__str, size_type __pos2, size_type __n);
            std::__1::basic_string<wchar_t> &insert(size_type __pos, const value_type *__s, size_type __n);
            std::__1::basic_string<wchar_t> &insert(size_type __pos, const value_type *__s);
            std::__1::basic_string<wchar_t> &insert(size_type __pos, size_type __n, value_type __c);
            iterator insert(const_iterator __pos, value_type __c);
            iterator insert(const_iterator __pos, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, iterator>::type insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, iterator>::type insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
            iterator insert(const_iterator __pos, initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &erase(size_type __pos, size_type __n);
            iterator erase(const_iterator __pos) __attribute__((always_inline));
            iterator erase(const_iterator __first, const_iterator __last) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2);
            std::__1::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2);
            std::__1::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const value_type *__s);
            std::__1::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il) __attribute__((always_inline));
            size_type copy(value_type *__s, size_type __n, size_type __pos) const;
            std::__1::basic_string<wchar_t> substr(size_type __pos, size_type __n) const __attribute__((always_inline));
            void swap(std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            const value_type *c_str() const noexcept __attribute__((always_inline));
            const value_type *data() const noexcept __attribute__((always_inline));
            allocator_type get_allocator() const noexcept __attribute__((always_inline));
            size_type find(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(value_type __c, size_type __pos) const noexcept;
            size_type rfind(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type rfind(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(value_type __c, size_type __pos) const noexcept;
            size_type find_first_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            int compare(const std::__1::basic_string<wchar_t> &__str) const noexcept __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str) const __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2) const;
            int compare(const value_type *__s) const noexcept;
            int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
            int compare(size_type __pos1, size_type __n1, const value_type *__s, size_type __n2) const;
            bool __invariants() const __attribute__((always_inline));
            bool __is_long() const noexcept __attribute__((always_inline));
        private:
            allocator_type &__alloc() noexcept __attribute__((always_inline));
            const allocator_type &__alloc() const noexcept __attribute__((always_inline));
            void __set_short_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_short_size() const noexcept __attribute__((always_inline));
            void __set_long_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_size() const noexcept __attribute__((always_inline));
            void __set_size(size_type __s) noexcept __attribute__((always_inline));
            void __set_long_cap(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_cap() const noexcept __attribute__((always_inline));
            void __set_long_pointer(pointer __p) noexcept __attribute__((always_inline));
            pointer __get_long_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_long_pointer() const noexcept __attribute__((always_inline));
            pointer __get_short_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_short_pointer() const noexcept __attribute__((always_inline));
            pointer __get_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_pointer() const noexcept __attribute__((always_inline));
            void __zero() noexcept __attribute__((always_inline))             {
                size_type (&__a)[3] = this->__r_.first().__r.__words;
                for (unsigned int __i = 0; __i < __n_words; ++__i) 
                    __a[__i] = 0;
            }


            template <size_type __a> static size_type __align_it(size_type __s) noexcept __attribute__((always_inline));
            enum  {
                __alignment = 16
            };
            static size_type __recommend(size_type __s) noexcept __attribute__((always_inline));
            void __init(const value_type *__s, size_type __sz, size_type __reserve);
            void __init(const value_type *__s, size_type __sz);
            void __init(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add);
            void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add, const value_type *__p_new_stuff);
            void __erase_to_end(size_type __pos) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &__str, true_type) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &, false_type) noexcept __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<wchar_t> &__str, false_type) __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<wchar_t> &__str, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &__c, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &, false_type) noexcept __attribute__((always_inline));
            void __invalidate_all_iterators() __attribute__((always_inline));
            void __invalidate_iterators_past(size_type) __attribute__((always_inline));
            friend std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const std::__1::basic_string<wchar_t> &);
            friend std::__1::basic_string<wchar_t> operator+(const value_type *, const std::__1::basic_string<wchar_t> &);
            friend std::__1::basic_string<wchar_t> operator+(value_type, const std::__1::basic_string<wchar_t> &);
            friend std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const value_type *);
            friend std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, value_type);
        }
template <class _CharT = char16_t, class _Traits = std::__1::char_traits<char16_t>, class _Allocator = std::__1::allocator<char16_t>> class basic_string
template <class _CharT = char32_t, class _Traits = std::__1::char_traits<char32_t>, class _Allocator = std::__1::allocator<char32_t>> class basic_string
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_string : private __basic_string_common<true> {
        public:
            typedef basic_string<_CharT, _Traits, _Allocator> __self;
            typedef _Traits traits_type;
            typedef typename traits_type::char_type value_type;
            typedef _Allocator allocator_type;
            typedef allocator_traits<allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef value_type &reference;
            typedef const value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
            static_assert((is_same<_CharT, value_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<pointer> iterator;
            typedef __wrap_iter<const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                size_type __cap_;
                size_type __size_;
                pointer __data_;
            };
            enum  {
                __short_mask = 1
            };
            enum  {
                __long_mask = 1UL
            };
            enum  {
                __min_cap = (sizeof(std::__1::basic_string::__long) - 1) / sizeof(value_type) > 2 ? (sizeof(std::__1::basic_string::__long) - 1) / sizeof(value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    value_type __lx;
                };
                value_type __data_[__min_cap];
            };
            union __ulx {
                std::__1::basic_string::__long __lx;
                std::__1::basic_string::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string::__ulx) / sizeof(size_type)
            };
            struct __raw {
                size_type __words[__n_words];
            };
            struct __rep {
                union {
                    std::__1::basic_string::__long __l;
                    std::__1::basic_string::__short __s;
                    std::__1::basic_string::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string::__rep, allocator_type> __r_;
        public:
            static const size_type npos = -1;
            basic_string<_CharT, _Traits, _Allocator>() noexcept(is_nothrow_default_constructible<allocator_type>::valuebasic_string<_CharT, _Traits, _Allocator>() noexcept(is_nothrow_default_constructible<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            explicit basic_string<_CharT, _Traits, _Allocator>(const allocator_type &__a) noexcept(is_nothrow_copy_constructible<allocator_type>::valuebasic_string<_CharT, _Traits, _Allocator>(const allocator_type &__a) noexcept(is_nothrow_copy_constructible<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str);
            basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, const allocator_type &__a);
            basic_string<_CharT, _Traits, _Allocator>(basic_string<_CharT, _Traits, _Allocator> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::valuebasic_string<_CharT, _Traits, _Allocator>(basic_string<_CharT, _Traits, _Allocator> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(basic_string<_CharT, _Traits, _Allocator> &&__str, const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(const value_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(const value_type *__s, const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(const value_type *__s, size_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(const value_type *__s, size_type __n, const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(size_type __n, value_type __c) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(size_type __n, value_type __c, const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos, size_type __n = npos, const allocator_type &__a = allocator_type());
            template <class _InputIterator> basic_string<_CharT, _Traits, _Allocator>(_InputIterator __first, _InputIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _InputIterator> basic_string<_CharT, _Traits, _Allocator>(_InputIterator __first, _InputIterator __last, const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(initializer_list<value_type> __il) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator>(initializer_list<value_type> __il, const allocator_type &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            ~basic_string<_CharT, _Traits, _Allocator>();
            basic_string<_CharT, _Traits, _Allocator> &operator=(const basic_string<_CharT, _Traits, _Allocator> &__str);
            basic_string<_CharT, _Traits, _Allocator> &operator=(basic_string<_CharT, _Traits, _Allocator> &&__str) noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::valueoperator=(basic_string<_CharT, _Traits, _Allocator> &&__str) noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &operator=(const value_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return assign(__s);
            }


            basic_string<_CharT, _Traits, _Allocator> &operator=(value_type __c);
            basic_string<_CharT, _Traits, _Allocator> &operator=(initializer_list<value_type> __il) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return assign(__il.begin(), __il.size());
            }


            iterator begin() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return iterator(__get_pointer());
            }


            const_iterator begin() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_iterator(__get_pointer());
            }


            iterator end() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return iterator(__get_pointer() + this->size());
            }


            const_iterator end() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_iterator(__get_pointer() + this->size());
            }


            reverse_iterator rbegin() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reverse_iterator(end());
            }


            const_reverse_iterator rbegin() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_reverse_iterator(end());
            }


            reverse_iterator rend() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reverse_iterator(begin());
            }


            const_reverse_iterator rend() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_reverse_iterator(begin());
            }


            const_iterator cbegin() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return begin();
            }


            const_iterator cend() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return end();
            }


            const_reverse_iterator crbegin() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return rbegin();
            }


            const_reverse_iterator crend() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return rend();
            }


            size_type size() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__is_long() ? this->__get_long_size() : this->__get_short_size();
            }


            size_type length() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->size();
            }


            size_type max_size() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type capacity() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (this->__is_long() ? this->__get_long_cap() : __min_cap) - 1;
            }


            void resize(size_type __n, value_type __c);
            void resize(size_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                resize(__n, value_type());
            }


            void reserve(size_type res_arg = 0);
            void shrink_to_fit() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->reserve();
            }


            void clear() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool empty() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->size() == 0;
            }


            const_reference operator[](size_type __pos) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            reference operator[](size_type __pos) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            basic_string<_CharT, _Traits, _Allocator> &operator+=(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return append(__str);
            }


            basic_string<_CharT, _Traits, _Allocator> &operator+=(const value_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return append(__s);
            }


            basic_string<_CharT, _Traits, _Allocator> &operator+=(value_type __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->push_back(__c);
                return *this;
            }


            basic_string<_CharT, _Traits, _Allocator> &operator+=(initializer_list<value_type> __il) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return append(__il);
            }


            basic_string<_CharT, _Traits, _Allocator> &append(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &append(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos, size_type __n = npos);
            basic_string<_CharT, _Traits, _Allocator> &append(const value_type *__s, size_type __n);
            basic_string<_CharT, _Traits, _Allocator> &append(const value_type *__s);
            basic_string<_CharT, _Traits, _Allocator> &append(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type append(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type append(_ForwardIterator __first, _ForwardIterator __last);
            basic_string<_CharT, _Traits, _Allocator> &append(initializer_list<value_type> __il) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return append(__il.begin(), __il.size());
            }


            void push_back(value_type __c);
            void pop_back() __attribute__((always_inline)) __attribute__((visibility("hidden")));
            reference front() __attribute__((always_inline)) __attribute__((visibility("hidden")));
            const_reference front() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            reference back() __attribute__((always_inline)) __attribute__((visibility("hidden")));
            const_reference back() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &assign(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &assign(basic_string<_CharT, _Traits, _Allocator> &&str) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                *this = std::__1::move(str);
                return *this;
            }


            basic_string<_CharT, _Traits, _Allocator> &assign(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos, size_type __n = npos);
            basic_string<_CharT, _Traits, _Allocator> &assign(const value_type *__s, size_type __n);
            basic_string<_CharT, _Traits, _Allocator> &assign(const value_type *__s);
            basic_string<_CharT, _Traits, _Allocator> &assign(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            basic_string<_CharT, _Traits, _Allocator> &assign(initializer_list<value_type> __il) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return assign(__il.begin(), __il.size());
            }


            basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos1, const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos1, const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos2, size_type __n = npos);
            basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos, const value_type *__s, size_type __n);
            basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos, const value_type *__s);
            basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos, size_type __n, value_type __c);
            iterator insert(const_iterator __pos, value_type __c);
            iterator insert(const_iterator __pos, size_type __n, value_type __c) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, iterator>::type insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, iterator>::type insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
            iterator insert(const_iterator __pos, initializer_list<value_type> __il) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return insert(__pos, __il.begin(), __il.end());
            }


            basic_string<_CharT, _Traits, _Allocator> &erase(size_type __pos = 0, size_type __n = npos);
            iterator erase(const_iterator __pos) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            iterator erase(const_iterator __first, const_iterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos2, size_type __n2 = npos);
            basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2);
            basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos, size_type __n1, const value_type *__s);
            basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
            basic_string<_CharT, _Traits, _Allocator> &replace(const_iterator __i1, const_iterator __i2, const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
            basic_string<_CharT, _Traits, _Allocator> &replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return replace(__i1, __i2, __il.begin(), __il.end());
            }


            size_type copy(value_type *__s, size_type __n, size_type __pos = 0) const;
            basic_string<_CharT, _Traits, _Allocator> substr(size_type __pos = 0, size_type __n = npos) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void swap(basic_string<_CharT, _Traits, _Allocator> &__str) noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::valueswap(basic_string<_CharT, _Traits, _Allocator> &__str) noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            const value_type *c_str() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->data();
            }


            const value_type *data() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return std::__1::__to_raw_pointer(__get_pointer());
            }


            allocator_type get_allocator() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __alloc();
            }


            size_type find(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find(const value_type *__s, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find(value_type __c, size_type __pos = 0) const noexcept;
            size_type rfind(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type rfind(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type rfind(const value_type *__s, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type rfind(value_type __c, size_type __pos = npos) const noexcept;
            size_type find_first_of(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_first_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_of(const value_type *__s, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_last_of(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_last_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_of(const value_type *__s, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_last_of(value_type __c, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_first_not_of(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_first_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_not_of(const value_type *__s, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_first_not_of(value_type __c, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_last_not_of(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_last_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_not_of(const value_type *__s, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_type find_last_not_of(value_type __c, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            int compare(const basic_string<_CharT, _Traits, _Allocator> &__str) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            int compare(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            int compare(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos2, size_type __n2 = npos) const;
            int compare(const value_type *__s) const noexcept;
            int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
            int compare(size_type __pos1, size_type __n1, const value_type *__s, size_type __n2) const;
            bool __invariants() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool __is_long() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return bool(this->__r_.first().__s.__size_ & __short_mask);
            }


        private:
            allocator_type &__alloc() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__r_.second();
            }


            const allocator_type &__alloc() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__r_.second();
            }


            void __set_short_size(size_type __s) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__r_.first().__s.__size_ = (unsigned char)(__s << 1);
            }


            size_type __get_short_size() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__r_.first().__s.__size_ >> 1;
            }


            void __set_long_size(size_type __s) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__r_.first().__l.__size_ = __s;
            }


            size_type __get_long_size() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__r_.first().__l.__size_;
            }


            void __set_size(size_type __s) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (this->__is_long())
                    this->__set_long_size(__s);
                else
                    this->__set_short_size(__s);
            }


            void __set_long_cap(size_type __s) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__r_.first().__l.__cap_ = __long_mask | __s;
            }


            size_type __get_long_cap() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__r_.first().__l.__cap_ & size_type(~__long_mask);
            }


            void __set_long_pointer(pointer __p) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__r_.first().__l.__data_ = __p;
            }


            pointer __get_long_pointer() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__r_.first().__l.__data_;
            }


            const_pointer __get_long_pointer() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__r_.first().__l.__data_;
            }


            pointer __get_short_pointer() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return pointer_traits<pointer>::pointer_to(this->__r_.first().__s.__data_[0]);
            }


            const_pointer __get_short_pointer() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return pointer_traits<const_pointer>::pointer_to(this->__r_.first().__s.__data_[0]);
            }


            pointer __get_pointer() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__is_long() ? __get_long_pointer() : __get_short_pointer();
            }


            const_pointer __get_pointer() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__is_long() ? __get_long_pointer() : __get_short_pointer();
            }


            void __zero() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                size_type (&__a)[__n_words] = this->__r_.first().__r.__words;
                for (unsigned int __i = 0; __i < __n_words; ++__i) 
                    __a[__i] = 0;
            }


            template <size_type __a> static size_type __align_it(size_type __s) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __s + (__a - 1) & ~(__a - 1);
            }

;
            enum  {
                __alignment = 16
            };
            static size_type __recommend(size_type __s) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__s < __min_cap ? __min_cap : __align_it<sizeof(value_type) < __alignment ? __alignment / sizeof(value_type) : 1>(__s + 1)) - 1;
            }


            void __init(const value_type *__s, size_type __sz, size_type __reserve);
            void __init(const value_type *__s, size_type __sz);
            void __init(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add = 0);
            void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add, const value_type *__p_new_stuff);
            void __erase_to_end(size_type __pos) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void __copy_assign_alloc(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __copy_assign_alloc(__str, integral_constant<bool, __alloc_traits::propagate_on_container_copy_assignment::value>());
            }


            void __copy_assign_alloc(const basic_string<_CharT, _Traits, _Allocator> &__str, true_type) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__alloc() != __str.__alloc()) {
                    this->clear();
                    this->shrink_to_fit();
                }
                __alloc() = __str.__alloc();
            }


            void __copy_assign_alloc(const basic_string<_CharT, _Traits, _Allocator> &, false_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void __move_assign(basic_string<_CharT, _Traits, _Allocator> &__str, false_type) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void __move_assign(basic_string<_CharT, _Traits, _Allocator> &__str, true_type) noexcept(is_nothrow_move_assignable<allocator_type>::value__move_assign(basic_string<_CharT, _Traits, _Allocator> &__str, true_type) noexcept(is_nothrow_move_assignable<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void __move_assign_alloc(basic_string<_CharT, _Traits, _Allocator> &__str) noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value__move_assign_alloc(basic_string<_CharT, _Traits, _Allocator> &__str) noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __move_assign_alloc(__str, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
            }


            void __move_assign_alloc(basic_string<_CharT, _Traits, _Allocator> &__c, true_type) noexcept(is_nothrow_move_assignable<allocator_type>::value__move_assign_alloc(basic_string<_CharT, _Traits, _Allocator> &__c, true_type) noexcept(is_nothrow_move_assignable<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __alloc() = std::__1::move(__c.__alloc());
            }


            void __move_assign_alloc(basic_string<_CharT, _Traits, _Allocator> &, false_type) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void __invalidate_all_iterators() __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void __invalidate_iterators_past(size_type) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &, const basic_string<_CharT, _Traits, _Allocator> &);
            friend basic_string<_CharT, _Traits, _Allocator> operator+(const value_type *, const basic_string<_CharT, _Traits, _Allocator> &);
            friend basic_string<_CharT, _Traits, _Allocator> operator+(value_type, const basic_string<_CharT, _Traits, _Allocator> &);
            friend basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &, const value_type *);
            friend basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &, value_type);
        };
        inline void __invalidate_all_iterators() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline void __invalidate_iterators_past(size_type) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline basic_string<_CharT, _Traits, _Allocator>() noexcept(is_nothrow_default_constructible<allocator_type>::valuebasic_string<_CharT, _Traits, _Allocator>() noexcept(is_nothrow_default_constructible<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__zero();
        }


        inline basic_string<_CharT, _Traits, _Allocator>(const allocator_type &__a) noexcept(is_nothrow_copy_constructible<allocator_type>::valuebasic_string<_CharT, _Traits, _Allocator>(const allocator_type &__a) noexcept(is_nothrow_copy_constructible<allocator_type>::value) : __r_(__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__zero();
        }


        void __init(const value_type *__s, size_type __sz, size_type __reserve)         {
            if (__reserve > this->max_size())
                this->__throw_length_error();
            pointer __p;
            if (__reserve < __min_cap) {
                this->__set_short_size(__sz);
                __p = __get_short_pointer();
            } else {
                size_type __cap = __recommend(__reserve);
                __p = __alloc_traits::allocate(__alloc(), __cap + 1);
                this->__set_long_pointer(__p);
                this->__set_long_cap(__cap + 1);
                this->__set_long_size(__sz);
            }
            traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
            traits_type::assign(__p[__sz], value_type());
        }


        void __init(const value_type *__s, size_type __sz)         {
            if (__sz > this->max_size())
                this->__throw_length_error();
            pointer __p;
            if (__sz < __min_cap) {
                this->__set_short_size(__sz);
                __p = __get_short_pointer();
            } else {
                size_type __cap = __recommend(__sz);
                __p = __alloc_traits::allocate(__alloc(), __cap + 1);
                this->__set_long_pointer(__p);
                this->__set_long_cap(__cap + 1);
                this->__set_long_size(__sz);
            }
            traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
            traits_type::assign(__p[__sz], value_type());
        }


        inline basic_string<_CharT, _Traits, _Allocator>(const value_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            __init(__s, traits_type::length(__s));
        }


        inline basic_string<_CharT, _Traits, _Allocator>(const value_type *__s, const allocator_type &__a) : __r_(__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            __init(__s, traits_type::length(__s));
        }


        inline basic_string<_CharT, _Traits, _Allocator>(const value_type *__s, size_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            __init(__s, __n);
        }


        inline basic_string<_CharT, _Traits, _Allocator>(const value_type *__s, size_type __n, const allocator_type &__a) : __r_(__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            __init(__s, __n);
        }


        basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str) : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))         {
            if (!__str.__is_long())
                this->__r_.first().__r = __str.__r_.first().__r;
            else
                __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
        }


        basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, const allocator_type &__a) : __r_(__a)         {
            if (!__str.__is_long())
                this->__r_.first().__r = __str.__r_.first().__r;
            else
                __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
        }


        inline basic_string<_CharT, _Traits, _Allocator>(basic_string<_CharT, _Traits, _Allocator> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::valuebasic_string<_CharT, _Traits, _Allocator>(basic_string<_CharT, _Traits, _Allocator> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::value) : __r_(std::__1::move(__str.__r_)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.__zero();
        }


        inline basic_string<_CharT, _Traits, _Allocator>(basic_string<_CharT, _Traits, _Allocator> &&__str, const allocator_type &__a) : __r_(__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__str.__is_long() && __a != __str.__alloc())
                __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
            else {
                this->__r_.first().__r = __str.__r_.first().__r;
                __str.__zero();
            }
        }


        void __init(size_type __n, value_type __c)         {
            if (__n > this->max_size())
                this->__throw_length_error();
            pointer __p;
            if (__n < __min_cap) {
                this->__set_short_size(__n);
                __p = __get_short_pointer();
            } else {
                size_type __cap = __recommend(__n);
                __p = __alloc_traits::allocate(__alloc(), __cap + 1);
                this->__set_long_pointer(__p);
                this->__set_long_cap(__cap + 1);
                this->__set_long_size(__n);
            }
            traits_type::assign(std::__1::__to_raw_pointer(__p), __n, __c);
            traits_type::assign(__p[__n], value_type());
        }


        inline basic_string<_CharT, _Traits, _Allocator>(size_type __n, value_type __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __init(__n, __c);
        }


        inline basic_string<_CharT, _Traits, _Allocator>(size_type __n, value_type __c, const allocator_type &__a) : __r_(__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __init(__n, __c);
        }


        basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos, size_type __n = npos, const allocator_type &__a = allocator_type()) : __r_(__a)         {
            size_type __str_sz = __str.size();
            if (__pos > __str_sz)
                this->__throw_out_of_range();
            __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));
        }


        template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last)         {
            this->__zero();
            try {
                for (; __first != __last; ++__first) 
                    this->push_back(*__first);
            } catch (...) {
                if (this->__is_long())
                    __alloc_traits::deallocate(__alloc(), __get_long_pointer(), this->__get_long_cap());
                throw;
            }
        }

;
        template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last)         {
            size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
            if (__sz > this->max_size())
                this->__throw_length_error();
            pointer __p;
            if (__sz < __min_cap) {
                this->__set_short_size(__sz);
                __p = __get_short_pointer();
            } else {
                size_type __cap = __recommend(__sz);
                __p = __alloc_traits::allocate(__alloc(), __cap + 1);
                this->__set_long_pointer(__p);
                this->__set_long_cap(__cap + 1);
                this->__set_long_size(__sz);
            }
            for (; __first != __last; ++__first , (void)++__p) 
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, value_type());
        }

;
        template <class _InputIterator> inline basic_string<_CharT, _Traits, _Allocator>(_InputIterator __first, _InputIterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __init(__first, __last);
        }

;
        template <class _InputIterator> inline basic_string<_CharT, _Traits, _Allocator>(_InputIterator __first, _InputIterator __last, const allocator_type &__a) : __r_(__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __init(__first, __last);
        }

;
        inline basic_string<_CharT, _Traits, _Allocator>(initializer_list<value_type> __il) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __init(__il.begin(), __il.end());
        }


        inline basic_string<_CharT, _Traits, _Allocator>(initializer_list<value_type> __il, const allocator_type &__a) : __r_(__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __init(__il.begin(), __il.end());
        }


        ~basic_string<_CharT, _Traits, _Allocator>()         {
            if (this->__is_long())
                __alloc_traits::deallocate(__alloc(), __get_long_pointer(), this->__get_long_cap());
        }


        void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add, const value_type *__p_new_stuff)         {
            size_type __ms = this->max_size();
            if (__delta_cap > __ms - __old_cap - 1)
                this->__throw_length_error();
            pointer __old_p = __get_pointer();
            size_type __cap = __old_cap < __ms / 2 - __alignment ? __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
            pointer __p = __alloc_traits::allocate(__alloc(), __cap + 1);
            this->__invalidate_all_iterators();
            if (__n_copy != 0)
                traits_type::copy(std::__1::__to_raw_pointer(__p), std::__1::__to_raw_pointer(__old_p), __n_copy);
            if (__n_add != 0)
                traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
            size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
            if (__sec_cp_sz != 0)
                traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add, std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
            if (__old_cap + 1 != __min_cap)
                __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
            this->__set_long_pointer(__p);
            this->__set_long_cap(__cap + 1);
            __old_sz = __n_copy + __n_add + __sec_cp_sz;
            this->__set_long_size(__old_sz);
            traits_type::assign(__p[__old_sz], value_type());
        }


        void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add = 0)         {
            size_type __ms = this->max_size();
            if (__delta_cap > __ms - __old_cap)
                this->__throw_length_error();
            pointer __old_p = __get_pointer();
            size_type __cap = __old_cap < __ms / 2 - __alignment ? __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
            pointer __p = __alloc_traits::allocate(__alloc(), __cap + 1);
            this->__invalidate_all_iterators();
            if (__n_copy != 0)
                traits_type::copy(std::__1::__to_raw_pointer(__p), std::__1::__to_raw_pointer(__old_p), __n_copy);
            size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
            if (__sec_cp_sz != 0)
                traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add, std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
            if (__old_cap + 1 != __min_cap)
                __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
            this->__set_long_pointer(__p);
            this->__set_long_cap(__cap + 1);
        }


        basic_string<_CharT, _Traits, _Allocator> &assign(const value_type *__s, size_type __n)         {
            ((void)0);
            size_type __cap = this->capacity();
            if (__cap >= __n) {
                value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
                traits_type::move(__p, __s, __n);
                traits_type::assign(__p[__n], value_type());
                this->__set_size(__n);
                this->__invalidate_iterators_past(__n);
            } else {
                size_type __sz = this->size();
                this->__grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
            }
            return *this;
        }


        basic_string<_CharT, _Traits, _Allocator> &assign(size_type __n, value_type __c)         {
            size_type __cap = this->capacity();
            if (__cap < __n) {
                size_type __sz = this->size();
                this->__grow_by(__cap, __n - __cap, __sz, 0, __sz);
            } else
                this->__invalidate_iterators_past(__n);
            value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
            traits_type::assign(__p, __n, __c);
            traits_type::assign(__p[__n], value_type());
            this->__set_size(__n);
            return *this;
        }


        basic_string<_CharT, _Traits, _Allocator> &operator=(value_type __c)         {
            pointer __p;
            if (this->__is_long()) {
                __p = __get_long_pointer();
                this->__set_long_size(1);
            } else {
                __p = __get_short_pointer();
                this->__set_short_size(1);
            }
            traits_type::assign(*__p, __c);
            traits_type::assign(*++__p, value_type());
            this->__invalidate_iterators_past(1);
            return *this;
        }


        basic_string<_CharT, _Traits, _Allocator> &operator=(const basic_string<_CharT, _Traits, _Allocator> &__str)         {
            if (this != &__str) {
                __copy_assign_alloc(__str);
                assign(__str);
            }
            return *this;
        }


        inline void __move_assign(basic_string<_CharT, _Traits, _Allocator> &__str, false_type) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__alloc() != __str.__alloc())
                assign(__str);
            else
                __move_assign(__str, true_type());
        }


        inline void __move_assign(basic_string<_CharT, _Traits, _Allocator> &__str, true_type) noexcept(is_nothrow_move_assignable<allocator_type>::value__move_assign(basic_string<_CharT, _Traits, _Allocator> &__str, true_type) noexcept(is_nothrow_move_assignable<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->clear();
            this->shrink_to_fit();
            this->__r_.first() = __str.__r_.first();
            __move_assign_alloc(__str);
            __str.__zero();
        }


        inline basic_string<_CharT, _Traits, _Allocator> &operator=(basic_string<_CharT, _Traits, _Allocator> &&__str) noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::valueoperator=(basic_string<_CharT, _Traits, _Allocator> &&__str) noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __move_assign(__str, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
            return *this;
        }


        template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type assign(_InputIterator __first, _InputIterator __last)         {
            this->clear();
            for (; __first != __last; ++__first) 
                this->push_back(*__first);
            return *this;
        }

;
        template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type assign(_ForwardIterator __first, _ForwardIterator __last)         {
            size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
            size_type __cap = this->capacity();
            if (__cap < __n) {
                size_type __sz = this->size();
                this->__grow_by(__cap, __n - __cap, __sz, 0, __sz);
            } else
                this->__invalidate_iterators_past(__n);
            pointer __p = __get_pointer();
            for (; __first != __last; ++__first , ++__p) 
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, value_type());
            this->__set_size(__n);
            return *this;
        }

;
        inline basic_string<_CharT, _Traits, _Allocator> &assign(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return assign(__str.data(), __str.size());
        }


        basic_string<_CharT, _Traits, _Allocator> &assign(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos, size_type __n = npos)         {
            size_type __sz = __str.size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
        }


        basic_string<_CharT, _Traits, _Allocator> &assign(const value_type *__s)         {
            ((void)0);
            return assign(__s, traits_type::length(__s));
        }


        basic_string<_CharT, _Traits, _Allocator> &append(const value_type *__s, size_type __n)         {
            ((void)0);
            size_type __cap = this->capacity();
            size_type __sz = this->size();
            if (__cap - __sz >= __n) {
                if (__n) {
                    value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
                    traits_type::copy(__p + __sz, __s, __n);
                    __sz += __n;
                    this->__set_size(__sz);
                    traits_type::assign(__p[__sz], value_type());
                }
            } else
                this->__grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
            return *this;
        }


        basic_string<_CharT, _Traits, _Allocator> &append(size_type __n, value_type __c)         {
            if (__n) {
                size_type __cap = this->capacity();
                size_type __sz = this->size();
                if (__cap - __sz < __n)
                    this->__grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
                pointer __p = __get_pointer();
                traits_type::assign(std::__1::__to_raw_pointer(__p) + __sz, __n, __c);
                __sz += __n;
                this->__set_size(__sz);
                traits_type::assign(__p[__sz], value_type());
            }
            return *this;
        }


        void push_back(value_type __c)         {
            bool __is_short = !this->__is_long();
            size_type __cap;
            size_type __sz;
            if (__is_short) {
                __cap = __min_cap - 1;
                __sz = this->__get_short_size();
            } else {
                __cap = this->__get_long_cap() - 1;
                __sz = this->__get_long_size();
            }
            if (__sz == __cap) {
                this->__grow_by(__cap, 1, __sz, __sz, 0);
                __is_short = !this->__is_long();
            }
            pointer __p;
            if (__is_short) {
                __p = __get_short_pointer() + __sz;
                this->__set_short_size(__sz + 1);
            } else {
                __p = __get_long_pointer() + __sz;
                this->__set_long_size(__sz + 1);
            }
            traits_type::assign(*__p, __c);
            traits_type::assign(*++__p, value_type());
        }


        template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type append(_InputIterator __first, _InputIterator __last)         {
            for (; __first != __last; ++__first) 
                this->push_back(*__first);
            return *this;
        }

;
        template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type append(_ForwardIterator __first, _ForwardIterator __last)         {
            size_type __sz = this->size();
            size_type __cap = this->capacity();
            size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
            if (__n) {
                if (__cap - __sz < __n)
                    this->__grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
                pointer __p = __get_pointer() + __sz;
                for (; __first != __last; ++__p , ++__first) 
                    traits_type::assign(*__p, *__first);
                traits_type::assign(*__p, value_type());
                this->__set_size(__sz + __n);
            }
            return *this;
        }

;
        inline basic_string<_CharT, _Traits, _Allocator> &append(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return append(__str.data(), __str.size());
        }


        basic_string<_CharT, _Traits, _Allocator> &append(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos, size_type __n = npos)         {
            size_type __sz = __str.size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
        }


        basic_string<_CharT, _Traits, _Allocator> &append(const value_type *__s)         {
            ((void)0);
            return append(__s, traits_type::length(__s));
        }


        basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos, const value_type *__s, size_type __n)         {
            ((void)0);
            size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            size_type __cap = this->capacity();
            if (__cap - __sz >= __n) {
                if (__n) {
                    value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
                    size_type __n_move = __sz - __pos;
                    if (__n_move != 0) {
                        if (__p + __pos <= __s && __s < __p + __sz)
                            __s += __n;
                        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
                    }
                    traits_type::move(__p + __pos, __s, __n);
                    __sz += __n;
                    this->__set_size(__sz);
                    traits_type::assign(__p[__sz], value_type());
                }
            } else
                this->__grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
            return *this;
        }


        basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos, size_type __n, value_type __c)         {
            size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            if (__n) {
                size_type __cap = this->capacity();
                value_type *__p;
                if (__cap - __sz >= __n) {
                    __p = std::__1::__to_raw_pointer(__get_pointer());
                    size_type __n_move = __sz - __pos;
                    if (__n_move != 0)
                        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
                } else {
                    this->__grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
                    __p = std::__1::__to_raw_pointer(__get_long_pointer());
                }
                traits_type::assign(__p + __pos, __n, __c);
                __sz += __n;
                this->__set_size(__sz);
                traits_type::assign(__p[__sz], value_type());
            }
            return *this;
        }


        template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, typename basic_string<_CharT, _Traits, _Allocator>::iterator>::type insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)         {
            size_type __old_sz = this->size();
            difference_type __ip = __pos - begin();
            for (; __first != __last; ++__first) 
                this->push_back(*__first);
            pointer __p = __get_pointer();
            std::__1::rotate(__p + __ip, __p + __old_sz, __p + this->size());
            return iterator(__p + __ip);
        }

;
        template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, typename basic_string<_CharT, _Traits, _Allocator>::iterator>::type insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)         {
            size_type __ip = static_cast<size_type>(__pos - begin());
            size_type __sz = this->size();
            size_type __cap = this->capacity();
            size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
            if (__n) {
                value_type *__p;
                if (__cap - __sz >= __n) {
                    __p = std::__1::__to_raw_pointer(__get_pointer());
                    size_type __n_move = __sz - __ip;
                    if (__n_move != 0)
                        traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
                } else {
                    this->__grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
                    __p = std::__1::__to_raw_pointer(__get_long_pointer());
                }
                __sz += __n;
                this->__set_size(__sz);
                traits_type::assign(__p[__sz], value_type());
                for (__p += __ip; __first != __last; ++__p , ++__first) 
                    traits_type::assign(*__p, *__first);
            }
            return begin() + __ip;
        }

;
        inline basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos1, const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return insert(__pos1, __str.data(), __str.size());
        }


        basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos1, const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos2, size_type __n = npos)         {
            size_type __str_sz = __str.size();
            if (__pos2 > __str_sz)
                this->__throw_out_of_range();
            return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
        }


        basic_string<_CharT, _Traits, _Allocator> &insert(size_type __pos, const value_type *__s)         {
            ((void)0);
            return insert(__pos, __s, traits_type::length(__s));
        }


        typename basic_string<_CharT, _Traits, _Allocator>::iterator insert(const_iterator __pos, value_type __c)         {
            size_type __ip = static_cast<size_type>(__pos - begin());
            size_type __sz = this->size();
            size_type __cap = this->capacity();
            value_type *__p;
            if (__cap == __sz) {
                this->__grow_by(__cap, 1, __sz, __ip, 0, 1);
                __p = std::__1::__to_raw_pointer(__get_long_pointer());
            } else {
                __p = std::__1::__to_raw_pointer(__get_pointer());
                size_type __n_move = __sz - __ip;
                if (__n_move != 0)
                    traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
            }
            traits_type::assign(__p[__ip], __c);
            traits_type::assign(__p[++__sz], value_type());
            this->__set_size(__sz);
            return begin() + static_cast<difference_type>(__ip);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::iterator insert(const_iterator __pos, size_type __n, value_type __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            difference_type __p = __pos - begin();
            insert(static_cast<size_type>(__p), __n, __c);
            return begin() + __p;
        }


        basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2)         {
            ((void)0);
            size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            __n1 = std::__1::min(__n1, __sz - __pos);
            size_type __cap = this->capacity();
            if (__cap - __sz + __n1 >= __n2) {
                value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
                if (__n1 != __n2) {
                    size_type __n_move = __sz - __pos - __n1;
                    if (__n_move != 0) {
                        if (__n1 > __n2) {
                            traits_type::move(__p + __pos, __s, __n2);
                            traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                            goto __finish;
                        }
                        if (__p + __pos < __s && __s < __p + __sz) {
                            if (__p + __pos + __n1 <= __s)
                                __s += __n2 - __n1;
                            else {
                                traits_type::move(__p + __pos, __s, __n1);
                                __pos += __n1;
                                __s += __n2;
                                __n2 -= __n1;
                                __n1 = 0;
                            }
                        }
                        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    }
                }
                traits_type::move(__p + __pos, __s, __n2);
              __finish:
                __sz += __n2 - __n1;
                this->__set_size(__sz);
                this->__invalidate_iterators_past(__sz);
                traits_type::assign(__p[__sz], value_type());
            } else
                this->__grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
            return *this;
        }


        basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)         {
            size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            __n1 = std::__1::min(__n1, __sz - __pos);
            size_type __cap = this->capacity();
            value_type *__p;
            if (__cap - __sz + __n1 >= __n2) {
                __p = std::__1::__to_raw_pointer(__get_pointer());
                if (__n1 != __n2) {
                    size_type __n_move = __sz - __pos - __n1;
                    if (__n_move != 0)
                        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                }
            } else {
                this->__grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
                __p = std::__1::__to_raw_pointer(__get_long_pointer());
            }
            traits_type::assign(__p + __pos, __n2, __c);
            __sz += __n2 - __n1;
            this->__set_size(__sz);
            this->__invalidate_iterators_past(__sz);
            traits_type::assign(__p[__sz], value_type());
            return *this;
        }


        template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2)         {
            for (; true; ++__i1 , ++__j1) {
                if (__i1 == __i2) {
                    if (__j1 != __j2)
                        insert(__i1, __j1, __j2);
                    break;
                }
                if (__j1 == __j2) {
                    erase(__i1, __i2);
                    break;
                }
                traits_type::assign(const_cast<value_type &>(*__i1), *__j1);
            }
            return *this;
        }

;
        inline basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return replace(__pos1, __n1, __str.data(), __str.size());
        }


        basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos2, size_type __n2 = npos)         {
            size_type __str_sz = __str.size();
            if (__pos2 > __str_sz)
                this->__throw_out_of_range();
            return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
        }


        basic_string<_CharT, _Traits, _Allocator> &replace(size_type __pos, size_type __n1, const value_type *__s)         {
            ((void)0);
            return replace(__pos, __n1, __s, traits_type::length(__s));
        }


        inline basic_string<_CharT, _Traits, _Allocator> &replace(const_iterator __i1, const_iterator __i2, const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __str.data(), __str.size());
        }


        inline basic_string<_CharT, _Traits, _Allocator> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
        }


        inline basic_string<_CharT, _Traits, _Allocator> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
        }


        inline basic_string<_CharT, _Traits, _Allocator> &replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
        }


        basic_string<_CharT, _Traits, _Allocator> &erase(size_type __pos = 0, size_type __n = npos)         {
            size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            if (__n) {
                value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
                __n = std::__1::min(__n, __sz - __pos);
                size_type __n_move = __sz - __pos - __n;
                if (__n_move != 0)
                    traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
                __sz -= __n;
                this->__set_size(__sz);
                this->__invalidate_iterators_past(__sz);
                traits_type::assign(__p[__sz], value_type());
            }
            return *this;
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::iterator erase(const_iterator __pos) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            iterator __b = begin();
            size_type __r = static_cast<size_type>(__pos - __b);
            erase(__r, 1);
            return __b + static_cast<difference_type>(__r);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::iterator erase(const_iterator __first, const_iterator __last) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            iterator __b = begin();
            size_type __r = static_cast<size_type>(__first - __b);
            erase(__r, static_cast<size_type>(__last - __first));
            return __b + static_cast<difference_type>(__r);
        }


        inline void pop_back() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            size_type __sz;
            if (this->__is_long()) {
                __sz = this->__get_long_size() - 1;
                this->__set_long_size(__sz);
                traits_type::assign(*(__get_long_pointer() + __sz), value_type());
            } else {
                __sz = this->__get_short_size() - 1;
                this->__set_short_size(__sz);
                traits_type::assign(*(__get_short_pointer() + __sz), value_type());
            }
            this->__invalidate_iterators_past(__sz);
        }


        inline void clear() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__invalidate_all_iterators();
            if (this->__is_long()) {
                traits_type::assign(*__get_long_pointer(), value_type());
                this->__set_long_size(0);
            } else {
                traits_type::assign(*__get_short_pointer(), value_type());
                this->__set_short_size(0);
            }
        }


        inline void __erase_to_end(size_type __pos) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__is_long()) {
                traits_type::assign(*(__get_long_pointer() + __pos), value_type());
                this->__set_long_size(__pos);
            } else {
                traits_type::assign(*(__get_short_pointer() + __pos), value_type());
                this->__set_short_size(__pos);
            }
            this->__invalidate_iterators_past(__pos);
        }


        void resize(size_type __n, value_type __c)         {
            size_type __sz = this->size();
            if (__n > __sz)
                append(__n - __sz, __c);
            else
                this->__erase_to_end(__n);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type max_size() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            size_type __m = __alloc_traits::max_size(__alloc());
            return __m - __alignment;
        }


        void reserve(size_type __res_arg = 0)         {
            if (__res_arg > this->max_size())
                this->__throw_length_error();
            size_type __cap = this->capacity();
            size_type __sz = this->size();
            __res_arg = std::__1::max(__res_arg, __sz);
            __res_arg = __recommend(__res_arg);
            if (__res_arg != __cap) {
                pointer __new_data, __p;
                bool __was_long, __now_long;
                if (__res_arg == __min_cap - 1) {
                    __was_long = true;
                    __now_long = false;
                    __new_data = __get_short_pointer();
                    __p = __get_long_pointer();
                } else {
                    if (__res_arg > __cap)
                        __new_data = __alloc_traits::allocate(__alloc(), __res_arg + 1);
                    else {
                        try {
                            __new_data = __alloc_traits::allocate(__alloc(), __res_arg + 1);
                        } catch (...) {
                            return;
                        }
                    }
                    __now_long = true;
                    __was_long = this->__is_long();
                    __p = __get_pointer();
                }
                traits_type::copy(std::__1::__to_raw_pointer(__new_data), std::__1::__to_raw_pointer(__p), this->size() + 1);
                if (__was_long)
                    __alloc_traits::deallocate(__alloc(), __p, __cap + 1);
                if (__now_long) {
                    this->__set_long_cap(__res_arg + 1);
                    this->__set_long_size(__sz);
                    this->__set_long_pointer(__new_data);
                } else
                    this->__set_short_size(__sz);
                this->__invalidate_all_iterators();
            }
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference operator[](size_type __pos) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return *(this->data() + __pos);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::reference operator[](size_type __pos) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return *(__get_pointer() + __pos);
        }


        typename basic_string<_CharT, _Traits, _Allocator>::const_reference at(size_type __n) const         {
            if (__n >= this->size())
                this->__throw_out_of_range();
            return (*this)[__n];
        }


        typename basic_string<_CharT, _Traits, _Allocator>::reference at(size_type __n)         {
            if (__n >= this->size())
                this->__throw_out_of_range();
            return (*this)[__n];
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::reference front() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return *__get_pointer();
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference front() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return *this->data();
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::reference back() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return *(__get_pointer() + this->size() - 1);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference back() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return *(this->data() + this->size() - 1);
        }


        typename basic_string<_CharT, _Traits, _Allocator>::size_type copy(value_type *__s, size_type __n, size_type __pos = 0) const         {
            size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            size_type __rlen = std::__1::min(__n, __sz - __pos);
            traits_type::copy(__s, this->data() + __pos, __rlen);
            return __rlen;
        }


        inline basic_string<_CharT, _Traits, _Allocator> substr(size_type __pos = 0, size_type __n = npos) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return basic_string<_CharT, _Traits, _Allocator>(*this, __pos, __n, __alloc());
        }


        inline void swap(basic_string<_CharT, _Traits, _Allocator> &__str) noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::valueswap(basic_string<_CharT, _Traits, _Allocator> &__str) noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::swap(this->__r_.first(), __str.__r_.first());
            __swap_allocator(__alloc(), __str.__alloc());
        }


        template <class _Traits> struct __attribute__((visibility("hidden"))) __traits_eq {
            typedef typename _Traits::char_type char_type;
            bool operator()(const char_type &__x, const char_type &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return _Traits::eq(__x, __y);
            }


        };
        typename basic_string<_CharT, _Traits, _Allocator>::size_type find(const value_type *__s, size_type __pos, size_type __n) const noexcept         {
            ((void)0);
            return std::__1::__str_find<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__str_find<value_type, size_type, traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find(const value_type *__s, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return std::__1::__str_find<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }


        typename basic_string<_CharT, _Traits, _Allocator>::size_type find(value_type __c, size_type __pos = 0) const noexcept         {
            return std::__1::__str_find<value_type, size_type, traits_type, npos>(this->data(), this->size(), __c, __pos);
        }


        typename basic_string<_CharT, _Traits, _Allocator>::size_type rfind(const value_type *__s, size_type __pos, size_type __n) const noexcept         {
            ((void)0);
            return std::__1::__str_rfind<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type rfind(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__str_rfind<value_type, size_type, traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type rfind(const value_type *__s, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return std::__1::__str_rfind<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }


        typename basic_string<_CharT, _Traits, _Allocator>::size_type rfind(value_type __c, size_type __pos = npos) const noexcept         {
            return std::__1::__str_rfind<value_type, size_type, traits_type, npos>(this->data(), this->size(), __c, __pos);
        }


        typename basic_string<_CharT, _Traits, _Allocator>::size_type find_first_of(const value_type *__s, size_type __pos, size_type __n) const noexcept         {
            ((void)0);
            return std::__1::__str_find_first_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_first_of(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__str_find_first_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_first_of(const value_type *__s, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return std::__1::__str_find_first_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return find(__c, __pos);
        }


        typename basic_string<_CharT, _Traits, _Allocator>::size_type find_last_of(const value_type *__s, size_type __pos, size_type __n) const noexcept         {
            ((void)0);
            return std::__1::__str_find_last_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_last_of(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__str_find_last_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_last_of(const value_type *__s, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return std::__1::__str_find_last_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_last_of(value_type __c, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return rfind(__c, __pos);
        }


        typename basic_string<_CharT, _Traits, _Allocator>::size_type find_first_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept         {
            ((void)0);
            return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_first_not_of(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_first_not_of(const value_type *__s, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_first_not_of(value_type __c, size_type __pos = 0) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __c, __pos);
        }


        typename basic_string<_CharT, _Traits, _Allocator>::size_type find_last_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept         {
            ((void)0);
            return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_last_not_of(const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_last_not_of(const value_type *__s, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            ((void)0);
            return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }


        inline typename basic_string<_CharT, _Traits, _Allocator>::size_type find_last_not_of(value_type __c, size_type __pos = npos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>(this->data(), this->size(), __c, __pos);
        }


        inline int compare(const basic_string<_CharT, _Traits, _Allocator> &__str) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            size_t __lhs_sz = this->size();
            size_t __rhs_sz = __str.size();
            int __result = traits_type::compare(this->data(), __str.data(), std::__1::min(__lhs_sz, __rhs_sz));
            if (__result != 0)
                return __result;
            if (__lhs_sz < __rhs_sz)
                return -1;
            if (__lhs_sz > __rhs_sz)
                return 1;
            return 0;
        }


        inline int compare(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return compare(__pos1, __n1, __str.data(), __str.size());
        }


        int compare(size_type __pos1, size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str, size_type __pos2, size_type __n2 = npos) const         {
            size_type __sz = __str.size();
            if (__pos2 > __sz)
                this->__throw_out_of_range();
            return compare(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __sz - __pos2));
        }


        int compare(const value_type *__s) const noexcept         {
            ((void)0);
            return compare(0, npos, __s, traits_type::length(__s));
        }


        int compare(size_type __pos1, size_type __n1, const value_type *__s) const         {
            ((void)0);
            return compare(__pos1, __n1, __s, traits_type::length(__s));
        }


        int compare(size_type __pos1, size_type __n1, const value_type *__s, size_type __n2) const         {
            ((void)0);
            size_type __sz = this->size();
            if (__pos1 > __sz || __n2 == npos)
                this->__throw_out_of_range();
            size_type __rlen = std::__1::min(__n1, __sz - __pos1);
            int __r = traits_type::compare(this->data() + __pos1, __s, std::__1::min(__rlen, __n2));
            if (__r == 0) {
                if (__rlen < __n2)
                    __r = -1;
                else if (__rlen > __n2)
                    __r = 1;
            }
            return __r;
        }


        inline bool __invariants() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->size() > this->capacity())
                return false;
            if (this->capacity() < __min_cap - 1)
                return false;
            if (this->data() == 0)
                return false;
            if (this->data()[this->size()] != value_type(0))
                return false;
            return true;
        }


        template <class _CharT, class _Traits, class _Allocator> inline bool operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            size_t __lhs_sz = __lhs.size();
            return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(), __rhs.data(), __lhs_sz) == 0;
        }

;
        template <class _Allocator> inline bool operator==(const basic_string<char, char_traits<char>, _Allocator> &__lhs, const basic_string<char, char_traits<char>, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            size_t __lhs_sz = __lhs.size();
            if (__lhs_sz != __rhs.size())
                return false;
            const char *__lp = __lhs.data();
            const char *__rp = __rhs.data();
            if (__lhs.__is_long())
                return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
            for (; __lhs_sz != 0; --__lhs_sz , ++__lp , ++__rp) 
                if (*__lp != *__rp)
                    return false;
            return true;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator==(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __rhs.compare(__lhs) == 0;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __lhs.compare(__rhs) == 0;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__lhs == __rhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator!=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__lhs == __rhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__lhs == __rhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __lhs.compare(__rhs) < 0;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __lhs.compare(__rhs) < 0;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __rhs.compare(__lhs) > 0;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __rhs < __lhs;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __rhs < __lhs;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __rhs < __lhs;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__rhs < __lhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__rhs < __lhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__rhs < __lhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__lhs < __rhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__lhs < __rhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__lhs < __rhs);
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const std::__1::basic_string<char> &)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const std::__1::basic_string<wchar_t> &)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
            __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
            __r.append(__rhs.data(), __rhs_sz);
            return __r;
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(const value_type *, const std::__1::basic_string<char> &)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(const value_type *, const std::__1::basic_string<wchar_t> &)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
            __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
            __r.append(__rhs.data(), __rhs_sz);
            return __r;
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(value_type, const std::__1::basic_string<char> &)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(value_type, const std::__1::basic_string<wchar_t> &)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
            __r.__init(&__lhs, 1, 1 + __rhs_sz);
            __r.append(__rhs.data(), __rhs_sz);
            return __r;
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const value_type *)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const value_type *)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
            __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
            __r.append(__rhs, __rhs_sz);
            return __r;
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>, class _Allocator = std::__1::allocator<char>> std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, value_type)template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>, class _Allocator = std::__1::allocator<wchar_t>> std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, value_type)template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs, _CharT __rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
            __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
            __r.push_back(__rhs);
            return __r;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::move(__lhs.append(__rhs));
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs, basic_string<_CharT, _Traits, _Allocator> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::move(__rhs.insert(0, __lhs));
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs, basic_string<_CharT, _Traits, _Allocator> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::move(__lhs.append(__rhs));
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> operator+(const _CharT *__lhs, basic_string<_CharT, _Traits, _Allocator> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::move(__rhs.insert(0, __lhs));
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> operator+(_CharT __lhs, basic_string<_CharT, _Traits, _Allocator> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __rhs.insert(__rhs.begin(), __lhs);
            return std::__1::move(__rhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs, const _CharT *__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::move(__lhs.append(__rhs));
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs, _CharT __rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __lhs.push_back(__rhs);
            return std::__1::move(__lhs);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_string<_CharT, _Traits, _Allocator> &__lhs, basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept(noexcept(__lhs.swap(__rhs))swap(basic_string<_CharT, _Traits, _Allocator> &__lhs, basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept(noexcept(__lhs.swap(__rhs))) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __lhs.swap(__rhs);
        }

;
        typedef basic_string<char16_t> u16string;
        typedef basic_string<char32_t> u32string;
        int stoi(const string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        long stol(const string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        unsigned long stoul(const string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        long long stoll(const string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        unsigned long long stoull(const string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        float stof(const string &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        double stod(const string &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        long double stold(const string &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        string to_string(int __val) __attribute__((visibility("default")));
        string to_string(unsigned int __val) __attribute__((visibility("default")));
        string to_string(long __val) __attribute__((visibility("default")));
        string to_string(unsigned long __val) __attribute__((visibility("default")));
        string to_string(long long __val) __attribute__((visibility("default")));
        string to_string(unsigned long long __val) __attribute__((visibility("default")));
        string to_string(float __val) __attribute__((visibility("default")));
        string to_string(double __val) __attribute__((visibility("default")));
        string to_string(long double __val) __attribute__((visibility("default")));
        int stoi(const wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        long stol(const wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        unsigned long stoul(const wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        long long stoll(const wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        unsigned long long stoull(const wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        float stof(const wstring &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        double stod(const wstring &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        long double stold(const wstring &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        wstring to_wstring(int __val) __attribute__((visibility("default")));
        wstring to_wstring(unsigned int __val) __attribute__((visibility("default")));
        wstring to_wstring(long __val) __attribute__((visibility("default")));
        wstring to_wstring(unsigned long __val) __attribute__((visibility("default")));
        wstring to_wstring(long long __val) __attribute__((visibility("default")));
        wstring to_wstring(unsigned long long __val) __attribute__((visibility("default")));
        wstring to_wstring(float __val) __attribute__((visibility("default")));
        wstring to_wstring(double __val) __attribute__((visibility("default")));
        wstring to_wstring(long double __val) __attribute__((visibility("default")));
        const typename basic_string<_CharT, _Traits, _Allocator>::size_type npos;
        struct __attribute__((type_visibility("default"))) hash : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t> {
            size_t operator()(const basic_string<_CharT, _Traits, _Allocator> &__val) const noexcept;
        };
        size_t operator()(const basic_string<_CharT, _Traits, _Allocator> &__val) const noexcept         {
            return __do_string_hash(__val.data(), __val.data() + __val.size());
        }


        template <class _CharT, class _Traits, class _Allocator> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Allocator> &__str);
        template <class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str);
        template <class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm);
        template <class _CharT, class _Traits, class _Allocator> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _CharT, class _Traits, class _Allocator> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _CharT, class _Traits, class _Allocator> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        class __attribute__((type_visibility("default"))) basic_string : private __basic_string_common<true> {
        public:
            typedef std::__1::basic_string<char> __self;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::char_type value_type;
            typedef std::__1::allocator<char> allocator_type;
            typedef allocator_traits<allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef value_type &reference;
            typedef const value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
            static_assert((is_same<char, value_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<pointer> iterator;
            typedef __wrap_iter<const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                size_type __cap_;
                size_type __size_;
                pointer __data_;
            };
            enum  {
                __short_mask = 1
            };
            enum  {
                __long_mask = 1UL
            };
            enum  {
                __min_cap = (sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long) - 1) / sizeof(value_type) > 2 ? (sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long) - 1) / sizeof(value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    value_type __lx;
                };
                value_type __data_[23];
            };
            union __ulx {
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long __lx;
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__ulx) / sizeof(size_type)
            };
            struct __raw {
                size_type __words[3];
            };
            struct __rep {
                union {
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long __l;
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__short __s;
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, allocator_type> __r_;
        public:
            static const size_type npos = -1;
            basic_string() __attribute__((always_inline));
            explicit basic_string(const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<char> &__str);
            basic_string(const std::__1::basic_string<char> &__str, const allocator_type &__a);
            basic_string(std::__1::basic_string<char> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::valuebasic_string(std::__1::basic_string<char> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::value) : __basic_string_common<true>(), __r_(std::__1::move(__str.__r_)) __attribute__((always_inline))             {
                __str.__zero();
            }


            basic_string(std::__1::basic_string<char> &&__str, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s) __attribute__((always_inline));
            basic_string(const value_type *__s, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n, const allocator_type &__a) __attribute__((always_inline));
            basic_string(size_type __n, value_type __c) : __basic_string_common<true>(), __r_() __attribute__((always_inline))             {
                this->__init(__n, __c);
            }


            basic_string(size_type __n, value_type __c, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<char> &__str, size_type __pos, size_type __n, const allocator_type &__a);
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last) __attribute__((always_inline));
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last, const allocator_type &__a) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il, const allocator_type &__a) __attribute__((always_inline));
            ~std::__1::basic_string<char>() noexcept;
            std::__1::basic_string<char> &operator=(const std::__1::basic_string<char> &__str);
            std::__1::basic_string<char> &operator=(std::__1::basic_string<char> &&__str) __attribute__((always_inline));
            std::__1::basic_string<char> &operator=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<char> &operator=(value_type __c);
            std::__1::basic_string<char> &operator=(initializer_list<value_type> __il) __attribute__((always_inline));
            iterator begin() noexcept __attribute__((always_inline));
            const_iterator begin() const noexcept __attribute__((always_inline));
            iterator end() noexcept __attribute__((always_inline));
            const_iterator end() const noexcept __attribute__((always_inline));
            reverse_iterator rbegin() noexcept __attribute__((always_inline));
            const_reverse_iterator rbegin() const noexcept __attribute__((always_inline));
            reverse_iterator rend() noexcept __attribute__((always_inline));
            const_reverse_iterator rend() const noexcept __attribute__((always_inline));
            const_iterator cbegin() const noexcept __attribute__((always_inline));
            const_iterator cend() const noexcept __attribute__((always_inline));
            const_reverse_iterator crbegin() const noexcept __attribute__((always_inline));
            const_reverse_iterator crend() const noexcept __attribute__((always_inline));
            size_type size() const noexcept __attribute__((always_inline));
            size_type length() const noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            size_type capacity() const noexcept __attribute__((always_inline));
            void resize(size_type __n, value_type __c);
            void resize(size_type __n) __attribute__((always_inline));
            void reserve(size_type res_arg);
            void shrink_to_fit() noexcept __attribute__((always_inline));
            void clear() noexcept __attribute__((always_inline));
            bool empty() const noexcept __attribute__((always_inline));
            const_reference operator[](size_type __pos) const __attribute__((always_inline));
            reference operator[](size_type __pos) __attribute__((always_inline));
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__1::basic_string<char> &operator+=(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &operator+=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<char> &operator+=(value_type __c) __attribute__((always_inline));
            std::__1::basic_string<char> &operator+=(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<char> &append(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &append(const std::__1::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<char> &append(const value_type *__s, size_type __n);
            std::__1::basic_string<char> &append(const value_type *__s);
            std::__1::basic_string<char> &append(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<char> &>::type append(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<char> &>::type append(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<char> &append(initializer_list<value_type> __il) __attribute__((always_inline));
            void push_back(value_type __c);
            void pop_back() __attribute__((always_inline));
            reference front() __attribute__((always_inline));
            const_reference front() const __attribute__((always_inline));
            reference back() __attribute__((always_inline));
            const_reference back() const __attribute__((always_inline));
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &assign(std::__1::basic_string<char> &&str) __attribute__((always_inline));
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<char> &assign(const value_type *__s, size_type __n);
            std::__1::basic_string<char> &assign(const value_type *__s);
            std::__1::basic_string<char> &assign(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<char> &>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<char> &>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<char> &assign(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<char> &insert(size_type __pos1, const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &insert(size_type __pos1, const std::__1::basic_string<char> &__str, size_type __pos2, size_type __n);
            std::__1::basic_string<char> &insert(size_type __pos, const value_type *__s, size_type __n);
            std::__1::basic_string<char> &insert(size_type __pos, const value_type *__s);
            std::__1::basic_string<char> &insert(size_type __pos, size_type __n, value_type __c);
            iterator insert(const_iterator __pos, value_type __c);
            iterator insert(const_iterator __pos, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, iterator>::type insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, iterator>::type insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
            iterator insert(const_iterator __pos, initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<char> &erase(size_type __pos, size_type __n);
            iterator erase(const_iterator __pos) __attribute__((always_inline));
            iterator erase(const_iterator __first, const_iterator __last) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str, size_type __pos2, size_type __n2);
            std::__1::basic_string<char> &replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2);
            std::__1::basic_string<char> &replace(size_type __pos, size_type __n1, const value_type *__s);
            std::__1::basic_string<char> &replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value, basic_string<char> &>::type replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
            std::__1::basic_string<char> &replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il) __attribute__((always_inline));
            size_type copy(value_type *__s, size_type __n, size_type __pos) const;
            std::__1::basic_string<char> substr(size_type __pos, size_type __n) const __attribute__((always_inline));
            void swap(std::__1::basic_string<char> &__str) __attribute__((always_inline));
            const value_type *c_str() const noexcept __attribute__((always_inline));
            const value_type *data() const noexcept __attribute__((always_inline))             {
                return std::__1::__to_raw_pointer(this->__get_pointer());
            }


            allocator_type get_allocator() const noexcept __attribute__((always_inline));
            size_type find(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(value_type __c, size_type __pos) const noexcept;
            size_type rfind(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type rfind(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(value_type __c, size_type __pos) const noexcept;
            size_type find_first_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const std::__1::basic_string<char> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            int compare(const std::__1::basic_string<char> &__str) const noexcept __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str) const __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<char> &__str, size_type __pos2, size_type __n2) const;
            int compare(const value_type *__s) const noexcept;
            int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
            int compare(size_type __pos1, size_type __n1, const value_type *__s, size_type __n2) const;
            bool __invariants() const __attribute__((always_inline));
            bool __is_long() const noexcept __attribute__((always_inline))             {
                return bool(this->__r_.first().__s.__size_ & __short_mask);
            }


        private:
            allocator_type &__alloc() noexcept __attribute__((always_inline));
            const allocator_type &__alloc() const noexcept __attribute__((always_inline));
            void __set_short_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_short_size() const noexcept __attribute__((always_inline));
            void __set_long_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_size() const noexcept __attribute__((always_inline));
            void __set_size(size_type __s) noexcept __attribute__((always_inline));
            void __set_long_cap(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_cap() const noexcept __attribute__((always_inline));
            void __set_long_pointer(pointer __p) noexcept __attribute__((always_inline));
            pointer __get_long_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_long_pointer() const noexcept __attribute__((always_inline))             {
                return this->__r_.first().__l.__data_;
            }


            pointer __get_short_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_short_pointer() const noexcept __attribute__((always_inline))             {
                return pointer_traits<const_pointer>::pointer_to(this->__r_.first().__s.__data_[0]);
            }


            pointer __get_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_pointer() const noexcept __attribute__((always_inline))             {
                return this->__is_long() ? this->__get_long_pointer() : this->__get_short_pointer();
            }


            void __zero() noexcept __attribute__((always_inline))             {
                size_type (&__a)[3] = this->__r_.first().__r.__words;
                for (unsigned int __i = 0; __i < __n_words; ++__i) 
                    __a[__i] = 0;
            }


            template <size_type __a> static size_type __align_it(size_type __s) noexcept __attribute__((always_inline));
            enum  {
                __alignment = 16
            };
            static size_type __recommend(size_type __s) noexcept __attribute__((always_inline));
            void __init(const value_type *__s, size_type __sz, size_type __reserve);
            void __init(const value_type *__s, size_type __sz);
            void __init(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add);
            void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add, const value_type *__p_new_stuff);
            void __erase_to_end(size_type __pos) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<char> &__str) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<char> &__str, true_type) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<char> &, false_type) noexcept __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<char> &__str, false_type) __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<char> &__str, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<char> &__str) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<char> &__c, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<char> &, false_type) noexcept __attribute__((always_inline));
            void __invalidate_all_iterators() __attribute__((always_inline));
            void __invalidate_iterators_past(size_type) __attribute__((always_inline));
            friend std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const std::__1::basic_string<char> &);
            friend std::__1::basic_string<char> operator+(const value_type *, const std::__1::basic_string<char> &);
            friend std::__1::basic_string<char> operator+(value_type, const std::__1::basic_string<char> &);
            friend std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, const value_type *);
            friend std::__1::basic_string<char> operator+(const std::__1::basic_string<char> &, value_type);
        };
        class __attribute__((type_visibility("default"))) basic_string : private __basic_string_common<true> {
        public:
            typedef std::__1::basic_string<wchar_t> __self;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::char_type value_type;
            typedef std::__1::allocator<wchar_t> allocator_type;
            typedef allocator_traits<allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef value_type &reference;
            typedef const value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
            static_assert((is_same<wchar_t, value_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<pointer> iterator;
            typedef __wrap_iter<const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                size_type __cap_;
                size_type __size_;
                pointer __data_;
            };
            enum  {
                __short_mask = 1
            };
            enum  {
                __long_mask = 1UL
            };
            enum  {
                __min_cap = (sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long) - 1) / sizeof(value_type) > 2 ? (sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long) - 1) / sizeof(value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    value_type __lx;
                };
                value_type __data_[5];
            };
            union __ulx {
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long __lx;
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__ulx) / sizeof(size_type)
            };
            struct __raw {
                size_type __words[3];
            };
            struct __rep {
                union {
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long __l;
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__short __s;
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, allocator_type> __r_;
        public:
            static const size_type npos = -1;
            basic_string() __attribute__((always_inline));
            explicit basic_string(const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<wchar_t> &__str);
            basic_string(const std::__1::basic_string<wchar_t> &__str, const allocator_type &__a);
            basic_string(std::__1::basic_string<wchar_t> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::valuebasic_string(std::__1::basic_string<wchar_t> &&__str) noexcept(is_nothrow_move_constructible<allocator_type>::value) : __basic_string_common<true>(), __r_(std::__1::move(__str.__r_)) __attribute__((always_inline))             {
                __str.__zero();
            }


            basic_string(std::__1::basic_string<wchar_t> &&__str, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s) __attribute__((always_inline));
            basic_string(const value_type *__s, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n) __attribute__((always_inline));
            basic_string(const value_type *__s, size_type __n, const allocator_type &__a) __attribute__((always_inline));
            basic_string(size_type __n, value_type __c) __attribute__((always_inline));
            basic_string(size_type __n, value_type __c, const allocator_type &__a) __attribute__((always_inline));
            basic_string(const std::__1::basic_string<wchar_t> &__str, size_type __pos, size_type __n, const allocator_type &__a);
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last) __attribute__((always_inline));
            template <class _InputIterator> basic_string(_InputIterator __first, _InputIterator __last, const allocator_type &__a) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il) __attribute__((always_inline));
            basic_string(initializer_list<value_type> __il, const allocator_type &__a) __attribute__((always_inline));
            ~std::__1::basic_string<wchar_t>() noexcept;
            std::__1::basic_string<wchar_t> &operator=(const std::__1::basic_string<wchar_t> &__str);
            std::__1::basic_string<wchar_t> &operator=(std::__1::basic_string<wchar_t> &&__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator=(value_type __c);
            std::__1::basic_string<wchar_t> &operator=(initializer_list<value_type> __il) __attribute__((always_inline));
            iterator begin() noexcept __attribute__((always_inline));
            const_iterator begin() const noexcept __attribute__((always_inline));
            iterator end() noexcept __attribute__((always_inline));
            const_iterator end() const noexcept __attribute__((always_inline));
            reverse_iterator rbegin() noexcept __attribute__((always_inline));
            const_reverse_iterator rbegin() const noexcept __attribute__((always_inline));
            reverse_iterator rend() noexcept __attribute__((always_inline));
            const_reverse_iterator rend() const noexcept __attribute__((always_inline));
            const_iterator cbegin() const noexcept __attribute__((always_inline));
            const_iterator cend() const noexcept __attribute__((always_inline));
            const_reverse_iterator crbegin() const noexcept __attribute__((always_inline));
            const_reverse_iterator crend() const noexcept __attribute__((always_inline));
            size_type size() const noexcept __attribute__((always_inline));
            size_type length() const noexcept __attribute__((always_inline));
            size_type max_size() const noexcept __attribute__((always_inline));
            size_type capacity() const noexcept __attribute__((always_inline));
            void resize(size_type __n, value_type __c);
            void resize(size_type __n) __attribute__((always_inline));
            void reserve(size_type res_arg);
            void shrink_to_fit() noexcept __attribute__((always_inline));
            void clear() noexcept __attribute__((always_inline));
            bool empty() const noexcept __attribute__((always_inline));
            const_reference operator[](size_type __pos) const __attribute__((always_inline));
            reference operator[](size_type __pos) __attribute__((always_inline));
            const_reference at(size_type __n) const;
            reference at(size_type __n);
            std::__1::basic_string<wchar_t> &operator+=(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator+=(const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator+=(value_type __c) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &operator+=(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<wchar_t> &append(const value_type *__s, size_type __n);
            std::__1::basic_string<wchar_t> &append(const value_type *__s);
            std::__1::basic_string<wchar_t> &append(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type append(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<wchar_t> &>::type append(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<wchar_t> &append(initializer_list<value_type> __il) __attribute__((always_inline));
            void push_back(value_type __c);
            void pop_back() __attribute__((always_inline));
            reference front() __attribute__((always_inline));
            const_reference front() const __attribute__((always_inline));
            reference back() __attribute__((always_inline));
            const_reference back() const __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &assign(std::__1::basic_string<wchar_t> &&str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t> &__str, size_type __pos, size_type __n);
            std::__1::basic_string<wchar_t> &assign(const value_type *__s, size_type __n);
            std::__1::basic_string<wchar_t> &assign(const value_type *__s);
            std::__1::basic_string<wchar_t> &assign(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, basic_string<wchar_t> &>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<wchar_t> &assign(initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &insert(size_type __pos1, const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &insert(size_type __pos1, const std::__1::basic_string<wchar_t> &__str, size_type __pos2, size_type __n);
            std::__1::basic_string<wchar_t> &insert(size_type __pos, const value_type *__s, size_type __n);
            std::__1::basic_string<wchar_t> &insert(size_type __pos, const value_type *__s);
            std::__1::basic_string<wchar_t> &insert(size_type __pos, size_type __n, value_type __c);
            iterator insert(const_iterator __pos, value_type __c);
            iterator insert(const_iterator __pos, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, iterator>::type insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, iterator>::type insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
            iterator insert(const_iterator __pos, initializer_list<value_type> __il) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &erase(size_type __pos, size_type __n);
            iterator erase(const_iterator __pos) __attribute__((always_inline));
            iterator erase(const_iterator __first, const_iterator __last) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2);
            std::__1::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const value_type *__s, size_type __n2);
            std::__1::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, const value_type *__s);
            std::__1::basic_string<wchar_t> &replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s, size_type __n) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, const value_type *__s) __attribute__((always_inline));
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) __attribute__((always_inline));
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
            std::__1::basic_string<wchar_t> &replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il) __attribute__((always_inline));
            size_type copy(value_type *__s, size_type __n, size_type __pos) const;
            std::__1::basic_string<wchar_t> substr(size_type __pos, size_type __n) const __attribute__((always_inline));
            void swap(std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            const value_type *c_str() const noexcept __attribute__((always_inline));
            const value_type *data() const noexcept __attribute__((always_inline));
            allocator_type get_allocator() const noexcept __attribute__((always_inline));
            size_type find(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find(value_type __c, size_type __pos) const noexcept;
            size_type rfind(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type rfind(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type rfind(value_type __c, size_type __pos) const noexcept;
            size_type find_first_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_first_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_first_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const std::__1::basic_string<wchar_t> &__str, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(const value_type *__s, size_type __pos, size_type __n) const noexcept;
            size_type find_last_not_of(const value_type *__s, size_type __pos) const noexcept __attribute__((always_inline));
            size_type find_last_not_of(value_type __c, size_type __pos) const noexcept __attribute__((always_inline));
            int compare(const std::__1::basic_string<wchar_t> &__str) const noexcept __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str) const __attribute__((always_inline));
            int compare(size_type __pos1, size_type __n1, const std::__1::basic_string<wchar_t> &__str, size_type __pos2, size_type __n2) const;
            int compare(const value_type *__s) const noexcept;
            int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
            int compare(size_type __pos1, size_type __n1, const value_type *__s, size_type __n2) const;
            bool __invariants() const __attribute__((always_inline));
            bool __is_long() const noexcept __attribute__((always_inline));
        private:
            allocator_type &__alloc() noexcept __attribute__((always_inline));
            const allocator_type &__alloc() const noexcept __attribute__((always_inline));
            void __set_short_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_short_size() const noexcept __attribute__((always_inline));
            void __set_long_size(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_size() const noexcept __attribute__((always_inline));
            void __set_size(size_type __s) noexcept __attribute__((always_inline));
            void __set_long_cap(size_type __s) noexcept __attribute__((always_inline));
            size_type __get_long_cap() const noexcept __attribute__((always_inline));
            void __set_long_pointer(pointer __p) noexcept __attribute__((always_inline));
            pointer __get_long_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_long_pointer() const noexcept __attribute__((always_inline));
            pointer __get_short_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_short_pointer() const noexcept __attribute__((always_inline));
            pointer __get_pointer() noexcept __attribute__((always_inline));
            const_pointer __get_pointer() const noexcept __attribute__((always_inline));
            void __zero() noexcept __attribute__((always_inline))             {
                size_type (&__a)[3] = this->__r_.first().__r.__words;
                for (unsigned int __i = 0; __i < __n_words; ++__i) 
                    __a[__i] = 0;
            }


            template <size_type __a> static size_type __align_it(size_type __s) noexcept __attribute__((always_inline));
            enum  {
                __alignment = 16
            };
            static size_type __recommend(size_type __s) noexcept __attribute__((always_inline));
            void __init(const value_type *__s, size_type __sz, size_type __reserve);
            void __init(const value_type *__s, size_type __sz);
            void __init(size_type __n, value_type __c);
            template <class _InputIterator> typename enable_if<__is_input_iterator<_InputIterator>::value && !__is_forward_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add);
            void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz, size_type __n_copy, size_type __n_del, size_type __n_add, const value_type *__p_new_stuff);
            void __erase_to_end(size_type __pos) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &__str, true_type) __attribute__((always_inline));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &, false_type) noexcept __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<wchar_t> &__str, false_type) __attribute__((always_inline));
            void __move_assign(std::__1::basic_string<wchar_t> &__str, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &__str) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &__c, true_type) __attribute__((always_inline));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &, false_type) noexcept __attribute__((always_inline));
            void __invalidate_all_iterators() __attribute__((always_inline));
            void __invalidate_iterators_past(size_type) __attribute__((always_inline));
            friend std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const std::__1::basic_string<wchar_t> &);
            friend std::__1::basic_string<wchar_t> operator+(const value_type *, const std::__1::basic_string<wchar_t> &);
            friend std::__1::basic_string<wchar_t> operator+(value_type, const std::__1::basic_string<wchar_t> &);
            friend std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, const value_type *);
            friend std::__1::basic_string<wchar_t> operator+(const std::__1::basic_string<wchar_t> &, value_type);
        };
    }
}
namespace std {
    inline namespace __1 {
        using ::clock_t;
        using ::size_t;
        using ::time_t;
        using ::tm;
        using ::clock;
        using ::difftime;
        using ::mktime;
        using ::time;
        using ::asctime;
        using ::ctime;
        using ::gmtime;
        using ::localtime;
        using ::strftime;
    }
}
namespace std {
    inline namespace __1 {
        template <intmax_t _Xp = 0, intmax_t _Yp = 0> struct __static_gcd {
            static const intmax_t value = 1;
        }
template <intmax_t _Xp = 1, intmax_t _Yp = 1000000> struct __static_gcd {
            static const intmax_t value = __static_gcd<1000000L, 1L % 1000000L>::value;
        }
template <intmax_t _Xp = 1000000, intmax_t _Yp = 1> struct __static_gcd {
            static const intmax_t value = __static_gcd<1L, 1000000L % 1L>::value;
        }
template <intmax_t _Xp = 1, intmax_t _Yp = 0> struct __static_gcd {
            static const intmax_t value = 1L;
        }
template <intmax_t _Xp = 1, intmax_t _Yp = 1000000000> struct __static_gcd {
            static const intmax_t value = __static_gcd<1000000000L, 1L % 1000000000L>::value;
        }
template <intmax_t _Xp = 1000000000, intmax_t _Yp = 1> struct __static_gcd {
            static const intmax_t value = __static_gcd<1L, 1000000000L % 1L>::value;
        }
template <intmax_t _Xp = 1, intmax_t _Yp = 1> struct __static_gcd {
            static const intmax_t value = __static_gcd<1L, 1L % 1L>::value;
        }
template <intmax_t _Xp = 1000000000, intmax_t _Yp = 1000000000> struct __static_gcd {
            static const intmax_t value = __static_gcd<1000000000L, 1000000000L % 1000000000L>::value;
        }
template <intmax_t _Xp = 1000000000, intmax_t _Yp = 0> struct __static_gcd {
            static const intmax_t value = 1000000000L;
        }
template <intmax_t _Xp = 1000000, intmax_t _Yp = 1000000> struct __static_gcd {
            static const intmax_t value = __static_gcd<1000000L, 1000000L % 1000000L>::value;
        }
template <intmax_t _Xp = 1000000, intmax_t _Yp = 0> struct __static_gcd {
            static const intmax_t value = 1000000L;
        }
template <intmax_t _Xp, intmax_t _Yp> struct __static_gcd {
            static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
        };
        struct __static_gcd {
            static const intmax_t value = _Xp;
        };
        struct __static_gcd {
            static const intmax_t value = 1;
        };
        template <intmax_t _Xp = 1000000000, intmax_t _Yp = 1000000000> struct __static_lcm {
            static const intmax_t value = 1000000000L / __static_gcd<1000000000L, 1000000000L>::value * 1000000000L;
        }
template <intmax_t _Xp, intmax_t _Yp> struct __static_lcm {
            static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
        };
        template <intmax_t _Xp = 1> struct __static_abs {
            static const intmax_t value = 1L < 0 ? -1L : 1L;
        }
template <intmax_t _Xp = 1000000> struct __static_abs {
            static const intmax_t value = 1000000L < 0 ? -1000000L : 1000000L;
        }
template <intmax_t _Xp = 1000000000> struct __static_abs {
            static const intmax_t value = 1000000000L < 0 ? -1000000000L : 1000000000L;
        }
template <intmax_t _Xp> struct __static_abs {
            static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
        };
        template <intmax_t _Xp = 1> struct __static_sign {
            static const intmax_t value = 1L == 0 ? 0 : (1L < 0 ? -1 : 1);
        }
template <intmax_t _Xp = 1000000> struct __static_sign {
            static const intmax_t value = 1000000L == 0 ? 0 : (1000000L < 0 ? -1 : 1);
        }
template <intmax_t _Xp = 1000000000> struct __static_sign {
            static const intmax_t value = 1000000000L == 0 ? 0 : (1000000000L < 0 ? -1 : 1);
        }
template <intmax_t _Xp> struct __static_sign {
            static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
        };
        template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value> class __ll_add;
        class __ll_add {
            static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
            static const intmax_t max = -min;
            static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
        public:
            static const intmax_t value = _Xp + _Yp;
        };
        class __ll_add {
        public:
            static const intmax_t value = _Xp;
        };
        class __ll_add {
            static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
            static const intmax_t max = -min;
            static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
        public:
            static const intmax_t value = _Xp + _Yp;
        };
        template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value> class __ll_sub;
        class __ll_sub {
            static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
            static const intmax_t max = -min;
            static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
        public:
            static const intmax_t value = _Xp - _Yp;
        };
        class __ll_sub {
        public:
            static const intmax_t value = _Xp;
        };
        class __ll_sub {
            static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
            static const intmax_t max = -min;
            static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
        public:
            static const intmax_t value = _Xp - _Yp;
        };
        template <intmax_t _Xp = 0, intmax_t _Yp = 0> class __ll_mul {
        public:
            static const intmax_t value = 0;
        }
template <intmax_t _Xp = 1, intmax_t _Yp = 1> class __ll_mul {
            static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
            static const intmax_t min = nan + 1;
            static const intmax_t max = -min;
            static const intmax_t __a_x = __static_abs<1L>::value;
            static const intmax_t __a_y = __static_abs<1L>::value;
            static_assert(1L != nan && 1L != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
        public:
            static const intmax_t value = 1L * 1L;
        }
template <intmax_t _Xp, intmax_t _Yp> class __ll_mul {
            static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
            static const intmax_t min = nan + 1;
            static const intmax_t max = -min;
            static const intmax_t __a_x = __static_abs<_Xp>::value;
            static const intmax_t __a_y = __static_abs<_Yp>::value;
            static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
        public:
            static const intmax_t value = _Xp * _Yp;
        };
        class __ll_mul {
        public:
            static const intmax_t value = 0;
        };
        class __ll_mul {
        public:
            static const intmax_t value = 0;
        };
        class __ll_mul {
        public:
            static const intmax_t value = 0;
        };
        template <intmax_t _Xp, intmax_t _Yp> class __ll_div {
            static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
            static const intmax_t min = nan + 1;
            static const intmax_t max = -min;
            static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
        public:
            static const intmax_t value = _Xp / _Yp;
        };
        template <intmax_t _Num = 1, intmax_t _Den = 1000000000000000000> class ratio
template <intmax_t _Num = 1, intmax_t _Den = 1000000000000000> class ratio
template <intmax_t _Num = 1, intmax_t _Den = 1000000000000> class ratio
template <intmax_t _Num = 1, intmax_t _Den = 1000000000> class ratio {
            static_assert(__static_abs<1L>::value >= 0, "ratio numerator is out of range");
            static_assert(1000000000L != 0, "ratio divide by 0");
            static_assert(__static_abs<1000000000L>::value > 0, "ratio denominator is out of range");
            static const intmax_t __na = __static_abs<1L>::value;
            static const intmax_t __da = __static_abs<1000000000L>::value;
            static const intmax_t __s = __static_sign<1L>::value * __static_sign<1000000000L>::value;
            static const intmax_t __gcd = __static_gcd<__na, __da>::value;
        public:
            static const intmax_t num = __s * __na / __gcd;
            static const intmax_t den = __da / __gcd;
            typedef ratio<num, den> type;
        }
template <intmax_t _Num = 1, intmax_t _Den = 1000000> class ratio {
            static_assert(__static_abs<1L>::value >= 0, "ratio numerator is out of range");
            static_assert(1000000L != 0, "ratio divide by 0");
            static_assert(__static_abs<1000000L>::value > 0, "ratio denominator is out of range");
            static const intmax_t __na = __static_abs<1L>::value;
            static const intmax_t __da = __static_abs<1000000L>::value;
            static const intmax_t __s = __static_sign<1L>::value * __static_sign<1000000L>::value;
            static const intmax_t __gcd = __static_gcd<__na, __da>::value;
        public:
            static const intmax_t num = __s * __na / __gcd;
            static const intmax_t den = __da / __gcd;
            typedef ratio<num, den> type;
        }
template <intmax_t _Num = 1, intmax_t _Den = 1000> class ratio
template <intmax_t _Num = 1, intmax_t _Den = 100> class ratio
template <intmax_t _Num = 1, intmax_t _Den = 10> class ratio
template <intmax_t _Num = 10, intmax_t _Den = 1> class ratio
template <intmax_t _Num = 100, intmax_t _Den = 1> class ratio
template <intmax_t _Num = 1000, intmax_t _Den = 1> class ratio
template <intmax_t _Num = 1000000, intmax_t _Den = 1> class ratio
template <intmax_t _Num = 1000000000, intmax_t _Den = 1> class ratio
template <intmax_t _Num = 1000000000000, intmax_t _Den = 1> class ratio
template <intmax_t _Num = 1000000000000000, intmax_t _Den = 1> class ratio
template <intmax_t _Num = 1000000000000000000, intmax_t _Den = 1> class ratio
template <intmax_t _Num = 1, intmax_t _Den = 1> class ratio {
            static_assert(__static_abs<1L>::value >= 0, "ratio numerator is out of range");
            static_assert(1L != 0, "ratio divide by 0");
            static_assert(__static_abs<1L>::value > 0, "ratio denominator is out of range");
            static const intmax_t __na = __static_abs<1L>::value;
            static const intmax_t __da = __static_abs<1L>::value;
            static const intmax_t __s = __static_sign<1L>::value * __static_sign<1L>::value;
            static const intmax_t __gcd = __static_gcd<__na, __da>::value;
        public:
            static const intmax_t num = __s * __na / __gcd;
            static const intmax_t den = __da / __gcd;
            typedef ratio<num, den> type;
        }
template <intmax_t _Num = 60, intmax_t _Den = 1> class ratio
template <intmax_t _Num = 3600, intmax_t _Den = 1> class ratio
template <intmax_t _Num, intmax_t _Den = 1> class __attribute__((type_visibility("default"))) ratio {
            static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
            static_assert(_Den != 0, "ratio divide by 0");
            static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
            static const intmax_t __na = __static_abs<_Num>::value;
            static const intmax_t __da = __static_abs<_Den>::value;
            static const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
            static const intmax_t __gcd = __static_gcd<__na, __da>::value;
        public:
            static const intmax_t num = __s * __na / __gcd;
            static const intmax_t den = __da / __gcd;
            typedef ratio<num, den> type;
        };
        const intmax_t num;
        const intmax_t den;
        template <class _Tp = std::__1::ratio<1, 1000000>> struct __is_ratio : true_type {
        }
template <class _Tp = std::__1::ratio<1, 1000000000>> struct __is_ratio : true_type {
        }
template <class _Tp> struct __is_ratio : false_type {
        };
        struct __is_ratio : true_type {
        };
        typedef ratio<1LL, 1000000000000000000LL> atto;
        typedef ratio<1LL, 1000000000000000LL> femto;
        typedef ratio<1LL, 1000000000000LL> pico;
        typedef ratio<1LL, 1000000000LL> nano;
        typedef ratio<1LL, 1000000LL> micro;
        typedef ratio<1LL, 1000LL> milli;
        typedef ratio<1LL, 100LL> centi;
        typedef ratio<1LL, 10LL> deci;
        typedef ratio<10LL, 1LL> deca;
        typedef ratio<100LL, 1LL> hecto;
        typedef ratio<1000LL, 1LL> kilo;
        typedef ratio<1000000LL, 1LL> mega;
        typedef ratio<1000000000LL, 1LL> giga;
        typedef ratio<1000000000000LL, 1LL> tera;
        typedef ratio<1000000000000000LL, 1LL> peta;
        typedef ratio<1000000000000000000LL, 1LL> exa;
        template <class _R1, class _R2> struct __ratio_multiply {
        private:
            static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
            static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
        public:
            typedef typename ratio<__ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value, __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value>::type type;
        };
        template <class _R1, class _R2> using ratio_multiply = typename __ratio_multiply<_R1, _R2>::type;
        template <class _R1 = std::__1::ratio<1, 1000000000>, class _R2 = std::__1::ratio<1, 1000000000>> struct __ratio_divide {
        private:
            static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000000>::num, ratio<1, 1000000000>::num>::value;
            static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000000>::den, ratio<1, 1000000000>::den>::value;
        public:
            typedef typename ratio<__ll_mul<ratio<1, 1000000000>::num / __gcd_n1_n2, ratio<1, 1000000000>::den / __gcd_d1_d2>::value, __ll_mul<ratio<1, 1000000000>::num / __gcd_n1_n2, ratio<1, 1000000000>::den / __gcd_d1_d2>::value>::type type;
        }
template <class _R1, class _R2> struct __ratio_divide {
        private:
            static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
            static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        public:
            typedef typename ratio<__ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value, __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::type type;
        };
        template <class _R1, class _R2> using ratio_divide = typename __ratio_divide<_R1, _R2>::type;
        template <class _R1, class _R2> struct __ratio_add {
        private:
            static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
            static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        public:
            typedef typename ratio_multiply<ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>, ratio<__ll_add<__ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value, __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::value, _R2::den> >::type type;
        };
        template <class _R1, class _R2> using ratio_add = typename __ratio_add<_R1, _R2>::type;
        template <class _R1, class _R2> struct __ratio_subtract {
        private:
            static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
            static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        public:
            typedef typename ratio_multiply<ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>, ratio<__ll_sub<__ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value, __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::value, _R2::den> >::type type;
        };
        template <class _R1, class _R2> using ratio_subtract = typename __ratio_subtract<_R1, _R2>::type;
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_equal : public integral_constant<bool, ((_R1::num == _R2::num && _R1::den == _R2::den))> {
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_not_equal : public integral_constant<bool, ((!ratio_equal<_R1, _R2>::value))> {
        };
        template <class _R1, class _R2, bool _Odd = false, intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den, intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den> struct __ratio_less1 {
            static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
        };
        struct __ratio_less1 {
            static const bool value = false;
        };
        struct __ratio_less1 {
            static const bool value = !_Odd;
        };
        struct __ratio_less1 {
            static const bool value = _Odd;
        };
        struct __ratio_less1 {
            static const bool value = __ratio_less1<ratio<_R1::den, _M1>, ratio<_R2::den, _M2>, !_Odd>::value;
        };
        template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value, intmax_t _S2 = __static_sign<_R2::num>::value> struct __ratio_less {
            static const bool value = _S1 < _S2;
        };
        struct __ratio_less {
            static const bool value = __ratio_less1<_R1, _R2>::value;
        };
        struct __ratio_less {
            static const bool value = __ratio_less1<ratio<- _R2::num, _R2::den>, ratio<- _R1::num, _R1::den> >::value;
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_less : public integral_constant<bool, ((__ratio_less<_R1, _R2>::value))> {
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_less_equal : public integral_constant<bool, ((!ratio_less<_R2, _R1>::value))> {
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_greater : public integral_constant<bool, ((ratio_less<_R2, _R1>::value))> {
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_greater_equal : public integral_constant<bool, ((!ratio_less<_R1, _R2>::value))> {
        };
        template <class _R1 = std::__1::ratio<1, 1000000000>, class _R2 = std::__1::ratio<1, 1000000000>> struct __ratio_gcd {
            typedef ratio<__static_gcd<ratio<1, 1000000000>::num, ratio<1, 1000000000>::num>::value, __static_lcm<ratio<1, 1000000000>::den, ratio<1, 1000000000>::den>::value> type;
        }
template <class _R1, class _R2> struct __ratio_gcd {
            typedef ratio<__static_gcd<_R1::num, _R2::num>::value, __static_lcm<_R1::den, _R2::den>::value> type;
        };
        const intmax_t num;
        const intmax_t den;
        const intmax_t num;
        const intmax_t den;
        const intmax_t num;
        const intmax_t den;
    }
}
namespace std {
    inline namespace __1 {
        namespace chrono {
            template <class _Rep = long long, class _Period = std::__1::ratio<1, 1000000000>> class duration {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000000>::num > 0, "duration period must be positive");
                template <class _R1 = std::__1::ratio<1, 1000000000>, class _R2 = std::__1::ratio<1, 1000000000>> struct __no_overflow {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000000>::num, ratio<1, 1000000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000000>::den, ratio<1, 1000000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp = 1, intmax_t _Yp = 1, bool __overflow = false> struct __mul {
                        static const intmax_t value = 1L * 1L;
                    }
template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul;
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                }
template <class _R1, class _R2> struct __no_overflow;
            public:
                typedef long long rep;
                typedef std::__1::ratio<1, 1000000000> period;
            private:
                rep __rep_;
            public:
                duration() __attribute__((always_inline)) = default;
                template <class _Rep2 = long long> constexpr explicit duration(const long long &__r, typename enable_if<is_convertible<long long, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<long long>::value)>::type * = 0) : __rep_(__r) __attribute__((always_inline))                 {
                }

template <class _Rep2> constexpr explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((always_inline));
                template <class _Rep2 = long long, class _Period2 = std::__1::ratio<1, 1000000000>> constexpr duration(const duration<long long, std::__1::ratio<1, 1000000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((always_inline))template <class _Rep2, class _Period2> constexpr duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((always_inline));
                constexpr rep count() const __attribute__((always_inline))                 {
                    return this->__rep_;
                }


                constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator+() const __attribute__((always_inline));
                constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator-() const __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator++() __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator++(int) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator--() __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator--(int) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator*=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator/=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator%=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &rhs) __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > zero() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > max() __attribute__((always_inline))                 {
                    return std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >(duration_values<rep>::max());
                }


            }
template <class _Rep = long long, class _Period = std::__1::ratio<1, 1000000>> class duration {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000>::num > 0, "duration period must be positive");
                template <class _R1 = std::__1::ratio<1, 1000000>, class _R2 = std::__1::ratio<1, 1000000>> struct __no_overflow {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000>::num, ratio<1, 1000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000>::den, ratio<1, 1000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp = 1, intmax_t _Yp = 1, bool __overflow = false> struct __mul {
                        static const intmax_t value = 1L * 1L;
                    }
template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul;
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                }
template <class _R1, class _R2> struct __no_overflow;
            public:
                typedef long long rep;
                typedef std::__1::ratio<1, 1000000> period;
            private:
                rep __rep_;
            public:
                duration() __attribute__((always_inline)) = default;
                template <class _Rep2> constexpr explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((always_inline));
                template <class _Rep2 = long long, class _Period2 = std::__1::ratio<1, 1000000>> constexpr duration(const duration<long long, std::__1::ratio<1, 1000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((always_inline))template <class _Rep2, class _Period2> constexpr duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((always_inline));
                constexpr rep count() const __attribute__((always_inline));
                constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator+() const __attribute__((always_inline));
                constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator-() const __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator++() __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator++(int) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator--() __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator--(int) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator*=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator/=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator%=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &rhs) __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > zero() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > max() __attribute__((always_inline));
            }
template <class _Rep = long long, class _Period = std::__1::ratio<1, 1000>> class duration
template <class _Rep = long long, class _Period = std::__1::ratio<1, 1>> class duration
template <class _Rep = long, class _Period = std::__1::ratio<60, 1>> class duration
template <class _Rep = long, class _Period = std::__1::ratio<3600, 1>> class duration
template <class _Rep = long double, class _Period = std::__1::ratio<1, 1000000000>> class duration {
                static_assert(!__is_duration<long double>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000000>::num > 0, "duration period must be positive");
                template <class _R1 = std::__1::ratio<1, 1000000000>, class _R2 = std::__1::ratio<1, 1000000000>> struct __no_overflow {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000000>::num, ratio<1, 1000000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000000>::den, ratio<1, 1000000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp = 1, intmax_t _Yp = 1, bool __overflow = false> struct __mul {
                        static const intmax_t value = 1L * 1L;
                    }
template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul;
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                }
template <class _R1, class _R2> struct __no_overflow;
            public:
                typedef long double rep;
                typedef std::__1::ratio<1, 1000000000> period;
            private:
                rep __rep_;
            public:
                duration() __attribute__((always_inline)) = default;
                template <class _Rep2 = long double> constexpr explicit duration(const long double &__r, typename enable_if<is_convertible<long double, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<long double>::value)>::type * = 0) : __rep_(__r) __attribute__((always_inline))                 {
                }

template <class _Rep2> constexpr explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((always_inline));
                template <class _Rep2 = long double, class _Period2 = std::__1::ratio<1, 1000000000>> constexpr duration(const duration<long double, std::__1::ratio<1, 1000000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000000>, period>::type::den == 1 && !treat_as_floating_point<long double>::value))>::type *) __attribute__((always_inline))template <class _Rep2 = long long, class _Period2 = std::__1::ratio<1, 1000000000>> constexpr duration(const duration<long long, std::__1::ratio<1, 1000000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type * = 0) : __rep_(std::__1::chrono::duration_cast<std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > >(__d).count()) __attribute__((always_inline))                 {
                }

template <class _Rep2, class _Period2> constexpr duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((always_inline));
                constexpr rep count() const __attribute__((always_inline))                 {
                    return this->__rep_;
                }


                constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > operator+() const __attribute__((always_inline));
                constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > operator-() const __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator++() __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > operator++(int) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator--() __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > operator--(int) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator+=(const std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator-=(const std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator*=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator/=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator%=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator%=(const std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &rhs) __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > zero() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > max() __attribute__((always_inline));
            }
template <class _Rep, class _Period = ratio<1>> class __attribute__((type_visibility("default"))) duration;
            template <class _Tp = long long> struct __is_duration : false_type {
            }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct __is_duration : true_type {
            }
template <class _Tp = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct __is_duration : true_type {
            }
template <class _Tp = long double> struct __is_duration : false_type {
            }
template <class _Tp = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct __is_duration : true_type {
            }
template <class _Tp> struct __is_duration : false_type {
            };
            struct __is_duration : true_type {
            };
            struct __is_duration : true_type {
            };
            struct __is_duration : true_type {
            };
            struct __is_duration : true_type {
            };
        }
        struct __attribute__((type_visibility("default"))) common_type {
            typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type, typename __ratio_gcd<_Period1, _Period2>::type> type;
        };
        namespace chrono {
            template <class _FromDuration = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, class _ToDuration = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >, class _Period = std::__1::ratio<1, 1>, bool = true, bool = true> struct __duration_cast {
                constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > operator()(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__fd) const __attribute__((always_inline))                 {
                    return std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >(static_cast<typename duration<long double, ratio<1, 1000000000> >::rep>(__fd.count()));
                }


            }
template <class _FromDuration, class _ToDuration, class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type, bool = _Period::num == 1, bool = _Period::den == 1> struct __duration_cast;
            struct __duration_cast {
                constexpr _ToDuration operator()(const _FromDuration &__fd) const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
                }


            };
            struct __duration_cast {
                constexpr _ToDuration operator()(const _FromDuration &__fd) const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
                    return _ToDuration(static_cast<typename _ToDuration::rep>(static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
                }


            };
            struct __duration_cast {
                constexpr _ToDuration operator()(const _FromDuration &__fd) const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
                    return _ToDuration(static_cast<typename _ToDuration::rep>(static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
                }


            };
            struct __duration_cast {
                constexpr _ToDuration operator()(const _FromDuration &__fd) const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
                    return _ToDuration(static_cast<typename _ToDuration::rep>(static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num) / static_cast<_Ct>(_Period::den)));
                }


            };
            template <class _ToDuration = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >, class _Rep = long long, class _Period = std::__1::ratio<1, 1000000000>> inline constexpr typename enable_if<__is_duration<duration<long double, ratio<1, 1000000000> > >::value, duration<long double, ratio<1, 1000000000> > >::type duration_cast(const duration<long long, std::__1::ratio<1, 1000000000> > &__fd) __attribute__((always_inline))             {
                return __duration_cast<duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > >()(__fd);
            }

template <class _ToDuration, class _Rep, class _Period> inline constexpr typename enable_if<__is_duration<_ToDuration>::value, _ToDuration>::type duration_cast(const duration<_Rep, _Period> &__fd) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
            }

;
            template <class _Rep = long long> struct treat_as_floating_point : is_floating_point<long long> {
            }
template <class _Rep = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> struct treat_as_floating_point : is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > {
            }
template <class _Rep = long double> struct treat_as_floating_point : is_floating_point<long double> {
            }
template <class _Rep = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> struct treat_as_floating_point : is_floating_point<std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > > {
            }
template <class _Rep = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> struct treat_as_floating_point : is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > {
            }
template <class _Rep> struct __attribute__((type_visibility("default"))) treat_as_floating_point : is_floating_point<_Rep> {
            };
            template <class _Rep = long long> struct duration_values {
            public:
                static constexpr long long zero() __attribute__((always_inline));
                static constexpr long long max() __attribute__((always_inline))                 {
                    return numeric_limits<long long>::max();
                }


                static constexpr long long min() __attribute__((always_inline));
            }
template <class _Rep> struct __attribute__((type_visibility("default"))) duration_values {
            public:
                static constexpr _Rep zero() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return _Rep(0);
                }


                static constexpr _Rep max() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return numeric_limits<_Rep>::max();
                }


                static constexpr _Rep min() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return numeric_limits<_Rep>::lowest();
                }


            };
            template <class _Rep = long long, class _Period = std::__1::ratio<1, 1000000000>> class duration {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000000>::num > 0, "duration period must be positive");
                template <class _R1 = std::__1::ratio<1, 1000000000>, class _R2 = std::__1::ratio<1, 1000000000>> struct __no_overflow {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000000>::num, ratio<1, 1000000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000000>::den, ratio<1, 1000000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp = 1, intmax_t _Yp = 1, bool __overflow = false> struct __mul {
                        static const intmax_t value = 1L * 1L;
                    }
template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul;
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                }
template <class _R1, class _R2> struct __no_overflow;
            public:
                typedef long long rep;
                typedef std::__1::ratio<1, 1000000000> period;
            private:
                rep __rep_;
            public:
                duration() __attribute__((always_inline)) = default;
                template <class _Rep2 = long long> constexpr explicit duration(const long long &__r, typename enable_if<is_convertible<long long, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<long long>::value)>::type * = 0) : __rep_(__r) __attribute__((always_inline))                 {
                }

template <class _Rep2> constexpr explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((always_inline));
                template <class _Rep2 = long long, class _Period2 = std::__1::ratio<1, 1000000000>> constexpr duration(const duration<long long, std::__1::ratio<1, 1000000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((always_inline))template <class _Rep2, class _Period2> constexpr duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((always_inline));
                constexpr rep count() const __attribute__((always_inline))                 {
                    return this->__rep_;
                }


                constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator+() const __attribute__((always_inline));
                constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator-() const __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator++() __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator++(int) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator--() __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator--(int) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator*=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator/=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator%=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &rhs) __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > zero() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > max() __attribute__((always_inline))                 {
                    return std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >(duration_values<rep>::max());
                }


            }
template <class _Rep = long long, class _Period = std::__1::ratio<1, 1000000>> class duration {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000>::num > 0, "duration period must be positive");
                template <class _R1 = std::__1::ratio<1, 1000000>, class _R2 = std::__1::ratio<1, 1000000>> struct __no_overflow {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000>::num, ratio<1, 1000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000>::den, ratio<1, 1000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp = 1, intmax_t _Yp = 1, bool __overflow = false> struct __mul {
                        static const intmax_t value = 1L * 1L;
                    }
template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul;
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                }
template <class _R1, class _R2> struct __no_overflow;
            public:
                typedef long long rep;
                typedef std::__1::ratio<1, 1000000> period;
            private:
                rep __rep_;
            public:
                duration() __attribute__((always_inline)) = default;
                template <class _Rep2> constexpr explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((always_inline));
                template <class _Rep2 = long long, class _Period2 = std::__1::ratio<1, 1000000>> constexpr duration(const duration<long long, std::__1::ratio<1, 1000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((always_inline))template <class _Rep2, class _Period2> constexpr duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((always_inline));
                constexpr rep count() const __attribute__((always_inline));
                constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator+() const __attribute__((always_inline));
                constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator-() const __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator++() __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator++(int) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator--() __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator--(int) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator*=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator/=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator%=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &rhs) __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > zero() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > max() __attribute__((always_inline));
            }
template <class _Rep = long long, class _Period = std::__1::ratio<1, 1000>> class duration
template <class _Rep = long long, class _Period = std::__1::ratio<1, 1>> class duration
template <class _Rep = long, class _Period = std::__1::ratio<60, 1>> class duration
template <class _Rep = long, class _Period = std::__1::ratio<3600, 1>> class duration
template <class _Rep = long double, class _Period = std::__1::ratio<1, 1000000000>> class duration {
                static_assert(!__is_duration<long double>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000000>::num > 0, "duration period must be positive");
                template <class _R1 = std::__1::ratio<1, 1000000000>, class _R2 = std::__1::ratio<1, 1000000000>> struct __no_overflow {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000000>::num, ratio<1, 1000000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000000>::den, ratio<1, 1000000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp = 1, intmax_t _Yp = 1, bool __overflow = false> struct __mul {
                        static const intmax_t value = 1L * 1L;
                    }
template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul;
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                }
template <class _R1, class _R2> struct __no_overflow;
            public:
                typedef long double rep;
                typedef std::__1::ratio<1, 1000000000> period;
            private:
                rep __rep_;
            public:
                duration() __attribute__((always_inline)) = default;
                template <class _Rep2 = long double> constexpr explicit duration(const long double &__r, typename enable_if<is_convertible<long double, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<long double>::value)>::type * = 0) : __rep_(__r) __attribute__((always_inline))                 {
                }

template <class _Rep2> constexpr explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((always_inline));
                template <class _Rep2 = long double, class _Period2 = std::__1::ratio<1, 1000000000>> constexpr duration(const duration<long double, std::__1::ratio<1, 1000000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000000>, period>::type::den == 1 && !treat_as_floating_point<long double>::value))>::type *) __attribute__((always_inline))template <class _Rep2 = long long, class _Period2 = std::__1::ratio<1, 1000000000>> constexpr duration(const duration<long long, std::__1::ratio<1, 1000000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type * = 0) : __rep_(std::__1::chrono::duration_cast<std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > >(__d).count()) __attribute__((always_inline))                 {
                }

template <class _Rep2, class _Period2> constexpr duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((always_inline));
                constexpr rep count() const __attribute__((always_inline))                 {
                    return this->__rep_;
                }


                constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > operator+() const __attribute__((always_inline));
                constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > operator-() const __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator++() __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > operator++(int) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator--() __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > operator--(int) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator+=(const std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator-=(const std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &__d) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator*=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator/=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator%=(const rep &rhs) __attribute__((always_inline));
                std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &operator%=(const std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > &rhs) __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > zero() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > max() __attribute__((always_inline));
            }
template <class _Rep, class _Period = ratio<1>> class __attribute__((type_visibility("default"))) duration {
                static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
                static_assert(_Period::num > 0, "duration period must be positive");
                template <class _R1, class _R2> struct __no_overflow {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
                    static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
                    static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
                    static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
                    static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul {
                        static const intmax_t value = _Xp * _Yp;
                    };
                    struct __mul {
                        static const intmax_t value = 1;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                };
            public:
                typedef _Rep rep;
                typedef _Period period;
            private:
                rep __rep_;
            public:
                duration<_Rep, _Period>() __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
                template <class _Rep2> constexpr explicit duration<_Rep, _Period>(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type * = 0) : __rep_(__r) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }

;
                template <class _Rep2, class _Period2> constexpr duration<_Rep, _Period>(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type * = 0) : __rep_(std::__1::chrono::duration_cast<duration<_Rep, _Period> >(__d).count()) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }

;
                constexpr rep count() const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return this->__rep_;
                }


                constexpr duration<_Rep, _Period> operator+() const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return *this;
                }


                constexpr duration<_Rep, _Period> operator-() const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return duration<_Rep, _Period>(- this->__rep_);
                }


                duration<_Rep, _Period> &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    ++this->__rep_;
                    return *this;
                }


                duration<_Rep, _Period> operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return duration<_Rep, _Period>(this->__rep_++);
                }


                duration<_Rep, _Period> &operator--() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    --this->__rep_;
                    return *this;
                }


                duration<_Rep, _Period> operator--(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return duration<_Rep, _Period>(this->__rep_--);
                }


                duration<_Rep, _Period> &operator+=(const duration<_Rep, _Period> &__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    this->__rep_ += __d.count();
                    return *this;
                }


                duration<_Rep, _Period> &operator-=(const duration<_Rep, _Period> &__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    this->__rep_ -= __d.count();
                    return *this;
                }


                duration<_Rep, _Period> &operator*=(const rep &rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    this->__rep_ *= rhs;
                    return *this;
                }


                duration<_Rep, _Period> &operator/=(const rep &rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    this->__rep_ /= rhs;
                    return *this;
                }


                duration<_Rep, _Period> &operator%=(const rep &rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    this->__rep_ %= rhs;
                    return *this;
                }


                duration<_Rep, _Period> &operator%=(const duration<_Rep, _Period> &rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    this->__rep_ %= rhs.count();
                    return *this;
                }


                static constexpr duration<_Rep, _Period> zero() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return duration<_Rep, _Period>(duration_values<rep>::zero());
                }


                static constexpr duration<_Rep, _Period> min() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return duration<_Rep, _Period>(duration_values<rep>::min());
                }


                static constexpr duration<_Rep, _Period> max() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return duration<_Rep, _Period>(duration_values<rep>::max());
                }


            };
            typedef duration<long long, nano> nanoseconds;
            typedef duration<long long, micro> microseconds;
            typedef duration<long long, milli> milliseconds;
            typedef duration<long long> seconds;
            typedef duration<long, ratio<60> > minutes;
            typedef duration<long, ratio<3600> > hours;
            template <class _LhsDuration, class _RhsDuration> struct __duration_eq {
                constexpr bool operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
                    return _Ct(__lhs).count() == _Ct(__rhs).count();
                }


            };
            struct __duration_eq {
                constexpr bool operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return __lhs.count() == __rhs.count();
                }


            };
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr bool operator==(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
            }

;
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr bool operator!=(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__lhs == __rhs);
            }

;
            template <class _LhsDuration, class _RhsDuration> struct __duration_lt {
                constexpr bool operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
                    return _Ct(__lhs).count() < _Ct(__rhs).count();
                }


            };
            struct __duration_lt {
                constexpr bool operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return __lhs.count() < __rhs.count();
                }


            };
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr bool operator<(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
            }

;
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr bool operator>(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __rhs < __lhs;
            }

;
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr bool operator<=(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__rhs < __lhs);
            }

;
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr bool operator>=(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__lhs < __rhs);
            }

;
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type operator+(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
                return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
            }

;
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type operator-(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
                return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
            }

;
            template <class _Rep1, class _Period, class _Rep2> inline constexpr typename enable_if<is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value, duration<typename common_type<_Rep1, _Rep2>::type, _Period> >::type operator*(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename common_type<_Rep1, _Rep2>::type _Cr;
                typedef duration<_Cr, _Period> _Cd;
                return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
            }

;
            template <class _Rep1, class _Period, class _Rep2> inline constexpr typename enable_if<is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value, duration<typename common_type<_Rep1, _Rep2>::type, _Period> >::type operator*(const _Rep1 &__s, const duration<_Rep2, _Period> &__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __d * __s;
            }

;
            template <class _Duration, class _Rep, bool = __is_duration<_Rep>::value> struct __duration_divide_result {
            };
            template <class _Duration, class _Rep2, bool = is_convertible<_Rep2, typename common_type<typename _Duration::rep, _Rep2>::type>::value> struct __duration_divide_imp {
            };
            struct __duration_divide_imp {
                typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
            };
            struct __duration_divide_result : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2> {
            };
            template <class _Rep1, class _Period, class _Rep2> inline constexpr typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type operator/(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename common_type<_Rep1, _Rep2>::type _Cr;
                typedef duration<_Cr, _Period> _Cd;
                return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
            }

;
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr typename common_type<_Rep1, _Rep2>::type operator/(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
                return _Ct(__lhs).count() / _Ct(__rhs).count();
            }

;
            template <class _Rep1, class _Period, class _Rep2> inline constexpr typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type operator%(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename common_type<_Rep1, _Rep2>::type _Cr;
                typedef duration<_Cr, _Period> _Cd;
                return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
            }

;
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline constexpr typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type operator%(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename common_type<_Rep1, _Rep2>::type _Cr;
                typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
                return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
            }

;
            template <class _Clock = std::__1::chrono::system_clock, class _Duration = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> class time_point {
                static_assert(__is_duration<duration<long long, ratio<1, 1000000> > >::value, "Second template parameter of time_point must be a std::chrono::duration");
            public:
                typedef std::__1::chrono::system_clock clock;
                typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > duration;
                typedef typename duration::rep rep;
                typedef typename duration::period period;
            private:
                duration __d_;
            public:
                time_point() __attribute__((always_inline));
                explicit time_point(const duration &__d) __attribute__((always_inline));
                template <class _Duration2 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> time_point(const time_point<clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > &t, typename enable_if<is_convertible<duration<long long, ratio<1, 1000000> >, duration>::value>::type *) __attribute__((always_inline))template <class _Duration2> time_point(const time_point<clock, _Duration2> &t, typename enable_if<is_convertible<_Duration2, duration>::value>::type *) __attribute__((always_inline));
                duration time_since_epoch() const __attribute__((always_inline));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > &operator+=(const duration &__d) __attribute__((always_inline));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > &operator-=(const duration &__d) __attribute__((always_inline));
                static constexpr std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > max() __attribute__((always_inline));
            }
template <class _Clock = std::__1::chrono::steady_clock, class _Duration = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> class time_point {
                static_assert(__is_duration<duration<long long, ratio<1, 1000000000> > >::value, "Second template parameter of time_point must be a std::chrono::duration");
            public:
                typedef std::__1::chrono::steady_clock clock;
                typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > duration;
                typedef typename duration::rep rep;
                typedef typename duration::period period;
            private:
                duration __d_;
            public:
                time_point() __attribute__((always_inline));
                explicit time_point(const duration &__d) __attribute__((always_inline));
                template <class _Duration2 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> time_point(const time_point<clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &t, typename enable_if<is_convertible<duration<long long, ratio<1, 1000000000> >, duration>::value>::type *) __attribute__((always_inline))template <class _Duration2> time_point(const time_point<clock, _Duration2> &t, typename enable_if<is_convertible<_Duration2, duration>::value>::type *) __attribute__((always_inline));
                duration time_since_epoch() const __attribute__((always_inline));
                std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &operator+=(const duration &__d) __attribute__((always_inline));
                std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &operator-=(const duration &__d) __attribute__((always_inline));
                static constexpr std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > max() __attribute__((always_inline));
            }
template <class _Clock = std::__1::chrono::system_clock, class _Duration = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> class time_point {
                static_assert(__is_duration<duration<long long, ratio<1, 1000000000> > >::value, "Second template parameter of time_point must be a std::chrono::duration");
            public:
                typedef std::__1::chrono::system_clock clock;
                typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > duration;
                typedef typename duration::rep rep;
                typedef typename duration::period period;
            private:
                duration __d_;
            public:
                time_point() __attribute__((always_inline));
                explicit time_point(const duration &__d) : __d_(__d) __attribute__((always_inline))                 {
                }


                template <class _Duration2 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> time_point(const time_point<clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &t, typename enable_if<is_convertible<duration<long long, ratio<1, 1000000000> >, duration>::value>::type *) __attribute__((always_inline))template <class _Duration2> time_point(const time_point<clock, _Duration2> &t, typename enable_if<is_convertible<_Duration2, duration>::value>::type *) __attribute__((always_inline));
                duration time_since_epoch() const __attribute__((always_inline));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &operator+=(const duration &__d) __attribute__((always_inline));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &operator-=(const duration &__d) __attribute__((always_inline));
                static constexpr std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > max() __attribute__((always_inline))                 {
                    return std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >(duration::max());
                }


            }
template <class _Clock = std::__1::chrono::system_clock, class _Duration = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> class time_point {
                static_assert(__is_duration<duration<long double, ratio<1, 1000000000> > >::value, "Second template parameter of time_point must be a std::chrono::duration");
            public:
                typedef std::__1::chrono::system_clock clock;
                typedef std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > duration;
                typedef typename duration::rep rep;
                typedef typename duration::period period;
            private:
                duration __d_;
            public:
                time_point() __attribute__((always_inline));
                explicit time_point(const duration &__d) __attribute__((always_inline));
                template <class _Duration2 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> time_point(const time_point<clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &t, typename enable_if<is_convertible<duration<long long, ratio<1, 1000000000> >, duration>::value>::type * = 0) __attribute__((always_inline))template <class _Duration2 = std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> >> time_point(const time_point<clock, std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > > &t, typename enable_if<is_convertible<duration<long double, ratio<1, 1000000000> >, duration>::value>::type *) __attribute__((always_inline))template <class _Duration2> time_point(const time_point<clock, _Duration2> &t, typename enable_if<is_convertible<_Duration2, duration>::value>::type *) __attribute__((always_inline));
                duration time_since_epoch() const __attribute__((always_inline));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > > &operator+=(const duration &__d) __attribute__((always_inline));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > > &operator-=(const duration &__d) __attribute__((always_inline));
                static constexpr std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > > min() __attribute__((always_inline));
                static constexpr std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long double, std::__1::ratio<1, 1000000000> > > max() __attribute__((always_inline));
            }
template <class _Clock, class _Duration = typename _Clock::duration> class __attribute__((type_visibility("default"))) time_point {
                static_assert(__is_duration<_Duration>::value, "Second template parameter of time_point must be a std::chrono::duration");
            public:
                typedef _Clock clock;
                typedef _Duration duration;
                typedef typename duration::rep rep;
                typedef typename duration::period period;
            private:
                duration __d_;
            public:
                time_point<_Clock, _Duration>() : __d_(duration::zero()) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }


                explicit time_point<_Clock, _Duration>(const duration &__d) : __d_(__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }


                template <class _Duration2> time_point<_Clock, _Duration>(const time_point<clock, _Duration2> &t, typename enable_if<is_convertible<_Duration2, duration>::value>::type * = 0) : __d_(t.time_since_epoch()) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }

;
                duration time_since_epoch() const __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return this->__d_;
                }


                time_point<_Clock, _Duration> &operator+=(const duration &__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    this->__d_ += __d;
                    return * this;
                }


                time_point<_Clock, _Duration> &operator-=(const duration &__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    this->__d_ -= __d;
                    return * this;
                }


                static constexpr time_point<_Clock, _Duration> min() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return time_point<_Clock, _Duration>(duration::min());
                }


                static constexpr time_point<_Clock, _Duration> max() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                    return time_point<_Clock, _Duration>(duration::max());
                }


            };
        }
        struct __attribute__((type_visibility("default"))) common_type {
            typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
        };
        namespace chrono {
            template <class _ToDuration, class _Clock, class _Duration> inline time_point<_Clock, _ToDuration> time_point_cast(const time_point<_Clock, _Duration> &__t) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return time_point<_Clock, _ToDuration>(std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
            }

;
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator==(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __lhs.time_since_epoch() == __rhs.time_since_epoch();
            }

;
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator!=(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__lhs == __rhs);
            }

;
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator<(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __lhs.time_since_epoch() < __rhs.time_since_epoch();
            }

;
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator>(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __rhs < __lhs;
            }

;
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator<=(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__rhs < __lhs);
            }

;
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator>=(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__lhs < __rhs);
            }

;
            template <class _Clock, class _Duration1, class _Rep2, class _Period2> inline time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> operator+(const time_point<_Clock, _Duration1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
                return _Tr(__lhs.time_since_epoch() + __rhs);
            }

;
            template <class _Rep1, class _Period1, class _Clock, class _Duration2> inline time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type> operator+(const duration<_Rep1, _Period1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __rhs + __lhs;
            }

;
            template <class _Clock, class _Duration1, class _Rep2, class _Period2> inline time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> operator-(const time_point<_Clock, _Duration1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __lhs + (- __rhs);
            }

;
            template <class _Clock = std::__1::chrono::steady_clock, class _Duration1 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, class _Duration2 = std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> inline typename common_type<duration<long long, ratio<1, 1000000000> >, duration<long long, ratio<1, 1000000000> > >::type operator-(const time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &__lhs, const time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &__rhs) __attribute__((always_inline))template <class _Clock, class _Duration1, class _Duration2> inline typename common_type<_Duration1, _Duration2>::type operator-(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __lhs.time_since_epoch() - __rhs.time_since_epoch();
            }

;
            class __attribute__((type_visibility("default"))) system_clock {
            public:
                typedef microseconds duration;
                typedef duration::rep rep;
                typedef duration::period period;
                typedef chrono::time_point<system_clock> time_point;
                static const bool is_steady = false;
                static time_point now() noexcept;
                static time_t to_time_t(const time_point &__t) noexcept;
                static time_point from_time_t(time_t __t) noexcept;
            };
            class __attribute__((type_visibility("default"))) steady_clock {
            public:
                typedef nanoseconds duration;
                typedef duration::rep rep;
                typedef duration::period period;
                typedef chrono::time_point<steady_clock, duration> time_point;
                static const bool is_steady = true;
                static time_point now() noexcept;
            };
            typedef std::__1::chrono::steady_clock high_resolution_clock;
        }
    }
}
extern "C" {
    extern int *__error();
}
namespace std {
    inline namespace __1 {
        template <class _Tp = int> struct is_error_code_enum : public false_type {
        }
template <class _Tp = std::__1::error_code> struct is_error_code_enum : public false_type {
        }
template <class _Tp = std::__1::error_category> struct is_error_code_enum : public false_type {
        }
template <class _Tp = std::__1::error_condition> struct is_error_code_enum : public false_type {
        }
template <class _Tp = std::type_info> struct is_error_code_enum : public false_type {
        }
template <class _Tp = std::__1::locale> struct is_error_code_enum : public false_type {
        }
template <class _Tp = std::__1::io_errc> struct __attribute__((type_visibility("default"))) is_error_code_enum : public true_type {
        }
template <class _Tp = std::__1::ios_base &(*)(std::__1::ios_base &)> struct is_error_code_enum : public false_type {
        }
template <class _Tp = const char *> struct is_error_code_enum : public false_type {
        }
template <class _Tp = bool> struct is_error_code_enum : public false_type {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_error_code_enum : public false_type {
        };
        template <class _Tp = std::__1::errc> struct __attribute__((type_visibility("default"))) is_error_condition_enum : true_type {
        }
template <class _Tp = int> struct is_error_condition_enum : public false_type {
        }
template <class _Tp = std::__1::error_condition> struct is_error_condition_enum : public false_type {
        }
template <class _Tp = std::__1::error_category> struct is_error_condition_enum : public false_type {
        }
template <class _Tp = std::__1::error_code> struct is_error_condition_enum : public false_type {
        }
template <class _Tp = std::type_info> struct is_error_condition_enum : public false_type {
        }
template <class _Tp = std::__1::locale> struct is_error_condition_enum : public false_type {
        }
template <class _Tp> struct __attribute__((type_visibility("default"))) is_error_condition_enum : public false_type {
        };
        enum class errc : int {
            address_family_not_supported = 47,
            address_in_use = 48,
            address_not_available = 49,
            already_connected = 56,
            argument_list_too_long = 7,
            argument_out_of_domain = 33,
            bad_address = 14,
            bad_file_descriptor = 9,
            bad_message = 94,
            broken_pipe = 32,
            connection_aborted = 53,
            connection_already_in_progress = 37,
            connection_refused = 61,
            connection_reset = 54,
            cross_device_link = 18,
            destination_address_required = 39,
            device_or_resource_busy = 16,
            directory_not_empty = 66,
            executable_format_error = 8,
            file_exists = 17,
            file_too_large = 27,
            filename_too_long = 63,
            function_not_supported = 78,
            host_unreachable = 65,
            identifier_removed = 90,
            illegal_byte_sequence = 92,
            inappropriate_io_control_operation = 25,
            interrupted = 4,
            invalid_argument = 22,
            invalid_seek = 29,
            io_error = 5,
            is_a_directory = 21,
            message_size = 40,
            network_down = 50,
            network_reset = 52,
            network_unreachable = 51,
            no_buffer_space = 55,
            no_child_process = 10,
            no_link = 97,
            no_lock_available = 77,
            no_message_available = 96,
            no_message = 91,
            no_protocol_option = 42,
            no_space_on_device = 28,
            no_stream_resources = 98,
            no_such_device_or_address = 6,
            no_such_device = 19,
            no_such_file_or_directory = 2,
            no_such_process = 3,
            not_a_directory = 20,
            not_a_socket = 38,
            not_a_stream = 99,
            not_connected = 57,
            not_enough_memory = 12,
            not_supported = 45,
            operation_canceled = 89,
            operation_in_progress = 36,
            operation_not_permitted = 1,
            operation_not_supported = 102,
            operation_would_block = 35,
            owner_dead = 105,
            permission_denied = 13,
            protocol_error = 100,
            protocol_not_supported = 43,
            read_only_file_system = 30,
            resource_deadlock_would_occur = 11,
            resource_unavailable_try_again = 35,
            result_out_of_range = 34,
            state_not_recoverable = 104,
            stream_timeout = 101,
            text_file_busy = 26,
            timed_out = 60,
            too_many_files_open_in_system = 23,
            too_many_files_open = 24,
            too_many_links = 31,
            too_many_symbolic_link_levels = 62,
            value_too_large = 84,
            wrong_protocol_type = 41
        } __attribute__((type_visibility("default")));
        struct __attribute__((type_visibility("default"))) is_error_condition_enum : true_type {
        };
        class __attribute__((type_visibility("default"))) error_condition;
        class __attribute__((type_visibility("default"))) error_code;
        class __attribute__((visibility("hidden"))) __do_message;
        class __attribute__((type_visibility("default"))) error_category {
        public:
            virtual ~std::__1::error_category() noexcept;
            error_category() __attribute__((always_inline)) __attribute__((visibility("hidden"))) = default;
        private:
            error_category(const std::__1::error_category &);
            std::__1::error_category &operator=(const std::__1::error_category &);
        public:
            virtual const char *name() const noexcept = 0;
            virtual std::__1::error_condition default_error_condition(int __ev) const noexcept;
            virtual bool equivalent(int __code, const std::__1::error_condition &__condition) const noexcept;
            virtual bool equivalent(const std::__1::error_code &__code, int __condition) const noexcept;
            virtual string message(int __ev) const = 0;
            bool operator==(const std::__1::error_category &__rhs) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this == &__rhs;
            }


            bool operator!=(const std::__1::error_category &__rhs) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(*this == __rhs);
            }


            bool operator<(const std::__1::error_category &__rhs) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this < &__rhs;
            }


            friend  class __do_message;
        };
        class __attribute__((visibility("hidden"))) __do_message : public std::__1::error_category {
        public:
            virtual string message(int ev) const;
        };
        const std::__1::error_category &generic_category() noexcept __attribute__((visibility("default")));
        const std::__1::error_category &system_category() noexcept __attribute__((visibility("default")));
        class __attribute__((type_visibility("default"))) error_condition {
            int __val_;
            const std::__1::error_category *__cat_;
        public:
            error_condition() noexcept : __val_(0), __cat_(&generic_category()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            error_condition(int __val, const std::__1::error_category &__cat) noexcept : __val_(__val), __cat_(&__cat) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Ep> error_condition(_Ep __e, typename enable_if<is_error_condition_enum<_Ep>::value>::type * = 0) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                *this = make_error_condition(__e);
            }

;
            void assign(int __val, const std::__1::error_category &__cat) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__val_ = __val;
                this->__cat_ = &__cat;
            }


            template <class _Ep> typename enable_if<is_error_condition_enum<_Ep>::value, error_condition &>::type operator=(_Ep __e) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                *this = make_error_condition(__e);
                return *this;
            }

;
            void clear() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__val_ = 0;
                this->__cat_ = &generic_category();
            }


            int value() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__val_;
            }


            const std::__1::error_category &category() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this->__cat_;
            }


            string message() const;
            explicit operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__val_ != 0;
            }


        };
        inline std::__1::error_condition make_error_condition(std::__1::errc __e) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::error_condition(static_cast<int>(__e), generic_category());
        }


        inline bool operator<(const std::__1::error_condition &__x, const std::__1::error_condition &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.category() < __y.category() || (__x.category() == __y.category() && __x.value() < __y.value());
        }


        class __attribute__((type_visibility("default"))) error_code {
            int __val_;
            const std::__1::error_category *__cat_;
        public:
            error_code() noexcept : __val_(0), __cat_(&system_category()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            error_code(int __val, const std::__1::error_category &__cat) noexcept : __val_(__val), __cat_(&__cat) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Ep = std::__1::io_errc> error_code(std::__1::io_errc __e, typename enable_if<is_error_code_enum<io_errc>::value>::type * = 0) noexcept __attribute__((always_inline))template <class _Ep> error_code(_Ep __e, typename enable_if<is_error_code_enum<_Ep>::value>::type * = 0) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                *this = make_error_code(__e);
            }

;
            void assign(int __val, const std::__1::error_category &__cat) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__val_ = __val;
                this->__cat_ = &__cat;
            }


            template <class _Ep> typename enable_if<is_error_code_enum<_Ep>::value, error_code &>::type operator=(_Ep __e) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                *this = make_error_code(__e);
                return *this;
            }

;
            void clear() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__val_ = 0;
                this->__cat_ = &system_category();
            }


            int value() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__val_;
            }


            const std::__1::error_category &category() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this->__cat_;
            }


            std::__1::error_condition default_error_condition() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cat_->default_error_condition(this->__val_);
            }


            string message() const;
            explicit operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__val_ != 0;
            }


        };
        inline std::__1::error_code make_error_code(std::__1::errc __e) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::error_code(static_cast<int>(__e), generic_category());
        }


        inline bool operator<(const std::__1::error_code &__x, const std::__1::error_code &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.category() < __y.category() || (__x.category() == __y.category() && __x.value() < __y.value());
        }


        inline bool operator==(const std::__1::error_code &__x, const std::__1::error_code &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.category() == __y.category() && __x.value() == __y.value();
        }


        inline bool operator==(const std::__1::error_code &__x, const std::__1::error_condition &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.category().equivalent(__x.value(), __y) || __y.category().equivalent(__x, __y.value());
        }


        inline bool operator==(const std::__1::error_condition &__x, const std::__1::error_code &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __y == __x;
        }


        inline bool operator==(const std::__1::error_condition &__x, const std::__1::error_condition &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.category() == __y.category() && __x.value() == __y.value();
        }


        inline bool operator!=(const std::__1::error_code &__x, const std::__1::error_code &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }


        inline bool operator!=(const std::__1::error_code &__x, const std::__1::error_condition &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }


        inline bool operator!=(const std::__1::error_condition &__x, const std::__1::error_code &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }


        inline bool operator!=(const std::__1::error_condition &__x, const std::__1::error_condition &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(__x == __y);
        }


        struct __attribute__((type_visibility("default"))) hash : public unary_function<std::__1::error_code, size_t> {
            size_t operator()(const std::__1::error_code &__ec) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__ec.value());
            }


        };
        class __attribute__((type_visibility("default"))) system_error : public std::runtime_error {
            std::__1::error_code __ec_;
        public:
            system_error(std::__1::error_code __ec, const string &__what_arg);
            system_error(std::__1::error_code __ec, const char *__what_arg);
            system_error(std::__1::error_code __ec);
            system_error(int __ev, const std::__1::error_category &__ecat, const string &__what_arg);
            system_error(int __ev, const std::__1::error_category &__ecat, const char *__what_arg);
            system_error(int __ev, const std::__1::error_category &__ecat);
            ~std::__1::system_error() noexcept;
            const std::__1::error_code &code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ec_;
            }


        private:
            static string __init(const std::__1::error_code &, string);
        };
        void __throw_system_error(int ev, const char *what_arg) __attribute__((visibility("default")));
    }
}
extern "C" {
    struct sched_param {
        int sched_priority;
        char __opaque[4];
    };
    extern int sched_yield();
    extern int sched_get_priority_min(int);
    extern int sched_get_priority_max(int);
}
typedef __darwin_pthread_attr_t pthread_attr_t;
typedef __darwin_pthread_cond_t pthread_cond_t;
typedef __darwin_pthread_condattr_t pthread_condattr_t;
typedef __darwin_pthread_key_t pthread_key_t;
typedef __darwin_pthread_mutex_t pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
typedef __darwin_pthread_once_t pthread_once_t;
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
typedef __darwin_pthread_t pthread_t;
enum  : unsigned int {
    QOS_CLASS_USER_INTERACTIVE = 33,
    QOS_CLASS_USER_INITIATED = 25,
    QOS_CLASS_DEFAULT = 21,
    QOS_CLASS_UTILITY = 17,
    QOS_CLASS_BACKGROUND = 9,
    QOS_CLASS_UNSPECIFIED = 0
} typedef qos_class_t;
extern "C" {
    qos_class_t qos_class_self() __attribute__((availability(macos, introduced=10.10)));
    qos_class_t qos_class_main() __attribute__((availability(macos, introduced=10.10)));
}
extern "C" {
    int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority) __attribute__((availability(macos, introduced=10.10)));
    int pthread_attr_get_qos_class_np(pthread_attr_t *__attr, qos_class_t *__qos_class, int *__relative_priority) __attribute__((availability(macos, introduced=10.10)));
    int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority) __attribute__((availability(macos, introduced=10.10)));
    int pthread_get_qos_class_np(pthread_t __pthread, qos_class_t *__qos_class, int *__relative_priority) __attribute__((availability(macos, introduced=10.10)));
    struct pthread_override_s;
    typedef struct pthread_override_s *pthread_override_t;
    pthread_override_t pthread_override_qos_class_start_np(pthread_t __pthread, qos_class_t __qos_class, int __relative_priority) __attribute__((availability(macos, introduced=10.10)));
    int pthread_override_qos_class_end_np(pthread_override_t __override) __attribute__((availability(macos, introduced=10.10)));
}
typedef __darwin_mach_port_t mach_port_t;
typedef __darwin_sigset_t sigset_t;
extern "C" {
    int pthread_atfork(void (*)(), void (*)(), void (*)()) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_destroy(pthread_attr_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_getdetachstate(const pthread_attr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_getguardsize(const pthread_attr_t *, size_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_getinheritsched(const pthread_attr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_getschedparam(const pthread_attr_t *, struct sched_param *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_getschedpolicy(const pthread_attr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_getscope(const pthread_attr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_getstack(const pthread_attr_t *, void **, size_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_getstackaddr(const pthread_attr_t *, void **) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_getstacksize(const pthread_attr_t *, size_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_init(pthread_attr_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_setdetachstate(pthread_attr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_setguardsize(pthread_attr_t *, size_t) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_setinheritsched(pthread_attr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_setschedparam(pthread_attr_t *, const struct sched_param *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_setschedpolicy(pthread_attr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_setscope(pthread_attr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_setstack(pthread_attr_t *, void *, size_t) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_setstackaddr(pthread_attr_t *, void *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_attr_setstacksize(pthread_attr_t *, size_t) __attribute__((availability(macos, introduced=10.4)));
    int pthread_cancel(pthread_t) asm("_pthread_cancel") __attribute__((availability(macos, introduced=10.4)));
    int pthread_cond_broadcast(pthread_cond_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_cond_destroy(pthread_cond_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *) asm("_pthread_cond_init") __attribute__((availability(macos, introduced=10.4)));
    int pthread_cond_signal(pthread_cond_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *, const struct timespec *) asm("_pthread_cond_timedwait") __attribute__((availability(macos, introduced=10.4)));
    int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *) asm("_pthread_cond_wait") __attribute__((availability(macos, introduced=10.4)));
    int pthread_condattr_destroy(pthread_condattr_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_condattr_init(pthread_condattr_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_condattr_getpshared(const pthread_condattr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_condattr_setpshared(pthread_condattr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_create(pthread_t *, const pthread_attr_t *, void *(*)(void *), void *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_detach(pthread_t) __attribute__((availability(macos, introduced=10.4)));
    int pthread_equal(pthread_t, pthread_t) __attribute__((availability(macos, introduced=10.4)));
    void pthread_exit(void *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_getconcurrency() __attribute__((availability(macos, introduced=10.4)));
    int pthread_getschedparam(pthread_t, int *, struct sched_param *) __attribute__((availability(macos, introduced=10.4)));
    void *pthread_getspecific(pthread_key_t) __attribute__((availability(macos, introduced=10.4)));
    int pthread_join(pthread_t, void **) asm("_pthread_join") __attribute__((availability(macos, introduced=10.4)));
    int pthread_key_create(pthread_key_t *, void (*)(void *)) __attribute__((availability(macos, introduced=10.4)));
    int pthread_key_delete(pthread_key_t) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutex_destroy(pthread_mutex_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutex_getprioceiling(const pthread_mutex_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutex_lock(pthread_mutex_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutex_trylock(pthread_mutex_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutex_unlock(pthread_mutex_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_destroy(pthread_mutexattr_t *) asm("_pthread_mutexattr_destroy") __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_getpshared(const pthread_mutexattr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_gettype(const pthread_mutexattr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_init(pthread_mutexattr_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_mutexattr_settype(pthread_mutexattr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_once(pthread_once_t *, void (*)()) __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlock_destroy(pthread_rwlock_t *) asm("_pthread_rwlock_destroy") __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlock_init(pthread_rwlock_t *, const pthread_rwlockattr_t *) asm("_pthread_rwlock_init") __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlock_rdlock(pthread_rwlock_t *) asm("_pthread_rwlock_rdlock") __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlock_tryrdlock(pthread_rwlock_t *) asm("_pthread_rwlock_tryrdlock") __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlock_trywrlock(pthread_rwlock_t *) asm("_pthread_rwlock_trywrlock") __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlock_wrlock(pthread_rwlock_t *) asm("_pthread_rwlock_wrlock") __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlock_unlock(pthread_rwlock_t *) asm("_pthread_rwlock_unlock") __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlockattr_destroy(pthread_rwlockattr_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *, int *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlockattr_init(pthread_rwlockattr_t *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int) __attribute__((availability(macos, introduced=10.4)));
    pthread_t pthread_self() __attribute__((availability(macos, introduced=10.4)));
    int pthread_setcancelstate(int, int *) asm("_pthread_setcancelstate") __attribute__((availability(macos, introduced=10.4)));
    int pthread_setcanceltype(int, int *) asm("_pthread_setcanceltype") __attribute__((availability(macos, introduced=10.4)));
    int pthread_setconcurrency(int) __attribute__((availability(macos, introduced=10.4)));
    int pthread_setschedparam(pthread_t, int, const struct sched_param *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_setspecific(pthread_key_t, const void *) __attribute__((availability(macos, introduced=10.4)));
    void pthread_testcancel() asm("_pthread_testcancel") __attribute__((availability(macos, introduced=10.4)));
    int pthread_is_threaded_np() __attribute__((availability(macos, introduced=10.4)));
    int pthread_threadid_np(pthread_t, __uint64_t *) __attribute__((availability(macos, introduced=10.6)));
    int pthread_getname_np(pthread_t, char *, size_t) __attribute__((availability(macos, introduced=10.6)));
    int pthread_setname_np(const char *) __attribute__((availability(macos, introduced=10.6)));
    int pthread_main_np() __attribute__((availability(macos, introduced=10.4)));
    mach_port_t pthread_mach_thread_np(pthread_t) __attribute__((availability(macos, introduced=10.4)));
    size_t pthread_get_stacksize_np(pthread_t) __attribute__((availability(macos, introduced=10.4)));
    void *pthread_get_stackaddr_np(pthread_t) __attribute__((availability(macos, introduced=10.4)));
    int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t) __attribute__((availability(macos, introduced=10.4)));
    int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *, const struct timespec *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_create_suspended_np(pthread_t *, const pthread_attr_t *, void *(*)(void *), void *) __attribute__((availability(macos, introduced=10.4)));
    int pthread_kill(pthread_t, int) __attribute__((availability(macos, introduced=10.4)));
    pthread_t pthread_from_mach_thread_np(mach_port_t) __attribute__((availability(macos, introduced=10.5)));
    int pthread_sigmask(int, const sigset_t *, sigset_t *) asm("_pthread_sigmask") __attribute__((availability(macos, introduced=10.4)));
    void pthread_yield_np() __attribute__((availability(macos, introduced=10.4)));
}
namespace std {
    inline namespace __1 {
        class __attribute__((type_visibility("default"))) mutex {
            pthread_mutex_t __m_;
        public:
            constexpr mutex() noexcept : __m_({850045863, {0}}) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::mutex();
        private:
            mutex(const std::__1::mutex &);
            std::__1::mutex &operator=(const std::__1::mutex &);
        public:
            void lock();
            bool try_lock() noexcept;
            void unlock() noexcept;
            typedef pthread_mutex_t *native_handle_type;
            native_handle_type native_handle() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return &this->__m_;
            }


        };
        struct __attribute__((type_visibility("default"))) defer_lock_t {
        };
        struct __attribute__((type_visibility("default"))) try_to_lock_t {
        };
        struct __attribute__((type_visibility("default"))) adopt_lock_t {
        };
        const std::__1::defer_lock_t defer_lock = std::__1::defer_lock_t();
        const std::__1::try_to_lock_t try_to_lock = std::__1::try_to_lock_t();
        const std::__1::adopt_lock_t adopt_lock = std::__1::adopt_lock_t();
        template <class _Mutex> class __attribute__((type_visibility("default"))) lock_guard {
        public:
            typedef _Mutex mutex_type;
        private:
            mutex_type &__m_;
        public:
            explicit lock_guard<_Mutex>(mutex_type &__m) : __m_(__m) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__m_.lock();
            }


            lock_guard<_Mutex>(mutex_type &__m, std::__1::adopt_lock_t) : __m_(__m) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~lock_guard<_Mutex>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__m_.unlock();
            }


        private:
            lock_guard<_Mutex>(const lock_guard<_Mutex> &);
            lock_guard<_Mutex> &operator=(const lock_guard<_Mutex> &);
        };
        template <class _Mutex = std::__1::mutex> class unique_lock {
        public:
            typedef std::__1::mutex mutex_type;
        private:
            mutex_type *__m_;
            bool __owns_;
        public:
            unique_lock() noexcept __attribute__((always_inline));
            explicit unique_lock(mutex_type &__m) __attribute__((always_inline));
            unique_lock(mutex_type &__m, std::__1::defer_lock_t) noexcept __attribute__((always_inline));
            unique_lock(mutex_type &__m, std::__1::try_to_lock_t) __attribute__((always_inline));
            unique_lock(mutex_type &__m, std::__1::adopt_lock_t) __attribute__((always_inline));
            template <class _Clock, class _Duration> unique_lock(mutex_type &__m, const chrono::time_point<_Clock, _Duration> &__t) __attribute__((always_inline));
            template <class _Rep, class _Period> unique_lock(mutex_type &__m, const chrono::duration<_Rep, _Period> &__d) __attribute__((always_inline));
            ~std::__1::unique_lock<std::__1::mutex>() __attribute__((always_inline));
        private:
            unique_lock(const std::__1::unique_lock<std::__1::mutex> &);
            std::__1::unique_lock<std::__1::mutex> &operator=(const std::__1::unique_lock<std::__1::mutex> &);
        public:
            unique_lock(std::__1::unique_lock<std::__1::mutex> &&__u) noexcept __attribute__((always_inline));
            std::__1::unique_lock<std::__1::mutex> &operator=(std::__1::unique_lock<std::__1::mutex> &&__u) noexcept __attribute__((always_inline));
            void lock();
            bool try_lock();
            template <class _Rep, class _Period> bool try_lock_for(const chrono::duration<_Rep, _Period> &__d);
            template <class _Clock, class _Duration> bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
            void unlock();
            void swap(std::__1::unique_lock<std::__1::mutex> &__u) noexcept __attribute__((always_inline));
            mutex_type *release() noexcept __attribute__((always_inline));
            bool owns_lock() const noexcept __attribute__((always_inline));
            explicit operator bool() const noexcept __attribute__((always_inline));
            mutex_type *mutex() const noexcept __attribute__((always_inline));
        }
template <class _Mutex> class __attribute__((type_visibility("default"))) unique_lock {
        public:
            typedef _Mutex mutex_type;
        private:
            mutex_type *__m_;
            bool __owns_;
        public:
            unique_lock<_Mutex>() noexcept : __m_(nullptr), __owns_(false) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit unique_lock<_Mutex>(mutex_type &__m) : __m_(&__m), __owns_(true) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__m_->lock();
            }


            unique_lock<_Mutex>(mutex_type &__m, std::__1::defer_lock_t) noexcept : __m_(&__m), __owns_(false) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            unique_lock<_Mutex>(mutex_type &__m, std::__1::try_to_lock_t) : __m_(&__m), __owns_(__m.try_lock()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            unique_lock<_Mutex>(mutex_type &__m, std::__1::adopt_lock_t) : __m_(&__m), __owns_(true) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Clock, class _Duration> unique_lock<_Mutex>(mutex_type &__m, const chrono::time_point<_Clock, _Duration> &__t) : __m_(&__m), __owns_(__m.try_lock_until(__t)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Rep, class _Period> unique_lock<_Mutex>(mutex_type &__m, const chrono::duration<_Rep, _Period> &__d) : __m_(&__m), __owns_(__m.try_lock_for(__d)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            ~unique_lock<_Mutex>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (this->__owns_)
                    this->__m_->unlock();
            }


        private:
            unique_lock<_Mutex>(const unique_lock<_Mutex> &);
            unique_lock<_Mutex> &operator=(const unique_lock<_Mutex> &);
        public:
            unique_lock<_Mutex>(unique_lock<_Mutex> &&__u) noexcept : __m_(__u.__m_), __owns_(__u.__owns_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __u.__m_ = nullptr;
                __u.__owns_ = false;
            }


            unique_lock<_Mutex> &operator=(unique_lock<_Mutex> &&__u) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (this->__owns_)
                    this->__m_->unlock();
                this->__m_ = __u.__m_;
                this->__owns_ = __u.__owns_;
                __u.__m_ = nullptr;
                __u.__owns_ = false;
                return *this;
            }


            void lock();
            bool try_lock();
            template <class _Rep, class _Period> bool try_lock_for(const chrono::duration<_Rep, _Period> &__d);
            template <class _Clock, class _Duration> bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
            void unlock();
            void swap(unique_lock<_Mutex> &__u) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::swap(this->__m_, __u.__m_);
                std::__1::swap(this->__owns_, __u.__owns_);
            }


            mutex_type *release() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                mutex_type *__m = this->__m_;
                this->__m_ = nullptr;
                this->__owns_ = false;
                return __m;
            }


            bool owns_lock() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__owns_;
            }


            explicit operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__owns_;
            }


            mutex_type *mutex() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__m_;
            }


        };
        void lock()         {
            if (this->__m_ == nullptr)
                __throw_system_error(1, "unique_lock::lock: references null mutex");
            if (this->__owns_)
                __throw_system_error(11, "unique_lock::lock: already locked");
            this->__m_->lock();
            this->__owns_ = true;
        }


        bool try_lock()         {
            if (this->__m_ == nullptr)
                __throw_system_error(1, "unique_lock::try_lock: references null mutex");
            if (this->__owns_)
                __throw_system_error(11, "unique_lock::try_lock: already locked");
            this->__owns_ = this->__m_->try_lock();
            return this->__owns_;
        }


        template <class _Rep, class _Period> bool try_lock_for(const chrono::duration<_Rep, _Period> &__d)         {
            if (this->__m_ == nullptr)
                __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
            if (this->__owns_)
                __throw_system_error(11, "unique_lock::try_lock_for: already locked");
            this->__owns_ = this->__m_->try_lock_for(__d);
            return this->__owns_;
        }

;
        template <class _Clock, class _Duration> bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t)         {
            if (this->__m_ == nullptr)
                __throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
            if (this->__owns_)
                __throw_system_error(11, "unique_lock::try_lock_until: already locked");
            this->__owns_ = this->__m_->try_lock_until(__t);
            return this->__owns_;
        }

;
        void unlock()         {
            if (!this->__owns_)
                __throw_system_error(1, "unique_lock::unlock: not locked");
            this->__m_->unlock();
            this->__owns_ = false;
        }


        template <class _Mutex> inline void swap(unique_lock<_Mutex> &__x, unique_lock<_Mutex> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __x.swap(__y);
        }

;
        enum class cv_status : int {
            no_timeout,
            timeout
        } __attribute__((type_visibility("default")));
        class __attribute__((type_visibility("default"))) condition_variable {
            pthread_cond_t __cv_;
        public:
            constexpr condition_variable() : __cv_({1018212795, {0}}) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::condition_variable();
        private:
            condition_variable(const std::__1::condition_variable &);
            std::__1::condition_variable &operator=(const std::__1::condition_variable &);
        public:
            void notify_one() noexcept;
            void notify_all() noexcept;
            void wait(unique_lock<std::__1::mutex> &__lk) noexcept;
            template <class _Predicate> void wait(unique_lock<std::__1::mutex> &__lk, _Predicate __pred);
            template <class _Clock, class _Duration> std::__1::cv_status wait_until(unique_lock<std::__1::mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t);
            template <class _Clock, class _Duration, class _Predicate> bool wait_until(unique_lock<std::__1::mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t, _Predicate __pred);
            template <class _Rep, class _Period> std::__1::cv_status wait_for(unique_lock<std::__1::mutex> &__lk, const chrono::duration<_Rep, _Period> &__d);
            template <class _Rep, class _Period, class _Predicate> bool wait_for(unique_lock<std::__1::mutex> &__lk, const chrono::duration<_Rep, _Period> &__d, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            typedef pthread_cond_t *native_handle_type;
            native_handle_type native_handle() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return &this->__cv_;
            }


        private:
            void __do_timed_wait(unique_lock<std::__1::mutex> &__lk, chrono::time_point<chrono::system_clock, chrono::nanoseconds>) noexcept;
        };
        template <class _To, class _Rep, class _Period> inline typename enable_if<chrono::__is_duration<_To>::value, _To>::type __ceil(chrono::duration<_Rep, _Period> __d) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            using namespace chrono;
            _To __r = duration_cast<_To>(__d);
            if (__r < __d)
                ++__r;
            return __r;
        }

;
        template <class _Predicate> void wait(unique_lock<std::__1::mutex> &__lk, _Predicate __pred)         {
            while (!__pred())
                this->wait(__lk);
        }

;
        template <class _Clock, class _Duration> std::__1::cv_status wait_until(unique_lock<std::__1::mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t)         {
            using namespace chrono;
            wait_for(__lk, __t - _Clock::now());
            return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
        }

;
        template <class _Clock, class _Duration, class _Predicate> bool wait_until(unique_lock<std::__1::mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t, _Predicate __pred)         {
            while (!__pred())
                {
                    if (wait_until(__lk, __t) == cv_status::timeout)
                        return __pred();
                }
            return true;
        }

;
        template <class _Rep, class _Period> std::__1::cv_status wait_for(unique_lock<std::__1::mutex> &__lk, const chrono::duration<_Rep, _Period> &__d)         {
            using namespace chrono;
            if (__d <= __d.zero())
                return cv_status::timeout;
            typedef time_point<std::__1::chrono::system_clock, duration<long double, nano> > __sys_tpf;
            typedef time_point<std::__1::chrono::system_clock, nanoseconds> __sys_tpi;
            __sys_tpf _Max = __sys_tpi::max();
            system_clock::time_point __s_now = system_clock::now();
            steady_clock::time_point __c_now = steady_clock::now();
            if (_Max - __d > __s_now)
                this->__do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
            else
                this->__do_timed_wait(__lk, __sys_tpi::max());
            return steady_clock::now() - __c_now < __d ? cv_status::no_timeout : cv_status::timeout;
        }

;
        template <class _Rep, class _Period, class _Predicate> inline bool wait_for(unique_lock<std::__1::mutex> &__lk, const chrono::duration<_Rep, _Period> &__d, _Predicate __pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return wait_until(__lk, chrono::steady_clock::now() + __d, std::__1::move(__pred));
        }

;
    }
}
namespace std {
    inline namespace __1 {
        template <class _Tp> struct __attribute__((type_visibility("default"))) plus : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x + __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) minus : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x - __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) multiplies : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x * __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) divides : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x / __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) modulus : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x % __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) negate : unary_function<_Tp, _Tp> {
            _Tp operator()(const _Tp &__x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return - __x;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) equal_to : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x == __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) not_equal_to : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x != __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) greater : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x > __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) greater_equal : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x >= __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) less_equal : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x <= __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) logical_and : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x && __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) logical_or : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x || __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) logical_not : unary_function<_Tp, bool> {
            bool operator()(const _Tp &__x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !__x;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) bit_and : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x & __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) bit_or : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x | __y;
            }


        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x ^ __y;
            }


        };
        template <class _Predicate> class __attribute__((type_visibility("default"))) unary_negate : public unary_function<typename _Predicate::argument_type, bool> {
            _Predicate __pred_;
        public:
            explicit unary_negate<_Predicate>(const _Predicate &__pred) : __pred_(__pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            bool operator()(const typename _Predicate::argument_type &__x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !this->__pred_(__x);
            }


        };
        template <class _Predicate> inline unary_negate<_Predicate> not1(const _Predicate &__pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return unary_negate<_Predicate>(__pred);
        }

;
        template <class _Predicate> class __attribute__((type_visibility("default"))) binary_negate : public binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool> {
            _Predicate __pred_;
        public:
            explicit binary_negate<_Predicate>(const _Predicate &__pred) : __pred_(__pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !this->__pred_(__x, __y);
            }


        };
        template <class _Predicate> inline binary_negate<_Predicate> not2(const _Predicate &__pred) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return binary_negate<_Predicate>(__pred);
        }

;
        template <class __Operation> class __attribute__((type_visibility("default"))) binder1st : public unary_function<typename __Operation::second_argument_type, typename __Operation::result_type> {
        protected:
            __Operation op;
            typename __Operation::first_argument_type value;
        public:
            binder1st<__Operation>(const __Operation &__x, const typename __Operation::first_argument_type __y) : op(__x), value(__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            typename __Operation::result_type operator()(typename __Operation::second_argument_type &__x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->op(this->value, __x);
            }


            typename __Operation::result_type operator()(const typename __Operation::second_argument_type &__x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->op(this->value, __x);
            }


        };
        template <class __Operation, class _Tp> inline binder1st<__Operation> bind1st(const __Operation &__op, const _Tp &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return binder1st<__Operation>(__op, __x);
        }

;
        template <class __Operation> class __attribute__((type_visibility("default"))) binder2nd : public unary_function<typename __Operation::first_argument_type, typename __Operation::result_type> {
        protected:
            __Operation op;
            typename __Operation::second_argument_type value;
        public:
            binder2nd<__Operation>(const __Operation &__x, const typename __Operation::second_argument_type __y) : op(__x), value(__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            typename __Operation::result_type operator()(typename __Operation::first_argument_type &__x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->op(__x, this->value);
            }


            typename __Operation::result_type operator()(const typename __Operation::first_argument_type &__x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->op(__x, this->value);
            }


        };
        template <class __Operation, class _Tp> inline binder2nd<__Operation> bind2nd(const __Operation &__op, const _Tp &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return binder2nd<__Operation>(__op, __x);
        }

;
        template <class _Arg, class _Result> class __attribute__((type_visibility("default"))) pointer_to_unary_function : public unary_function<_Arg, _Result> {
            _Result (*__f_)(_Arg);
        public:
            explicit pointer_to_unary_function<_Arg, _Result>(_Result (*__f)(_Arg)) : __f_(__f) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Result operator()(_Arg __x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__f_(__x);
            }


        };
        template <class _Arg, class _Result> inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__f)(_Arg)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return pointer_to_unary_function<_Arg, _Result>(__f);
        }

;
        template <class _Arg1, class _Arg2, class _Result> class __attribute__((type_visibility("default"))) pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result> {
            _Result (*__f_)(_Arg1, _Arg2);
        public:
            explicit pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Result (*__f)(_Arg1, _Arg2)) : __f_(__f) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Result operator()(_Arg1 __x, _Arg2 __y) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__f_(__x, __y);
            }


        };
        template <class _Arg1, class _Arg2, class _Result> inline pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__f)(_Arg1, _Arg2)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__f);
        }

;
        template <class _Sp, class _Tp> class __attribute__((type_visibility("default"))) mem_fun_t : public unary_function<_Tp *, _Sp> {
            _Sp (_Tp::*__p_)();
        public:
            explicit mem_fun_t<_Sp, _Tp>(_Sp (_Tp::*__p)()) : __p_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Sp operator()(_Tp *__p) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__p ->* this->__p_)();
            }


        };
        template <class _Sp, class _Tp, class _Ap> class __attribute__((type_visibility("default"))) mem_fun1_t : public binary_function<_Tp *, _Ap, _Sp> {
            _Sp (_Tp::*__p_)(_Ap);
        public:
            explicit mem_fun1_t<_Sp, _Tp, _Ap>(_Sp (_Tp::*__p)(_Ap)) : __p_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Sp operator()(_Tp *__p, _Ap __x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__p ->* this->__p_)(__x);
            }


        };
        template <class _Sp, class _Tp> inline mem_fun_t<_Sp, _Tp> mem_fun(_Sp (_Tp::*__f)()) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return mem_fun_t<_Sp, _Tp>(__f);
        }

;
        template <class _Sp, class _Tp, class _Ap> inline mem_fun1_t<_Sp, _Tp, _Ap> mem_fun(_Sp (_Tp::*__f)(_Ap)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return mem_fun1_t<_Sp, _Tp, _Ap>(__f);
        }

;
        template <class _Sp, class _Tp> class __attribute__((type_visibility("default"))) mem_fun_ref_t : public unary_function<_Tp, _Sp> {
            _Sp (_Tp::*__p_)();
        public:
            explicit mem_fun_ref_t<_Sp, _Tp>(_Sp (_Tp::*__p)()) : __p_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Sp operator()(_Tp &__p) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__p .* this->__p_)();
            }


        };
        template <class _Sp, class _Tp, class _Ap> class __attribute__((type_visibility("default"))) mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp> {
            _Sp (_Tp::*__p_)(_Ap);
        public:
            explicit mem_fun1_ref_t<_Sp, _Tp, _Ap>(_Sp (_Tp::*__p)(_Ap)) : __p_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Sp operator()(_Tp &__p, _Ap __x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__p .* this->__p_)(__x);
            }


        };
        template <class _Sp, class _Tp> inline mem_fun_ref_t<_Sp, _Tp> mem_fun_ref(_Sp (_Tp::*__f)()) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return mem_fun_ref_t<_Sp, _Tp>(__f);
        }

;
        template <class _Sp, class _Tp, class _Ap> inline mem_fun1_ref_t<_Sp, _Tp, _Ap> mem_fun_ref(_Sp (_Tp::*__f)(_Ap)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
        }

;
        template <class _Sp, class _Tp> class __attribute__((type_visibility("default"))) const_mem_fun_t : public unary_function<const _Tp *, _Sp> {
            _Sp (_Tp::*__p_)() const;
        public:
            explicit const_mem_fun_t<_Sp, _Tp>(_Sp (_Tp::*__p)() const) : __p_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Sp operator()(const _Tp *__p) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__p ->* this->__p_)();
            }


        };
        template <class _Sp, class _Tp, class _Ap> class __attribute__((type_visibility("default"))) const_mem_fun1_t : public binary_function<const _Tp *, _Ap, _Sp> {
            _Sp (_Tp::*__p_)(_Ap) const;
        public:
            explicit const_mem_fun1_t<_Sp, _Tp, _Ap>(_Sp (_Tp::*__p)(_Ap) const) : __p_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Sp operator()(const _Tp *__p, _Ap __x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__p ->* this->__p_)(__x);
            }


        };
        template <class _Sp, class _Tp> inline const_mem_fun_t<_Sp, _Tp> mem_fun(_Sp (_Tp::*__f)() const) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return const_mem_fun_t<_Sp, _Tp>(__f);
        }

;
        template <class _Sp, class _Tp, class _Ap> inline const_mem_fun1_t<_Sp, _Tp, _Ap> mem_fun(_Sp (_Tp::*__f)(_Ap) const) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return const_mem_fun1_t<_Sp, _Tp, _Ap>(__f);
        }

;
        template <class _Sp, class _Tp> class __attribute__((type_visibility("default"))) const_mem_fun_ref_t : public unary_function<_Tp, _Sp> {
            _Sp (_Tp::*__p_)() const;
        public:
            explicit const_mem_fun_ref_t<_Sp, _Tp>(_Sp (_Tp::*__p)() const) : __p_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Sp operator()(const _Tp &__p) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__p .* this->__p_)();
            }


        };
        template <class _Sp, class _Tp, class _Ap> class __attribute__((type_visibility("default"))) const_mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp> {
            _Sp (_Tp::*__p_)(_Ap) const;
        public:
            explicit const_mem_fun1_ref_t<_Sp, _Tp, _Ap>(_Sp (_Tp::*__p)(_Ap) const) : __p_(__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            _Sp operator()(const _Tp &__p, _Ap __x) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__p .* this->__p_)(__x);
            }


        };
        template <class _Sp, class _Tp> inline const_mem_fun_ref_t<_Sp, _Tp> mem_fun_ref(_Sp (_Tp::*__f)() const) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return const_mem_fun_ref_t<_Sp, _Tp>(__f);
        }

;
        template <class _Sp, class _Tp, class _Ap> inline const_mem_fun1_ref_t<_Sp, _Tp, _Ap> mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return const_mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
        }

;
        template <class _Tp> class __mem_fn : public __weak_result_type<_Tp> {
        public:
            typedef _Tp type;
        private:
            type __f_;
        public:
            __mem_fn<_Tp>(type __f) : __f_(__f) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class ..._ArgTypes> typename __invoke_return<type, _ArgTypes...>::type operator()(_ArgTypes &&...__args) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __invoke(this->__f_, std::__1::forward<_ArgTypes>(__args)...);
            }

;
        };
        template <class _Rp, class _Tp> inline __mem_fn<_Rp _Tp::*> mem_fn(_Rp _Tp::*__pm) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __mem_fn<_Rp _Tp::*>(__pm);
        }

;
        class __attribute__((visibility("default"))) bad_function_call : public std::exception {
        };
        template <class _Fp> class __attribute__((type_visibility("default"))) function;
        namespace __function {
            template <class _Rp> struct __maybe_derive_from_unary_function {
            };
            struct __maybe_derive_from_unary_function : public unary_function<_A1, _Rp> {
            };
            template <class _Rp> struct __maybe_derive_from_binary_function {
            };
            struct __maybe_derive_from_binary_function : public binary_function<_A1, _A2, _Rp> {
            };
        }
        namespace __function {
            template <class _Fp> class __base;
            class __base {
                __base<type-parameter-0-0 (type-parameter-0-1...)>(const __base<type-parameter-0-0 (type-parameter-0-1...)> &);
                __base<type-parameter-0-0 (type-parameter-0-1...)> &operator=(const __base<type-parameter-0-0 (type-parameter-0-1...)> &);
            public:
                __base<type-parameter-0-0 (type-parameter-0-1...)>() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }


                virtual ~__base<type-parameter-0-0 (type-parameter-0-1...)>() __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }


                virtual __base<type-parameter-0-0 (type-parameter-0-1...)> *__clone() const = 0;
                virtual void __clone(__base<type-parameter-0-0 (type-parameter-0-1...)> *) const = 0;
                virtual void destroy() noexcept = 0;
                virtual void destroy_deallocate() noexcept = 0;
                virtual _Rp operator()(_ArgTypes &&...) = 0;
                virtual const void *target(const std::type_info &) const noexcept = 0;
                virtual const std::type_info &target_type() const noexcept = 0;
            };
            template <class _FD, class _Alloc, class _FB> class __func;
            class __func : public __base<_Rp (_ArgTypes...)> {
                __compressed_pair<_Fp, _Alloc> __f_;
            public:
                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3...)>(_Fp &&__f) : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)), std::__1::forward_as_tuple()) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }


                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3...)>(const _Fp &__f, const _Alloc &__a) : __f_(piecewise_construct, std::__1::forward_as_tuple(__f), std::__1::forward_as_tuple(__a)) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }


                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3...)>(const _Fp &__f, _Alloc &&__a) : __f_(piecewise_construct, std::__1::forward_as_tuple(__f), std::__1::forward_as_tuple(std::__1::move(__a))) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }


                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3...)>(_Fp &&__f, _Alloc &&__a) : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)), std::__1::forward_as_tuple(std::__1::move(__a))) __attribute__((always_inline)) __attribute__((visibility("hidden")))                 {
                }


                virtual __base<_Rp (_ArgTypes...)> *__clone() const;
                virtual void __clone(__base<_Rp (_ArgTypes...)> *) const;
                virtual void destroy() noexcept;
                virtual void destroy_deallocate() noexcept;
                virtual _Rp operator()(_ArgTypes &&...__arg);
                virtual const void *target(const std::type_info &) const noexcept;
                virtual const std::type_info &target_type() const noexcept;
            };
            __base<_Rp (_ArgTypes...)> *__clone() const             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3...)> >::type _Ap;
                _Ap __a(this->__f_.second());
                typedef __allocator_destructor<_Ap> _Dp;
                unique_ptr<__func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3...)>, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                ::new (__hold.get()) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3...)>((this->__f_.first(), _Alloc(__a)));
                return __hold.release();
            }


            void __clone(__base<_Rp (_ArgTypes...)> *__p) const             {
                ::new (__p) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3...)>((this->__f_.first(), this->__f_.second()));
            }


            void destroy() noexcept             {
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
            }


            void destroy_deallocate() noexcept             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3...)> >::type _Ap;
                _Ap __a(this->__f_.second());
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
                __a.deallocate(this, 1);
            }


            _Rp operator()(_ArgTypes &&...__arg)             {
                typedef __invoke_void_return_wrapper<_Rp> _Invoker;
                return _Invoker::__call(this->__f_.first(), std::__1::forward<_ArgTypes>(__arg)...);
            }


            const void *target(const std::type_info &__ti) const noexcept             {
                if (__ti == typeid(_Fp))
                    return &this->__f_.first();
                return (const void *)0;
            }


            const std::type_info &target_type() const noexcept             {
                return typeid(_Fp);
            }


        }
        class __attribute__((type_visibility("default"))) function : public __function::__maybe_derive_from_unary_function<_Rp (_ArgTypes...)>, public __function::__maybe_derive_from_binary_function<_Rp (_ArgTypes...)> {
            typedef __function::__base<_Rp (_ArgTypes...)> __base;
            typename aligned_storage<3 * sizeof(void *)>::type __buf_;
            __base *__f_;
            template <class _Fp> static bool __not_null(const _Fp &) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return true;
            }

;
            template <class _R2, class ..._Ap> static bool __not_null(_R2 (*__p)(_Ap...)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p;
            }

;
            template <class _R2, class _Cp, class ..._Ap> static bool __not_null(_R2 (_Cp::*__p)(_Ap...)) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p;
            }

;
            template <class _R2, class _Cp, class ..._Ap> static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p;
            }

;
            template <class _R2, class _Cp, class ..._Ap> static bool __not_null(_R2 (_Cp::*__p)(_Ap...) volatile) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p;
            }

;
            template <class _R2, class _Cp, class ..._Ap> static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const volatile) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __p;
            }

;
            template <class _R2, class ..._Ap> static bool __not_null(const function<_R2 (_Ap...)> &__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !!__p;
            }

;
            template <class _Fp, bool = !is_same<_Fp, function<type-parameter-0-0 (type-parameter-0-1...)> >::value && __invokable<_Fp &, _ArgTypes...>::value> struct __callable;
            struct __callable {
                static const bool value = is_same<void, _Rp>::value || is_convertible<typename __invoke_of<_Fp &, _ArgTypes...>::type, _Rp>::value;
            };
            struct __callable {
                static const bool value = false;
            };
        public:
            typedef _Rp result_type;
            function<type-parameter-0-0 (type-parameter-0-1...)>() noexcept : __f_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            function<type-parameter-0-0 (type-parameter-0-1...)>(nullptr_t) noexcept : __f_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            function<type-parameter-0-0 (type-parameter-0-1...)>(const function<type-parameter-0-0 (type-parameter-0-1...)> &);
            function<type-parameter-0-0 (type-parameter-0-1...)>(function<type-parameter-0-0 (type-parameter-0-1...)> &&) noexcept;
            template <class _Fp> function<type-parameter-0-0 (type-parameter-0-1...)>(_Fp, typename enable_if<__callable<_Fp>::value && !is_same<_Fp, function<type-parameter-0-0 (type-parameter-0-1...)> >::value>::type * = 0);
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1...)>(std::__1::allocator_arg_t, const _Alloc &) noexcept : __f_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1...)>(std::__1::allocator_arg_t, const _Alloc &, nullptr_t) noexcept : __f_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1...)>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 (type-parameter-0-1...)> &);
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1...)>(std::__1::allocator_arg_t, const _Alloc &, function<type-parameter-0-0 (type-parameter-0-1...)> &&);
            template <class _Fp, class _Alloc> function<type-parameter-0-0 (type-parameter-0-1...)>(std::__1::allocator_arg_t, const _Alloc &__a, _Fp __f, typename enable_if<__callable<_Fp>::value>::type * = 0);
            function<type-parameter-0-0 (type-parameter-0-1...)> &operator=(const function<type-parameter-0-0 (type-parameter-0-1...)> &);
            function<type-parameter-0-0 (type-parameter-0-1...)> &operator=(function<type-parameter-0-0 (type-parameter-0-1...)> &&) noexcept;
            function<type-parameter-0-0 (type-parameter-0-1...)> &operator=(nullptr_t) noexcept;
            template <class _Fp> typename enable_if<__callable<typename decay<_Fp>::type>::value && !is_same<typename remove_reference<_Fp>::type, function<type-parameter-0-0 (type-parameter-0-1...)> >::value, function<type-parameter-0-0 (type-parameter-0-1...)> &>::type operator=(_Fp &&);
            ~function<type-parameter-0-0 (type-parameter-0-1...)>();
            void swap(function<type-parameter-0-0 (type-parameter-0-1...)> &) noexcept;
            template <class _Fp, class _Alloc> void assign(_Fp &&__f, const _Alloc &__a) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                function<type-parameter-0-0 (type-parameter-0-1...)>(allocator_arg, __a, std::__1::forward<_Fp>(__f)).swap(*this);
            }

;
            explicit operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__f_;
            }


            template <class _R2, class ..._ArgTypes2> bool operator==(const function<_R2 (_ArgTypes2...)> &) const = delete;
            template <class _R2, class ..._ArgTypes2> bool operator!=(const function<_R2 (_ArgTypes2...)> &) const = delete;
        public:
            _Rp operator()(_ArgTypes ...) const;
            const std::type_info &target_type() const noexcept;
            template <typename _Tp> _Tp *target() noexcept;
            template <typename _Tp> const _Tp *target() const noexcept;
        };
        function<type-parameter-0-0 (type-parameter-0-1...)>(const function<type-parameter-0-0 (type-parameter-0-1...)> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const __base *)&__f.__buf_) {
                this->__f_ = (__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }


        template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1...)>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 (type-parameter-0-1...)> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const __base *)&__f.__buf_) {
                this->__f_ = (__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }

;
        function<type-parameter-0-0 (type-parameter-0-1...)>(function<type-parameter-0-0 (type-parameter-0-1...)> &&__f) noexcept         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (__base *)&__f.__buf_) {
                this->__f_ = (__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else {
                this->__f_ = __f.__f_;
                __f.__f_ = 0;
            }
        }


        template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1...)>(std::__1::allocator_arg_t, const _Alloc &, function<type-parameter-0-0 (type-parameter-0-1...)> &&__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (__base *)&__f.__buf_) {
                this->__f_ = (__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else {
                this->__f_ = __f.__f_;
                __f.__f_ = 0;
            }
        }

;
        template <class _Fp> function<type-parameter-0-0 (type-parameter-0-1...)>(_Fp __f, typename enable_if<__callable<_Fp>::value && !is_same<_Fp, function<type-parameter-0-0 (type-parameter-0-1...)> >::value>::type * = 0) : __f_(0)         {
            if (__not_null(__f)) {
                typedef __function::__func<_Fp, allocator<_Fp>, _Rp (_ArgTypes...)> _FF;
                if (sizeof(_FF) <= sizeof (this->__buf_) && is_nothrow_copy_constructible<_Fp>::value) {
                    this->__f_ = (__base *)&this->__buf_;
                    ::new (this->__f_) _FF((std::__1::move(__f)));
                } else {
                    typedef allocator<_FF> _Ap;
                    _Ap __a;
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((std::__1::move(__f), allocator<_Fp>(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }

;
        template <class _Fp, class _Alloc> function<type-parameter-0-0 (type-parameter-0-1...)>(std::__1::allocator_arg_t, const _Alloc &__a0, _Fp __f, typename enable_if<__callable<_Fp>::value>::type * = 0) : __f_(0)         {
            typedef allocator_traits<_Alloc> __alloc_traits;
            if (__not_null(__f)) {
                typedef __function::__func<_Fp, _Alloc, _Rp (_ArgTypes...)> _FF;
                typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;
                _Ap __a(__a0);
                if (sizeof(_FF) <= sizeof (this->__buf_) && is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value) {
                    this->__f_ = (__base *)&this->__buf_;
                    ::new (this->__f_) _FF((std::__1::move(__f), _Alloc(__a)));
                } else {
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((std::__1::move(__f), _Alloc(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }

;
        function<_Rp (_ArgTypes...)> &operator=(const function<type-parameter-0-0 (type-parameter-0-1...)> &__f)         {
            function<type-parameter-0-0 (type-parameter-0-1...)>(__f).swap(*this);
            return *this;
        }


        function<_Rp (_ArgTypes...)> &operator=(function<type-parameter-0-0 (type-parameter-0-1...)> &&__f) noexcept         {
            if (this->__f_ == (__base *)&this->__buf_)
                this->__f_->destroy();
            else if (this->__f_)
                this->__f_->destroy_deallocate();
            this->__f_ = 0;
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (__base *)&__f.__buf_) {
                this->__f_ = (__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else {
                this->__f_ = __f.__f_;
                __f.__f_ = 0;
            }
            return *this;
        }


        function<_Rp (_ArgTypes...)> &operator=(nullptr_t) noexcept         {
            if (this->__f_ == (__base *)&this->__buf_)
                this->__f_->destroy();
            else if (this->__f_)
                this->__f_->destroy_deallocate();
            this->__f_ = 0;
            return *this;
        }


        template <class _Fp> typename enable_if<function<_Rp (_ArgTypes...)>::__callable<typename decay<_Fp>::type>::value && !is_same<typename remove_reference<_Fp>::type, function<_Rp (_ArgTypes...)> >::value, function<_Rp (_ArgTypes...)> &>::type operator=(_Fp &&__f)         {
            function<type-parameter-0-0 (type-parameter-0-1...)>(std::__1::forward<_Fp>(__f)).swap(*this);
            return *this;
        }

;
        ~function<type-parameter-0-0 (type-parameter-0-1...)>()         {
            if (this->__f_ == (__base *)&this->__buf_)
                this->__f_->destroy();
            else if (this->__f_)
                this->__f_->destroy_deallocate();
        }


        void swap(function<type-parameter-0-0 (type-parameter-0-1...)> &__f) noexcept         {
            if (this->__f_ == (__base *)&this->__buf_ && __f.__f_ == (__base *)&__f.__buf_) {
                typename aligned_storage<sizeof (this->__buf_)>::type __tempbuf;
                __base *__t = (__base *)&__tempbuf;
                this->__f_->__clone(__t);
                this->__f_->destroy();
                this->__f_ = 0;
                __f.__f_->__clone((__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = 0;
                this->__f_ = (__base *)&this->__buf_;
                __t->__clone((__base *)&__f.__buf_);
                __t->destroy();
                __f.__f_ = (__base *)&__f.__buf_;
            } else if (this->__f_ == (__base *)&this->__buf_) {
                this->__f_->__clone((__base *)&__f.__buf_);
                this->__f_->destroy();
                this->__f_ = __f.__f_;
                __f.__f_ = (__base *)&__f.__buf_;
            } else if (__f.__f_ == (__base *)&__f.__buf_) {
                __f.__f_->__clone((__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = this->__f_;
                this->__f_ = (__base *)&this->__buf_;
            } else
                std::__1::swap(this->__f_, __f.__f_);
        }


        _Rp operator()(_ArgTypes ...__arg) const         {
            if (this->__f_ == 0)
                throw std::__1::bad_function_call();
            return (*this->__f_)(std::__1::forward<_ArgTypes>(__arg)...);
        }


        const std::type_info &target_type() const noexcept         {
            if (this->__f_ == 0)
                return typeid(void);
            return this->__f_->target_type();
        }


        template <typename _Tp> _Tp *target() noexcept         {
            if (this->__f_ == 0)
                return (_Tp *)0;
            return (_Tp *)this->__f_->target(typeid(_Tp));
        }

;
        template <typename _Tp> const _Tp *target() const noexcept         {
            if (this->__f_ == 0)
                return (const _Tp *)0;
            return (const _Tp *)this->__f_->target(typeid(_Tp));
        }

;
        template <class _Rp, class ..._ArgTypes> inline bool operator==(const function<_Rp (_ArgTypes...)> &__f, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !__f;
        }

;
        template <class _Rp, class ..._ArgTypes> inline bool operator==(nullptr_t, const function<_Rp (_ArgTypes...)> &__f) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !__f;
        }

;
        template <class _Rp, class ..._ArgTypes> inline bool operator!=(const function<_Rp (_ArgTypes...)> &__f, nullptr_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return (bool)__f;
        }

;
        template <class _Rp, class ..._ArgTypes> inline bool operator!=(nullptr_t, const function<_Rp (_ArgTypes...)> &__f) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return (bool)__f;
        }

;
        template <class _Rp, class ..._ArgTypes> inline void swap(function<_Rp (_ArgTypes...)> &__x, function<_Rp (_ArgTypes...)> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __x.swap(__y);
        }

;
        template <class _Tp> struct __is_bind_expression : public false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_bind_expression : public __is_bind_expression<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp> struct __is_placeholder : public integral_constant<int, 0> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_placeholder : public __is_placeholder<typename remove_cv<_Tp>::type> {
        };
        namespace placeholders {
            template <int _Np = 1> struct __ph
template <int _Np = 2> struct __ph
template <int _Np = 3> struct __ph
template <int _Np = 4> struct __ph
template <int _Np = 5> struct __ph
template <int _Np = 6> struct __ph
template <int _Np = 7> struct __ph
template <int _Np = 8> struct __ph
template <int _Np = 9> struct __ph
template <int _Np = 10> struct __ph
template <int _Np> struct __ph {
            };
            extern __ph<1> _1 __attribute__((visibility("default")));
            extern __ph<2> _2 __attribute__((visibility("default")));
            extern __ph<3> _3 __attribute__((visibility("default")));
            extern __ph<4> _4 __attribute__((visibility("default")));
            extern __ph<5> _5 __attribute__((visibility("default")));
            extern __ph<6> _6 __attribute__((visibility("default")));
            extern __ph<7> _7 __attribute__((visibility("default")));
            extern __ph<8> _8 __attribute__((visibility("default")));
            extern __ph<9> _9 __attribute__((visibility("default")));
            extern __ph<10> _10 __attribute__((visibility("default")));
        }
        struct __is_placeholder : public integral_constant<int, _Np> {
        };
        template <class _Tp, class _Uj> inline _Tp &__mu(reference_wrapper<_Tp> __t, _Uj &) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __t.get();
        }

;
        template <class _Ti, class ..._Uj, size_t ..._Indx> inline typename __invoke_of<_Ti &, _Uj...>::type __mu_expand(_Ti &__ti, tuple<_Uj...> &__uj, __tuple_indices<_Indx...>) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __ti(std::__1::forward<_Uj>(std::__1::get<_Indx>(__uj))...);
        }

;
        template <class _Ti, class ..._Uj> inline typename __lazy_enable_if<is_bind_expression<_Ti>::value, __invoke_of<_Ti &, _Uj...> >::type __mu(_Ti &__ti, tuple<_Uj...> &__uj) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
            return __mu_expand(__ti, __uj, __indices());
        }

;
        template <bool IsPh, class _Ti, class _Uj> struct __mu_return2 {
        };
        struct __mu_return2 {
            typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
        };
        template <class _Ti, class _Uj> inline typename enable_if<0 < is_placeholder<_Ti>::value, typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type>::type __mu(_Ti &, _Uj &__uj) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            const size_t _Indx = is_placeholder<_Ti>::value - 1;
            return std::__1::forward<typename tuple_element<_Indx, _Uj>::type>(std::__1::get<_Indx>(__uj));
        }

;
        template <class _Ti, class _Uj> inline typename enable_if<!is_bind_expression<_Ti>::value && is_placeholder<_Ti>::value == 0 && !__is_reference_wrapper<_Ti>::value, _Ti &>::type __mu(_Ti &__ti, _Uj &) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __ti;
        }

;
        template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh, class _TupleUj> struct ____mu_return;
        template <bool _Invokable, class _Ti, class ..._Uj> struct ____mu_return_invokable {
            typedef std::__1::__nat type;
        };
        struct ____mu_return_invokable {
            typedef typename __invoke_of<_Ti &, _Uj...>::type type;
        };
        struct ____mu_return : public ____mu_return_invokable<__invokable<_Ti &, _Uj...>::value, _Ti, _Uj...> {
        };
        struct ____mu_return {
            typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _TupleUj>::type &&type;
        };
        struct ____mu_return {
            typedef typename _Ti::type &type;
        };
        struct ____mu_return {
            typedef _Ti &type;
        };
        template <class _Ti, class _TupleUj> struct __mu_return : public ____mu_return<_Ti, __is_reference_wrapper<_Ti>::value, is_bind_expression<_Ti>::value, 0 < is_placeholder<_Ti>::value && is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value, _TupleUj> {
        };
        template <class _Fp, class _BoundArgs, class _TupleUj> struct __is_valid_bind_return {
            static const bool value = false;
        };
        struct __is_valid_bind_return {
            static const bool value = __invokable<_Fp, typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
        };
        struct __is_valid_bind_return {
            static const bool value = __invokable<_Fp, typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
        };
        template <class _Fp, class _BoundArgs, class _TupleUj, bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value> struct __bind_return;
        struct __bind_return {
            typedef typename __invoke_of<_Fp &, typename __mu_return<_BoundArgs, _TupleUj>::type...>::type type;
        };
        struct __bind_return {
            typedef typename __invoke_of<_Fp &, typename __mu_return<const _BoundArgs, _TupleUj>::type...>::type type;
        };
        template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args> inline typename __bind_return<_Fp, _BoundArgs, _Args>::type __apply_functor(_Fp &__f, _BoundArgs &__bound_args, __tuple_indices<_Indx...>, _Args &&__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __invoke(__f, __mu(std::__1::get<_Indx>(__bound_args), __args)...);
        }

;
        template <class _Fp, class ..._BoundArgs> class __bind : public __weak_result_type<typename decay<_Fp>::type> {
        protected:
            typedef typename decay<_Fp>::type _Fd;
            typedef tuple<typename decay<_BoundArgs>::type...> _Td;
        private:
            _Fd __f_;
            _Td __bound_args_;
            typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
        public:
            template <class _Gp, class ..._BA, class  = typename enable_if<is_constructible<_Fd, _Gp>::value && !is_same<typename remove_reference<_Gp>::type, __bind<_Fp, _BoundArgs...> >::value>::type> explicit __bind<_Fp, _BoundArgs...>(_Gp &&__f, _BA &&...__bound_args) : __f_(std::__1::forward<_Gp>(__f)), __bound_args_(std::__1::forward<_BA>(__bound_args)...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class ..._Args> typename __bind_return<_Fd, _Td, tuple<_Args &&...> >::type operator()(_Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __apply_functor(this->__f_, this->__bound_args_, __indices(), tuple<_Args &&...>(std::__1::forward<_Args>(__args)...));
            }

;
            template <class ..._Args> typename __bind_return<const _Fd, const _Td, tuple<_Args &&...> >::type operator()(_Args &&...__args) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __apply_functor(this->__f_, this->__bound_args_, __indices(), tuple<_Args &&...>(std::__1::forward<_Args>(__args)...));
            }

;
        };
        struct __is_bind_expression : public true_type {
        };
        template <class _Rp, class _Fp, class ..._BoundArgs> class __bind_r : public __bind<_Fp, _BoundArgs...> {
            typedef __bind<_Fp, _BoundArgs...> base;
            typedef typename base::_Fd _Fd;
            typedef typename base::_Td _Td;
        public:
            typedef _Rp result_type;
            template <class _Gp, class ..._BA, class  = typename enable_if<is_constructible<_Fd, _Gp>::value && !is_same<typename remove_reference<_Gp>::type, __bind_r<_Rp, _Fp, _BoundArgs...> >::value>::type> explicit __bind_r<_Rp, _Fp, _BoundArgs...>(_Gp &&__f, _BA &&...__bound_args) : base(std::__1::forward<_Gp>(__f), std::__1::forward<_BA>(__bound_args)...) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }

;
            template <class ..._Args> typename enable_if<is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args &&...> >::type, result_type>::value || is_void<_Rp>::value, result_type>::type operator()(_Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef __invoke_void_return_wrapper<_Rp> _Invoker;
                return _Invoker::__call(static_cast<base &>(*this), std::__1::forward<_Args>(__args)...);
            }

;
            template <class ..._Args> typename enable_if<is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args &&...> >::type, result_type>::value || is_void<_Rp>::value, result_type>::type operator()(_Args &&...__args) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef __invoke_void_return_wrapper<_Rp> _Invoker;
                return _Invoker::__call(static_cast<const base &>(*this), std::__1::forward<_Args>(__args)...);
            }

;
        };
        struct __is_bind_expression : public true_type {
        };
        template <class _Fp, class ..._BoundArgs> inline __bind<_Fp, _BoundArgs...> bind(_Fp &&__f, _BoundArgs &&...__bound_args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef __bind<_Fp, _BoundArgs...> type;
            return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
        }

;
        template <class _Rp, class _Fp, class ..._BoundArgs> inline __bind_r<_Rp, _Fp, _BoundArgs...> bind(_Fp &&__f, _BoundArgs &&...__bound_args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
            return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
        }

;
        struct __attribute__((type_visibility("default"))) hash : public unary_function<bool, size_t> {
            size_t operator()(bool __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<char, size_t> {
            size_t operator()(char __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<signed char, size_t> {
            size_t operator()(signed char __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned char, size_t> {
            size_t operator()(unsigned char __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<char16_t, size_t> {
            size_t operator()(char16_t __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<char32_t, size_t> {
            size_t operator()(char32_t __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<wchar_t, size_t> {
            size_t operator()(wchar_t __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<short, size_t> {
            size_t operator()(short __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned short, size_t> {
            size_t operator()(unsigned short __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<int, size_t> {
            size_t operator()(int __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned int, size_t> {
            size_t operator()(unsigned int __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<long, size_t> {
            size_t operator()(long __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public unary_function<unsigned long, size_t> {
            size_t operator()(unsigned long __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<size_t>(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<long long> {
        };
        struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<unsigned long long> {
        };
        struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<float> {
            size_t operator()(float __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__v == 0)
                    return 0;
                return this->__scalar_hash<float>::operator()(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<double> {
            size_t operator()(double __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__v == 0)
                    return 0;
                return this->__scalar_hash<double>::operator()(__v);
            }


        };
        struct __attribute__((type_visibility("default"))) hash : public __scalar_hash<long double> {
            size_t operator()(long double __v) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__v == 0)
                    return 0;
                union {
                    long double __t;
                    struct {
                        size_t __a;
                        size_t __b;
                    } __s;
                } __u;
                __u.__s.__a = 0;
                __u.__s.__b = 0;
                __u.__t = __v;
                return __u.__s.__a ^ __u.__s.__b;
            }


        };
    }
}
namespace std {
    inline namespace __1 {
        class __attribute__((type_visibility("default"))) recursive_mutex {
            pthread_mutex_t __m_;
        public:
            recursive_mutex();
            ~std::__1::recursive_mutex();
        private:
            recursive_mutex(const std::__1::recursive_mutex &);
            std::__1::recursive_mutex &operator=(const std::__1::recursive_mutex &);
        public:
            void lock();
            bool try_lock() noexcept;
            void unlock() noexcept;
            typedef pthread_mutex_t *native_handle_type;
            native_handle_type native_handle() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return &this->__m_;
            }


        };
        class __attribute__((type_visibility("default"))) timed_mutex {
            std::__1::mutex __m_;
            std::__1::condition_variable __cv_;
            bool __locked_;
        public:
            timed_mutex();
            ~std::__1::timed_mutex();
        private:
            timed_mutex(const std::__1::timed_mutex &);
            std::__1::timed_mutex &operator=(const std::__1::timed_mutex &);
        public:
            void lock();
            bool try_lock() noexcept;
            template <class _Rep, class _Period> bool try_lock_for(const chrono::duration<_Rep, _Period> &__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return try_lock_until(chrono::steady_clock::now() + __d);
            }

;
            template <class _Clock, class _Duration> bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
            void unlock() noexcept;
        };
        template <class _Clock, class _Duration> bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t)         {
            using namespace chrono;
            unique_lock<std::__1::mutex> __lk(this->__m_);
            bool no_timeout = _Clock::now() < __t;
            while (no_timeout && this->__locked_)
                no_timeout = this->__cv_.wait_until(__lk, __t) == cv_status::no_timeout;
            if (!this->__locked_) {
                this->__locked_ = true;
                return true;
            }
            return false;
        }

;
        class __attribute__((type_visibility("default"))) recursive_timed_mutex {
            std::__1::mutex __m_;
            std::__1::condition_variable __cv_;
            size_t __count_;
            pthread_t __id_;
        public:
            recursive_timed_mutex();
            ~std::__1::recursive_timed_mutex();
        private:
            recursive_timed_mutex(const std::__1::recursive_timed_mutex &);
            std::__1::recursive_timed_mutex &operator=(const std::__1::recursive_timed_mutex &);
        public:
            void lock();
            bool try_lock() noexcept;
            template <class _Rep, class _Period> bool try_lock_for(const chrono::duration<_Rep, _Period> &__d) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return try_lock_until(chrono::steady_clock::now() + __d);
            }

;
            template <class _Clock, class _Duration> bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
            void unlock() noexcept;
        };
        template <class _Clock, class _Duration> bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t)         {
            using namespace chrono;
            pthread_t __id = pthread_self();
            unique_lock<std::__1::mutex> lk(this->__m_);
            if (pthread_equal(__id, this->__id_)) {
                if (this->__count_ == numeric_limits<size_t>::max())
                    return false;
                ++this->__count_;
                return true;
            }
            bool no_timeout = _Clock::now() < __t;
            while (no_timeout && this->__count_ != 0)
                no_timeout = this->__cv_.wait_until(lk, __t) == cv_status::no_timeout;
            if (this->__count_ == 0) {
                this->__count_ = 1;
                this->__id_ = __id;
                return true;
            }
            return false;
        }

;
        template <class _L0, class _L1> int try_lock(_L0 &__l0, _L1 &__l1)         {
            unique_lock<_L0> __u0(__l0, try_to_lock);
            if (__u0.owns_lock()) {
                if (__l1.try_lock()) {
                    __u0.release();
                    return -1;
                } else
                    return 1;
            }
            return 0;
        }

;
        template <class _L0, class _L1, class _L2, class ..._L3> int try_lock(_L0 &__l0, _L1 &__l1, _L2 &__l2, _L3 &...__l3)         {
            int __r = 0;
            unique_lock<_L0> __u0(__l0, try_to_lock);
            if (__u0.owns_lock()) {
                __r = try_lock(__l1, __l2, __l3...);
                if (__r == -1)
                    __u0.release();
                else
                    ++__r;
            }
            return __r;
        }

;
        template <class _L0, class _L1> void lock(_L0 &__l0, _L1 &__l1)         {
            while (true)
                {
                    {
                        unique_lock<_L0> __u0(__l0);
                        if (__l1.try_lock()) {
                            __u0.release();
                            break;
                        }
                    }
                    sched_yield();
                    {
                        unique_lock<_L1> __u1(__l1);
                        if (__l0.try_lock()) {
                            __u1.release();
                            break;
                        }
                    }
                    sched_yield();
                }
        }

;
        template <class _L0, class _L1, class _L2, class ..._L3> void __lock_first(int __i, _L0 &__l0, _L1 &__l1, _L2 &__l2, _L3 &...__l3)         {
            while (true)
                {
                    switch (__i) {
                      case 0:
                        {
                            unique_lock<_L0> __u0(__l0);
                            __i = try_lock(__l1, __l2, __l3...);
                            if (__i == -1) {
                                __u0.release();
                                return;
                            }
                        }
                        ++__i;
                        sched_yield();
                        break;
                      case 1:
                        {
                            unique_lock<_L1> __u1(__l1);
                            __i = try_lock(__l2, __l3..., __l0);
                            if (__i == -1) {
                                __u1.release();
                                return;
                            }
                        }
                        if (__i == sizeof...(_L3) + 1)
                            __i = 0;
                        else
                            __i += 2;
                        sched_yield();
                        break;
                      default:
                        __lock_first(__i - 2, __l2, __l3..., __l0, __l1);
                        return;
                    }
                }
        }

;
        template <class _L0, class _L1, class _L2, class ..._L3> inline void lock(_L0 &__l0, _L1 &__l1, _L2 &__l2, _L3 &...__l3) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __lock_first(0, __l0, __l1, __l2, __l3...);
        }

;
        struct __attribute__((type_visibility("default"))) once_flag;
        template <class _Callable, class ..._Args> void call_once(std::__1::once_flag &, _Callable &&, _Args &&...) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        struct __attribute__((type_visibility("default"))) once_flag {
            constexpr once_flag() noexcept : __state_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        private:
            once_flag(const std::__1::once_flag &);
            std::__1::once_flag &operator=(const std::__1::once_flag &);
            unsigned long __state_;
            friend template <class _Callable, class ..._Args> void call_once(std::__1::once_flag &, _Callable &&, _Args &&...) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        };
        template <class _Fp> class __call_once_param {
            _Fp &__f_;
        public:
            explicit __call_once_param<_Fp>(_Fp &__f) : __f_(__f) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void operator()() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
                __execute(_Index());
            }


        private:
            template <size_t ..._Indices> void __execute(__tuple_indices<_Indices...>) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __invoke(std::__1::get<0>(std::__1::move(this->__f_)), std::__1::get<_Indices>(std::__1::move(this->__f_))...);
            }

;
        };
        template <class _Fp> void __call_once_proxy(void *__vp)         {
            __call_once_param<_Fp> *__p = static_cast<__call_once_param<_Fp> *>(__vp);
            (*__p)();
        }

;
        void __call_once(volatile unsigned long &, void *, void (*)(void *)) __attribute__((visibility("default")));
        template <class _Callable, class ..._Args> inline void call_once(std::__1::once_flag &__flag, _Callable &&__func, _Args &&...__args) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__libcpp_relaxed_load(&__flag.__state_) != ~0UL) {
                typedef tuple<_Callable &&, _Args &&...> _Gp;
                _Gp __f(std::__1::forward<_Callable>(__func), std::__1::forward<_Args>(__args)...);
                __call_once_param<_Gp> __p(__f);
                __call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
            }
        }

;
    }
}
struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_n_cs_precedes;
    char int_p_sep_by_space;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};
extern "C" {
    struct lconv *localeconv();
}
extern "C" {
    char *setlocale(int, const char *);
}
struct _xlocale;
typedef struct _xlocale *locale_t;
extern "C" {
    int ___mb_cur_max();
    int ___mb_cur_max_l(locale_t);
}
extern "C" {
    extern const locale_t _c_locale;
    locale_t duplocale(locale_t);
    int freelocale(locale_t);
    struct lconv *localeconv_l(locale_t);
    locale_t newlocale(int, const char *, locale_t);
    const char *querylocale(int, locale_t);
    locale_t uselocale(locale_t);
}
extern "C" {
    unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
    __darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
    __darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}
extern "C" {
    int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}
inline int __istype_l(__darwin_ct_rune_t _c, unsigned long _f, locale_t _l) {
    return !!(isascii(_c) ? (_DefaultRuneLocale.__runetype[_c] & _f) : __maskrune_l(_c, _f, _l));
}


inline __darwin_ct_rune_t __toupper_l(__darwin_ct_rune_t _c, locale_t _l) {
    return isascii(_c) ? _DefaultRuneLocale.__mapupper[_c] : ___toupper_l(_c, _l);
}


inline __darwin_ct_rune_t __tolower_l(__darwin_ct_rune_t _c, locale_t _l) {
    return isascii(_c) ? _DefaultRuneLocale.__maplower[_c] : ___tolower_l(_c, _l);
}


inline int __wcwidth_l(__darwin_ct_rune_t _c, locale_t _l) {
    unsigned int _x;
    if (_c == 0)
        return (0);
    _x = (unsigned int)__maskrune_l(_c, 3758096384L | 262144L, _l);
    if ((_x & 3758096384L) != 0)
        return ((_x & 3758096384L) >> 30);
    return ((_x & 262144L) != 0 ? 1 : -1);
}


inline int digittoint_l(int c, locale_t l) {
    return (__maskrune_l(c, 15, l));
}


inline int isalnum_l(int c, locale_t l) {
    return (__istype_l(c, 256L | 1024L, l));
}


inline int isalpha_l(int c, locale_t l) {
    return (__istype_l(c, 256L, l));
}


inline int isblank_l(int c, locale_t l) {
    return (__istype_l(c, 131072L, l));
}


inline int iscntrl_l(int c, locale_t l) {
    return (__istype_l(c, 512L, l));
}


inline int isdigit_l(int c, locale_t l) {
    return (__istype_l(c, 1024L, l));
}


inline int isgraph_l(int c, locale_t l) {
    return (__istype_l(c, 2048L, l));
}


inline int ishexnumber_l(int c, locale_t l) {
    return (__istype_l(c, 65536L, l));
}


inline int isideogram_l(int c, locale_t l) {
    return (__istype_l(c, 524288L, l));
}


inline int islower_l(int c, locale_t l) {
    return (__istype_l(c, 4096L, l));
}


inline int isnumber_l(int c, locale_t l) {
    return (__istype_l(c, 1024L, l));
}


inline int isphonogram_l(int c, locale_t l) {
    return (__istype_l(c, 2097152L, l));
}


inline int isprint_l(int c, locale_t l) {
    return (__istype_l(c, 262144L, l));
}


inline int ispunct_l(int c, locale_t l) {
    return (__istype_l(c, 8192L, l));
}


inline int isrune_l(int c, locale_t l) {
    return (__istype_l(c, 4294967280L, l));
}


inline int isspace_l(int c, locale_t l) {
    return (__istype_l(c, 16384L, l));
}


inline int isspecial_l(int c, locale_t l) {
    return (__istype_l(c, 1048576L, l));
}


inline int isupper_l(int c, locale_t l) {
    return (__istype_l(c, 32768L, l));
}


inline int isxdigit_l(int c, locale_t l) {
    return (__istype_l(c, 65536L, l));
}


inline int tolower_l(int c, locale_t l) {
    return (__tolower_l(c, l));
}


inline int toupper_l(int c, locale_t l) {
    return (__toupper_l(c, l));
}


inline int iswalnum_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 256L | 1024L, _l));
}


inline int iswalpha_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 256L, _l));
}


inline int iswcntrl_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 512L, _l));
}


inline int iswctype_l(wint_t _wc, wctype_t _charclass, locale_t _l) {
    return (__istype_l(_wc, _charclass, _l));
}


inline int iswdigit_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 1024L, _l));
}


inline int iswgraph_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 2048L, _l));
}


inline int iswlower_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 4096L, _l));
}


inline int iswprint_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 262144L, _l));
}


inline int iswpunct_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 8192L, _l));
}


inline int iswspace_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 16384L, _l));
}


inline int iswupper_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 32768L, _l));
}


inline int iswxdigit_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 65536L, _l));
}


inline wint_t towlower_l(wint_t _wc, locale_t _l) {
    return (__tolower_l(_wc, _l));
}


inline wint_t towupper_l(wint_t _wc, locale_t _l) {
    return (__toupper_l(_wc, _l));
}


extern "C" {
    wctype_t wctype_l(const char *, locale_t);
}
extern "C" {
    int fprintf_l(FILE *, locale_t, const char *, ...) __attribute__((format(printf, 3, 4)));
    int fscanf_l(FILE *, locale_t, const char *, ...) __attribute__((format(scanf, 3, 4)));
    int printf_l(locale_t, const char *, ...) __attribute__((format(printf, 2, 3)));
    int scanf_l(locale_t, const char *, ...) __attribute__((format(scanf, 2, 3)));
    int sprintf_l(char *, locale_t, const char *, ...) __attribute__((format(printf, 3, 4)));
    int sscanf_l(const char *, locale_t, const char *, ...) __attribute__((format(scanf, 3, 4)));
    int vfprintf_l(FILE *, locale_t, const char *, va_list) __attribute__((format(printf, 3, 0)));
    int vprintf_l(locale_t, const char *, va_list) __attribute__((format(printf, 2, 0)));
    int vsprintf_l(char *, locale_t, const char *, va_list) __attribute__((format(printf, 3, 0)));
    int snprintf_l(char *, size_t, locale_t, const char *, ...) __attribute__((format(printf, 4, 5)));
    int vfscanf_l(FILE *, locale_t, const char *, va_list) __attribute__((format(scanf, 3, 0)));
    int vscanf_l(locale_t, const char *, va_list) __attribute__((format(scanf, 2, 0)));
    int vsnprintf_l(char *, size_t, locale_t, const char *, va_list) __attribute__((format(printf, 4, 0)));
    int vsscanf_l(const char *, locale_t, const char *, va_list) __attribute__((format(scanf, 3, 0)));
    int dprintf_l(int, locale_t, const char *, ...) __attribute__((availability(macos, introduced=10.7))) __attribute__((format(printf, 3, 4)));
    int vdprintf_l(int, locale_t, const char *, va_list) __attribute__((availability(macos, introduced=10.7))) __attribute__((format(printf, 3, 0)));
    int asprintf_l(char **, locale_t, const char *, ...) __attribute__((format(printf, 3, 4)));
    int vasprintf_l(char **, locale_t, const char *, va_list) __attribute__((format(printf, 3, 0)));
}
extern "C" {
    int strcoll_l(const char *, const char *, locale_t);
    size_t strxfrm_l(char *, const char *, size_t, locale_t);
    int strcasecmp_l(const char *, const char *, locale_t);
    char *strcasestr_l(const char *, const char *, locale_t);
    int strncasecmp_l(const char *, const char *, size_t, locale_t);
}
extern "C" {
    size_t strftime_l(char *, size_t, const char *, const struct tm *, locale_t) asm("_strftime_l") __attribute__((format(strftime, 3, 0)));
    char *strptime_l(const char *, const char *, struct tm *, locale_t) asm("_strptime_l") __attribute__((format(strftime, 2, 0)));
}
extern "C" {
    wint_t btowc_l(int, locale_t);
    wint_t fgetwc_l(FILE *, locale_t);
    wchar_t *fgetws_l(wchar_t *, int, FILE *, locale_t);
    wint_t fputwc_l(wchar_t, FILE *, locale_t);
    int fputws_l(const wchar_t *, FILE *, locale_t);
    int fwprintf_l(FILE *, locale_t, const wchar_t *, ...);
    int fwscanf_l(FILE *, locale_t, const wchar_t *, ...);
    wint_t getwc_l(FILE *, locale_t);
    wint_t getwchar_l(locale_t);
    size_t mbrlen_l(const char *, size_t, mbstate_t *, locale_t);
    size_t mbrtowc_l(wchar_t *, const char *, size_t, mbstate_t *, locale_t);
    int mbsinit_l(const mbstate_t *, locale_t);
    size_t mbsrtowcs_l(wchar_t *, const char **, size_t, mbstate_t *, locale_t);
    wint_t putwc_l(wchar_t, FILE *, locale_t);
    wint_t putwchar_l(wchar_t, locale_t);
    int swprintf_l(wchar_t *, size_t n, locale_t, const wchar_t *, ...);
    int swscanf_l(const wchar_t *, locale_t, const wchar_t *, ...);
    wint_t ungetwc_l(wint_t, FILE *, locale_t);
    int vfwprintf_l(FILE *, locale_t, const wchar_t *, __darwin_va_list);
    int vswprintf_l(wchar_t *, size_t n, locale_t, const wchar_t *, __darwin_va_list);
    int vwprintf_l(locale_t, const wchar_t *, __darwin_va_list);
    size_t wcrtomb_l(char *, wchar_t, mbstate_t *, locale_t);
    int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
    size_t wcsftime_l(wchar_t *, size_t, const wchar_t *, const struct tm *, locale_t) asm("_wcsftime_l");
    size_t wcsrtombs_l(char *, const wchar_t **, size_t, mbstate_t *, locale_t);
    double wcstod_l(const wchar_t *, wchar_t **, locale_t);
    long wcstol_l(const wchar_t *, wchar_t **, int, locale_t);
    unsigned long wcstoul_l(const wchar_t *, wchar_t **, int, locale_t);
    int wcswidth_l(const wchar_t *, size_t, locale_t);
    size_t wcsxfrm_l(wchar_t *, const wchar_t *, size_t, locale_t);
    int wctob_l(wint_t, locale_t);
    int wcwidth_l(wchar_t, locale_t);
    int wprintf_l(locale_t, const wchar_t *, ...);
    int wscanf_l(locale_t, const wchar_t *, ...);
}
extern "C" {
    int vfwscanf_l(FILE *, locale_t, const wchar_t *, __darwin_va_list);
    int vswscanf_l(const wchar_t *, locale_t, const wchar_t *, __darwin_va_list);
    int vwscanf_l(locale_t, const wchar_t *, __darwin_va_list);
    float wcstof_l(const wchar_t *, wchar_t **, locale_t);
    long double wcstold_l(const wchar_t *, wchar_t **, locale_t);
    long long wcstoll_l(const wchar_t *, wchar_t **, int, locale_t);
    unsigned long long wcstoull_l(const wchar_t *, wchar_t **, int, locale_t);
}
extern "C" {
    size_t mbsnrtowcs_l(wchar_t *, const char **, size_t, size_t, mbstate_t *, locale_t);
    int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t) __attribute__((availability(macos, introduced=10.7)));
    int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t n, locale_t) __attribute__((availability(macos, introduced=10.7)));
    size_t wcsnrtombs_l(char *, const wchar_t **, size_t, size_t, mbstate_t *, locale_t);
}
extern "C" {
    wchar_t *fgetwln_l(FILE *, size_t *, locale_t) __attribute__((availability(macos, introduced=10.7)));
}
inline int iswblank_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 131072L, _l));
}


inline int iswhexnumber_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 65536L, _l));
}


inline int iswideogram_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 524288L, _l));
}


inline int iswnumber_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 1024L, _l));
}


inline int iswphonogram_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 2097152L, _l));
}


inline int iswrune_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 4294967280L, _l));
}


inline int iswspecial_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 1048576L, _l));
}


extern "C" {
    wint_t nextwctype_l(wint_t, wctype_t, locale_t);
    wint_t towctrans_l(wint_t, wctrans_t, locale_t);
    wctrans_t wctrans_l(const char *, locale_t);
}
namespace std {
    inline namespace __1 {
        class __attribute__((type_visibility("default"))) locale;
        template <class _Facet> bool has_facet(const std::__1::locale &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        template <class _Facet = std::__1::ctype<char>> inline const std::__1::ctype<char> &use_facet(const std::__1::locale &__l) __attribute__((always_inline))         {
            return static_cast<const std::__1::ctype<char> &>(*__l.use_facet(ctype<char>::id));
        }

template <class _Facet> const _Facet &use_facet(const std::__1::locale &) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        class __attribute__((type_visibility("default"))) locale {
        public:
            class __attribute__((type_visibility("default"))) facet;
            class __attribute__((type_visibility("default"))) id;
            typedef int category;
            static const category none = 0 __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)));
            static const category collate = (1 << 0) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)));
            static const category ctype = (1 << 1) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)));
            static const category monetary = (1 << 3) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)));
            static const category numeric = (1 << 4) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)));
            static const category time = (1 << 5) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)));
            static const category messages = (1 << 2) __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)));
            static const category all = collate | ctype | monetary | numeric | time | messages __attribute__((availability(ios, introduced=7.0))) __attribute__((availability(macos, introduced=10.9)));
            locale() noexcept;
            locale(const std::__1::locale &) noexcept;
            explicit locale(const char *);
            explicit locale(const string &);
            locale(const std::__1::locale &, const char *, category);
            locale(const std::__1::locale &, const string &, category);
            template <class _Facet> locale(const std::__1::locale &, _Facet *) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            locale(const std::__1::locale &, const std::__1::locale &, category);
            ~std::__1::locale() noexcept;
            const std::__1::locale &operator=(const std::__1::locale &) noexcept;
            template <class _Facet> std::__1::locale combine(const std::__1::locale &) const;
            string name() const;
            bool operator==(const std::__1::locale &) const;
            bool operator!=(const std::__1::locale &__y) const             {
                return !(*this == __y);
            }


            template <class _CharT, class _Traits, class _Allocator> bool operator()(const basic_string<_CharT, _Traits, _Allocator> &, const basic_string<_CharT, _Traits, _Allocator> &) const;
            static std::__1::locale global(const std::__1::locale &);
            static const std::__1::locale &classic();
        private:
            class __imp;
            std::__1::locale::__imp *__locale_;
            void __install_ctor(const std::__1::locale &, std::__1::locale::facet *, long);
            static std::__1::locale &__global();
            bool has_facet(std::__1::locale::id &) const;
            const std::__1::locale::facet *use_facet(std::__1::locale::id &) const;
            friend template <class _Facet> bool has_facet(const std::__1::locale &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Facet = std::__1::ctype<char>> inline const std::__1::ctype<char> &use_facet(const std::__1::locale &__l) __attribute__((always_inline))             {
                return static_cast<const std::__1::ctype<char> &>(*__l.use_facet(ctype<char>::id));
            }

template <class _Facet> const _Facet &use_facet(const std::__1::locale &) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        };
        class __attribute__((type_visibility("default"))) facet : public std::__1::__shared_count {
        protected:
            explicit facet(size_t __refs = 0) : std::__1::__shared_count(static_cast<long>(__refs) - 1) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual ~std::__1::locale::facet() noexcept;
        private:
            virtual void __on_zero_shared() noexcept;
        };
        class __attribute__((type_visibility("default"))) id {
            std::__1::once_flag __flag_;
            int32_t __id_;
            static int32_t __next_id;
        public:
            constexpr id() : __flag_(), __id_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        private:
            void __init();
            void operator=(const std::__1::locale::id &);
            id(const std::__1::locale::id &);
        public:
            long __get();
            friend  class locale;
            friend  class locale::__imp;
        };
        template <class _Facet> inline locale(const std::__1::locale &__other, _Facet *__f) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__install_ctor(__other, __f, __f ? __f->id.__get() : 0);
        }

;
        template <class _Facet> std::__1::locale combine(const std::__1::locale &__other) const         {
            if (!std::__1::has_facet<_Facet>(__other))
                throw std::runtime_error("locale::combine: locale missing facet");
            return std::__1::locale(*this, &const_cast<_Facet &>(std::__1::use_facet<_Facet>(__other)));
        }

;
        template <class _Facet> inline bool has_facet(const std::__1::locale &__l) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __l.has_facet(_Facet::id);
        }

;
        template <class _Facet = std::__1::ctype<char>> inline const std::__1::ctype<char> &use_facet(const std::__1::locale &__l) __attribute__((always_inline))         {
            return static_cast<const std::__1::ctype<char> &>(*__l.use_facet(ctype<char>::id));
        }

template <class _Facet> inline const _Facet &use_facet(const std::__1::locale &__l) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<const _Facet &>(*__l.use_facet(_Facet::id));
        }

;
        template <class _CharT = char> class __attribute__((type_visibility("default"))) collate : public locale::facet {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit collate(size_t __refs) __attribute__((always_inline));
            int compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const __attribute__((always_inline));
            string_type transform(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline));
            long hash(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::collate<char>() noexcept;
            virtual int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const;
            virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
            virtual long do_hash(const char_type *__lo, const char_type *__hi) const;
        }
template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) collate : public locale::facet {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit collate(size_t __refs) __attribute__((always_inline));
            int compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const __attribute__((always_inline));
            string_type transform(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline));
            long hash(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::collate<wchar_t>() noexcept;
            virtual int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const;
            virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
            virtual long do_hash(const char_type *__lo, const char_type *__hi) const;
        }
template <class _CharT> class __attribute__((type_visibility("default"))) collate : public locale::facet {
        public:
            typedef _CharT char_type;
            typedef basic_string<char_type> string_type;
            explicit collate<_CharT>(size_t __refs = 0) : locale::facet(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            int compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_compare(__lo1, __hi1, __lo2, __hi2);
            }


            string_type transform(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_transform(__lo, __hi);
            }


            long hash(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_hash(__lo, __hi);
            }


            static locale::id id;
        protected:
            ~collate<_CharT>();
            virtual int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const;
            virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const             {
                return string_type(__lo, __hi);
            }


            virtual long do_hash(const char_type *__lo, const char_type *__hi) const;
        };
        locale::id id;
        ~collate<_CharT>()         {
        }


        int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const         {
            for (; __lo2 != __hi2; ++__lo1 , ++__lo2) {
                if (__lo1 == __hi1 || *__lo1 < *__lo2)
                    return -1;
                if (*__lo2 < *__lo1)
                    return 1;
            }
            return __lo1 != __hi1;
        }


        long do_hash(const char_type *__lo, const char_type *__hi) const         {
            size_t __h = 0;
            const size_t __sr = 8 * sizeof(size_t) - 8;
            const size_t __mask = size_t(15) << (__sr + 4);
            for (const char_type *__p = __lo; __p != __hi; ++__p) {
                __h = (__h << 4) + static_cast<size_t>(*__p);
                size_t __g = __h & __mask;
                __h ^= __g | (__g >> __sr);
            }
            return static_cast<long>(__h);
        }


        class __attribute__((type_visibility("default"))) collate : public locale::facet {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit collate(size_t __refs) __attribute__((always_inline));
            int compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const __attribute__((always_inline));
            string_type transform(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline));
            long hash(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::collate<char>() noexcept;
            virtual int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const;
            virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
            virtual long do_hash(const char_type *__lo, const char_type *__hi) const;
        };
        class __attribute__((type_visibility("default"))) collate : public locale::facet {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit collate(size_t __refs) __attribute__((always_inline));
            int compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const __attribute__((always_inline));
            string_type transform(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline));
            long hash(const char_type *__lo, const char_type *__hi) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::collate<wchar_t>() noexcept;
            virtual int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const;
            virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
            virtual long do_hash(const char_type *__lo, const char_type *__hi) const;
        };
        template <class _CharT = char> class __attribute__((type_visibility("default"))) collate_byname : public collate<char> {
            locale_t __l;
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit collate_byname(const char *__n, size_t __refs = 0);
            explicit collate_byname(const string &__n, size_t __refs = 0);
        protected:
            ~std::__1::collate_byname<char>() noexcept;
            virtual int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const;
            virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
        }
template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) collate_byname : public collate<wchar_t> {
            locale_t __l;
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit collate_byname(const char *__n, size_t __refs = 0);
            explicit collate_byname(const string &__n, size_t __refs = 0);
        protected:
            ~std::__1::collate_byname<wchar_t>() noexcept;
            virtual int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const;
            virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
        }
template <class _CharT> class __attribute__((type_visibility("default"))) collate_byname;
        class __attribute__((type_visibility("default"))) collate_byname : public collate<char> {
            locale_t __l;
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit collate_byname(const char *__n, size_t __refs = 0);
            explicit collate_byname(const string &__n, size_t __refs = 0);
        protected:
            ~std::__1::collate_byname<char>() noexcept;
            virtual int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const;
            virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
        };
        class __attribute__((type_visibility("default"))) collate_byname : public collate<wchar_t> {
            locale_t __l;
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit collate_byname(const char *__n, size_t __refs = 0);
            explicit collate_byname(const string &__n, size_t __refs = 0);
        protected:
            ~std::__1::collate_byname<wchar_t>() noexcept;
            virtual int do_compare(const char_type *__lo1, const char_type *__hi1, const char_type *__lo2, const char_type *__hi2) const;
            virtual string_type do_transform(const char_type *__lo, const char_type *__hi) const;
        };
        template <class _CharT, class _Traits, class _Allocator> bool operator()(const basic_string<_CharT, _Traits, _Allocator> &__x, const basic_string<_CharT, _Traits, _Allocator> &__y) const         {
            return std::__1::use_facet<std::__1::collate<_CharT> >(*this).compare(__x.data(), __x.data() + __x.size(), __y.data(), __y.data() + __y.size()) < 0;
        }

;
        class __attribute__((type_visibility("default"))) ctype_base {
        public:
            typedef __uint32_t mask;
            static const mask space = 16384L;
            static const mask print = 262144L;
            static const mask cntrl = 512L;
            static const mask upper = 32768L;
            static const mask lower = 4096L;
            static const mask alpha = 256L;
            static const mask digit = 1024L;
            static const mask punct = 8192L;
            static const mask xdigit = 65536L;
            static const mask blank = 131072L;
            static const mask alnum = alpha | digit;
            static const mask graph = alnum | punct;
            ctype_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) ctype : public locale::facet, public std::__1::ctype_base {
        public:
            typedef wchar_t char_type;
            explicit ctype(size_t __refs = 0) : locale::facet(__refs), std::__1::ctype_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            bool is(mask __m, char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_is(__m, __c);
            }


            const char_type *is(const char_type *__low, const char_type *__high, mask *__vec) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_is(__low, __high, __vec);
            }


            const char_type *scan_is(mask __m, const char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_scan_is(__m, __low, __high);
            }


            const char_type *scan_not(mask __m, const char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_scan_not(__m, __low, __high);
            }


            char_type toupper(char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_toupper(__c);
            }


            const char_type *toupper(char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_toupper(__low, __high);
            }


            char_type tolower(char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_tolower(__c);
            }


            const char_type *tolower(char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_tolower(__low, __high);
            }


            char_type widen(char __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_widen(__c);
            }


            const char *widen(const char *__low, const char *__high, char_type *__to) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_widen(__low, __high, __to);
            }


            char narrow(char_type __c, char __dfault) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_narrow(__c, __dfault);
            }


            const char_type *narrow(const char_type *__low, const char_type *__high, char __dfault, char *__to) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_narrow(__low, __high, __dfault, __to);
            }


            static locale::id id;
        protected:
            ~std::__1::ctype<wchar_t>() noexcept;
            virtual bool do_is(mask __m, char_type __c) const;
            virtual const char_type *do_is(const char_type *__low, const char_type *__high, mask *__vec) const;
            virtual const char_type *do_scan_is(mask __m, const char_type *__low, const char_type *__high) const;
            virtual const char_type *do_scan_not(mask __m, const char_type *__low, const char_type *__high) const;
            virtual char_type do_toupper(char_type) const;
            virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
            virtual char_type do_tolower(char_type) const;
            virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
            virtual char_type do_widen(char) const;
            virtual const char *do_widen(const char *__low, const char *__high, char_type *__dest) const;
            virtual char do_narrow(char_type, char __dfault) const;
            virtual const char_type *do_narrow(const char_type *__low, const char_type *__high, char __dfault, char *__dest) const;
        }
template <class _CharT = char> class __attribute__((type_visibility("default"))) ctype : public locale::facet, public std::__1::ctype_base {
            const mask *__tab_;
            bool __del_;
        public:
            typedef char char_type;
            explicit ctype(const mask *__tab = 0, bool __del = false, size_t __refs = 0);
            bool is(mask __m, char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return isascii(__c) ? (this->__tab_[static_cast<int>(__c)] & __m) != 0 : false;
            }


            const char_type *is(const char_type *__low, const char_type *__high, mask *__vec) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __low != __high; ++__low , ++__vec) 
                    *__vec = isascii(*__low) ? this->__tab_[static_cast<int>(*__low)] : 0;
                return __low;
            }


            const char_type *scan_is(mask __m, const char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __low != __high; ++__low) 
                    if (isascii(*__low) && (this->__tab_[static_cast<int>(*__low)] & __m))
                        break;
                return __low;
            }


            const char_type *scan_not(mask __m, const char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __low != __high; ++__low) 
                    if (!(isascii(*__low) && (this->__tab_[static_cast<int>(*__low)] & __m)))
                        break;
                return __low;
            }


            char_type toupper(char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_toupper(__c);
            }


            const char_type *toupper(char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_toupper(__low, __high);
            }


            char_type tolower(char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_tolower(__c);
            }


            const char_type *tolower(char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_tolower(__low, __high);
            }


            char_type widen(char __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_widen(__c);
            }


            const char *widen(const char *__low, const char *__high, char_type *__to) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_widen(__low, __high, __to);
            }


            char narrow(char_type __c, char __dfault) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_narrow(__c, __dfault);
            }


            const char *narrow(const char_type *__low, const char_type *__high, char __dfault, char *__to) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_narrow(__low, __high, __dfault, __to);
            }


            static locale::id id;
            static const size_t table_size = (1 << 8);
            const mask *table() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__tab_;
            }


            static const mask *classic_table() noexcept;
        protected:
            ~std::__1::ctype<char>() noexcept;
            virtual char_type do_toupper(char_type __c) const;
            virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
            virtual char_type do_tolower(char_type __c) const;
            virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
            virtual char_type do_widen(char __c) const;
            virtual const char *do_widen(const char *__low, const char *__high, char_type *__to) const;
            virtual char do_narrow(char_type __c, char __dfault) const;
            virtual const char *do_narrow(const char_type *__low, const char_type *__high, char __dfault, char *__to) const;
        }
template <class _CharT> class __attribute__((type_visibility("default"))) ctype;
        class __attribute__((type_visibility("default"))) ctype : public locale::facet, public std::__1::ctype_base {
        public:
            typedef wchar_t char_type;
            explicit ctype(size_t __refs = 0) : locale::facet(__refs), std::__1::ctype_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            bool is(mask __m, char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_is(__m, __c);
            }


            const char_type *is(const char_type *__low, const char_type *__high, mask *__vec) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_is(__low, __high, __vec);
            }


            const char_type *scan_is(mask __m, const char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_scan_is(__m, __low, __high);
            }


            const char_type *scan_not(mask __m, const char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_scan_not(__m, __low, __high);
            }


            char_type toupper(char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_toupper(__c);
            }


            const char_type *toupper(char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_toupper(__low, __high);
            }


            char_type tolower(char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_tolower(__c);
            }


            const char_type *tolower(char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_tolower(__low, __high);
            }


            char_type widen(char __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_widen(__c);
            }


            const char *widen(const char *__low, const char *__high, char_type *__to) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_widen(__low, __high, __to);
            }


            char narrow(char_type __c, char __dfault) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_narrow(__c, __dfault);
            }


            const char_type *narrow(const char_type *__low, const char_type *__high, char __dfault, char *__to) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_narrow(__low, __high, __dfault, __to);
            }


            static locale::id id;
        protected:
            ~std::__1::ctype<wchar_t>() noexcept;
            virtual bool do_is(mask __m, char_type __c) const;
            virtual const char_type *do_is(const char_type *__low, const char_type *__high, mask *__vec) const;
            virtual const char_type *do_scan_is(mask __m, const char_type *__low, const char_type *__high) const;
            virtual const char_type *do_scan_not(mask __m, const char_type *__low, const char_type *__high) const;
            virtual char_type do_toupper(char_type) const;
            virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
            virtual char_type do_tolower(char_type) const;
            virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
            virtual char_type do_widen(char) const;
            virtual const char *do_widen(const char *__low, const char *__high, char_type *__dest) const;
            virtual char do_narrow(char_type, char __dfault) const;
            virtual const char_type *do_narrow(const char_type *__low, const char_type *__high, char __dfault, char *__dest) const;
        };
        class __attribute__((type_visibility("default"))) ctype : public locale::facet, public std::__1::ctype_base {
            const mask *__tab_;
            bool __del_;
        public:
            typedef char char_type;
            explicit ctype(const mask *__tab = 0, bool __del = false, size_t __refs = 0);
            bool is(mask __m, char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return isascii(__c) ? (this->__tab_[static_cast<int>(__c)] & __m) != 0 : false;
            }


            const char_type *is(const char_type *__low, const char_type *__high, mask *__vec) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __low != __high; ++__low , ++__vec) 
                    *__vec = isascii(*__low) ? this->__tab_[static_cast<int>(*__low)] : 0;
                return __low;
            }


            const char_type *scan_is(mask __m, const char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __low != __high; ++__low) 
                    if (isascii(*__low) && (this->__tab_[static_cast<int>(*__low)] & __m))
                        break;
                return __low;
            }


            const char_type *scan_not(mask __m, const char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __low != __high; ++__low) 
                    if (!(isascii(*__low) && (this->__tab_[static_cast<int>(*__low)] & __m)))
                        break;
                return __low;
            }


            char_type toupper(char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_toupper(__c);
            }


            const char_type *toupper(char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_toupper(__low, __high);
            }


            char_type tolower(char_type __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_tolower(__c);
            }


            const char_type *tolower(char_type *__low, const char_type *__high) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_tolower(__low, __high);
            }


            char_type widen(char __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_widen(__c);
            }


            const char *widen(const char *__low, const char *__high, char_type *__to) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_widen(__low, __high, __to);
            }


            char narrow(char_type __c, char __dfault) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_narrow(__c, __dfault);
            }


            const char *narrow(const char_type *__low, const char_type *__high, char __dfault, char *__to) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_narrow(__low, __high, __dfault, __to);
            }


            static locale::id id;
            static const size_t table_size = (1 << 8);
            const mask *table() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__tab_;
            }


            static const mask *classic_table() noexcept;
        protected:
            ~std::__1::ctype<char>() noexcept;
            virtual char_type do_toupper(char_type __c) const;
            virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
            virtual char_type do_tolower(char_type __c) const;
            virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
            virtual char_type do_widen(char __c) const;
            virtual const char *do_widen(const char *__low, const char *__high, char_type *__to) const;
            virtual char do_narrow(char_type __c, char __dfault) const;
            virtual const char *do_narrow(const char_type *__low, const char_type *__high, char __dfault, char *__to) const;
        };
        template <class _CharT = char> class __attribute__((type_visibility("default"))) ctype_byname : public ctype<char> {
            locale_t __l;
        public:
            explicit ctype_byname(const char *, size_t = 0);
            explicit ctype_byname(const string &, size_t = 0);
        protected:
            ~std::__1::ctype_byname<char>() noexcept;
            virtual char_type do_toupper(char_type) const;
            virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
            virtual char_type do_tolower(char_type) const;
            virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
        }
template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) ctype_byname : public ctype<wchar_t> {
            locale_t __l;
        public:
            explicit ctype_byname(const char *, size_t = 0);
            explicit ctype_byname(const string &, size_t = 0);
        protected:
            ~std::__1::ctype_byname<wchar_t>() noexcept;
            virtual bool do_is(mask __m, char_type __c) const;
            virtual const char_type *do_is(const char_type *__low, const char_type *__high, mask *__vec) const;
            virtual const char_type *do_scan_is(mask __m, const char_type *__low, const char_type *__high) const;
            virtual const char_type *do_scan_not(mask __m, const char_type *__low, const char_type *__high) const;
            virtual char_type do_toupper(char_type) const;
            virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
            virtual char_type do_tolower(char_type) const;
            virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
            virtual char_type do_widen(char) const;
            virtual const char *do_widen(const char *__low, const char *__high, char_type *__dest) const;
            virtual char do_narrow(char_type, char __dfault) const;
            virtual const char_type *do_narrow(const char_type *__low, const char_type *__high, char __dfault, char *__dest) const;
        }
template <class _CharT> class __attribute__((type_visibility("default"))) ctype_byname;
        class __attribute__((type_visibility("default"))) ctype_byname : public ctype<char> {
            locale_t __l;
        public:
            explicit ctype_byname(const char *, size_t = 0);
            explicit ctype_byname(const string &, size_t = 0);
        protected:
            ~std::__1::ctype_byname<char>() noexcept;
            virtual char_type do_toupper(char_type) const;
            virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
            virtual char_type do_tolower(char_type) const;
            virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
        };
        class __attribute__((type_visibility("default"))) ctype_byname : public ctype<wchar_t> {
            locale_t __l;
        public:
            explicit ctype_byname(const char *, size_t = 0);
            explicit ctype_byname(const string &, size_t = 0);
        protected:
            ~std::__1::ctype_byname<wchar_t>() noexcept;
            virtual bool do_is(mask __m, char_type __c) const;
            virtual const char_type *do_is(const char_type *__low, const char_type *__high, mask *__vec) const;
            virtual const char_type *do_scan_is(mask __m, const char_type *__low, const char_type *__high) const;
            virtual const char_type *do_scan_not(mask __m, const char_type *__low, const char_type *__high) const;
            virtual char_type do_toupper(char_type) const;
            virtual const char_type *do_toupper(char_type *__low, const char_type *__high) const;
            virtual char_type do_tolower(char_type) const;
            virtual const char_type *do_tolower(char_type *__low, const char_type *__high) const;
            virtual char_type do_widen(char) const;
            virtual const char *do_widen(const char *__low, const char *__high, char_type *__dest) const;
            virtual char do_narrow(char_type, char __dfault) const;
            virtual const char_type *do_narrow(const char_type *__low, const char_type *__high, char __dfault, char *__dest) const;
        };
        template <class _CharT> inline bool isspace(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
        }

;
        template <class _CharT> inline bool isprint(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
        }

;
        template <class _CharT> inline bool iscntrl(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
        }

;
        template <class _CharT> inline bool isupper(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
        }

;
        template <class _CharT> inline bool islower(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
        }

;
        template <class _CharT> inline bool isalpha(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
        }

;
        template <class _CharT> inline bool isdigit(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
        }

;
        template <class _CharT> inline bool ispunct(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
        }

;
        template <class _CharT> inline bool isxdigit(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
        }

;
        template <class _CharT> inline bool isalnum(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
        }

;
        template <class _CharT> inline bool isgraph(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
        }

;
        template <class _CharT> inline _CharT toupper(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).toupper(__c);
        }

;
        template <class _CharT> inline _CharT tolower(_CharT __c, const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<_CharT> >(__loc).tolower(__c);
        }

;
        class __attribute__((type_visibility("default"))) codecvt_base {
        public:
            codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            enum result {
                ok,
                partial,
                error,
                noconv
            };
        };
        template <class _InternT = char, class _ExternT = char, class _StateT = __mbstate_t> class __attribute__((type_visibility("default"))) codecvt : public locale::facet, public std::__1::codecvt_base {
        public:
            typedef char intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            std::__1::codecvt_base::result out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            int encoding() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_encoding();
            }


            bool always_noconv() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_always_noconv();
            }


            int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_length(__st, __frm, __end, __mx);
            }


            int max_length() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_max_length();
            }


            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::codecvt<char, char, mbstate_t>() noexcept;
            virtual std::__1::codecvt_base::result do_out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual int do_encoding() const noexcept;
            virtual bool do_always_noconv() const noexcept;
            virtual int do_length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const noexcept;
        }
template <class _InternT = wchar_t, class _ExternT = char, class _StateT = __mbstate_t> class __attribute__((type_visibility("default"))) codecvt : public locale::facet, public std::__1::codecvt_base {
            locale_t __l;
        public:
            typedef wchar_t intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0);
            std::__1::codecvt_base::result out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            int encoding() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_encoding();
            }


            bool always_noconv() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_always_noconv();
            }


            int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_length(__st, __frm, __end, __mx);
            }


            int max_length() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_max_length();
            }


            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0);
            ~std::__1::codecvt<wchar_t, char, mbstate_t>() noexcept;
            virtual std::__1::codecvt_base::result do_out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual int do_encoding() const noexcept;
            virtual bool do_always_noconv() const noexcept;
            virtual int do_length(state_type &, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const noexcept;
        }
template <class _InternT = char16_t, class _ExternT = char, class _StateT = __mbstate_t> class __attribute__((type_visibility("default"))) codecvt : public locale::facet, public std::__1::codecvt_base {
        public:
            typedef char16_t intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            std::__1::codecvt_base::result out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            int encoding() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_encoding();
            }


            bool always_noconv() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_always_noconv();
            }


            int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_length(__st, __frm, __end, __mx);
            }


            int max_length() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_max_length();
            }


            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::codecvt<char16_t, char, mbstate_t>() noexcept;
            virtual std::__1::codecvt_base::result do_out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual int do_encoding() const noexcept;
            virtual bool do_always_noconv() const noexcept;
            virtual int do_length(state_type &, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const noexcept;
        }
template <class _InternT = char32_t, class _ExternT = char, class _StateT = __mbstate_t> class __attribute__((type_visibility("default"))) codecvt : public locale::facet, public std::__1::codecvt_base {
        public:
            typedef char32_t intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            std::__1::codecvt_base::result out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            int encoding() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_encoding();
            }


            bool always_noconv() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_always_noconv();
            }


            int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_length(__st, __frm, __end, __mx);
            }


            int max_length() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_max_length();
            }


            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::codecvt<char32_t, char, mbstate_t>() noexcept;
            virtual std::__1::codecvt_base::result do_out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual int do_encoding() const noexcept;
            virtual bool do_always_noconv() const noexcept;
            virtual int do_length(state_type &, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const noexcept;
        }
template <class _InternT, class _ExternT, class _StateT> class __attribute__((type_visibility("default"))) codecvt;
        class __attribute__((type_visibility("default"))) codecvt : public locale::facet, public std::__1::codecvt_base {
        public:
            typedef char intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            std::__1::codecvt_base::result out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            int encoding() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_encoding();
            }


            bool always_noconv() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_always_noconv();
            }


            int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_length(__st, __frm, __end, __mx);
            }


            int max_length() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_max_length();
            }


            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::codecvt<char, char, mbstate_t>() noexcept;
            virtual std::__1::codecvt_base::result do_out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual int do_encoding() const noexcept;
            virtual bool do_always_noconv() const noexcept;
            virtual int do_length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const noexcept;
        };
        class __attribute__((type_visibility("default"))) codecvt : public locale::facet, public std::__1::codecvt_base {
            locale_t __l;
        public:
            typedef wchar_t intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0);
            std::__1::codecvt_base::result out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            int encoding() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_encoding();
            }


            bool always_noconv() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_always_noconv();
            }


            int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_length(__st, __frm, __end, __mx);
            }


            int max_length() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_max_length();
            }


            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0);
            ~std::__1::codecvt<wchar_t, char, mbstate_t>() noexcept;
            virtual std::__1::codecvt_base::result do_out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual int do_encoding() const noexcept;
            virtual bool do_always_noconv() const noexcept;
            virtual int do_length(state_type &, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const noexcept;
        };
        class __attribute__((type_visibility("default"))) codecvt : public locale::facet, public std::__1::codecvt_base {
        public:
            typedef char16_t intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            std::__1::codecvt_base::result out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            int encoding() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_encoding();
            }


            bool always_noconv() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_always_noconv();
            }


            int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_length(__st, __frm, __end, __mx);
            }


            int max_length() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_max_length();
            }


            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::codecvt<char16_t, char, mbstate_t>() noexcept;
            virtual std::__1::codecvt_base::result do_out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual int do_encoding() const noexcept;
            virtual bool do_always_noconv() const noexcept;
            virtual int do_length(state_type &, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const noexcept;
        };
        class __attribute__((type_visibility("default"))) codecvt : public locale::facet, public std::__1::codecvt_base {
        public:
            typedef char32_t intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            std::__1::codecvt_base::result out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }


            std::__1::codecvt_base::result in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }


            int encoding() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_encoding();
            }


            bool always_noconv() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_always_noconv();
            }


            int length(state_type &__st, const extern_type *__frm, const extern_type *__end, size_t __mx) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_length(__st, __frm, __end, __mx);
            }


            int max_length() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_max_length();
            }


            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::codecvt<char32_t, char, mbstate_t>() noexcept;
            virtual std::__1::codecvt_base::result do_out(state_type &__st, const intern_type *__frm, const intern_type *__frm_end, const intern_type *&__frm_nxt, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(state_type &__st, const extern_type *__frm, const extern_type *__frm_end, const extern_type *&__frm_nxt, intern_type *__to, intern_type *__to_end, intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(state_type &__st, extern_type *__to, extern_type *__to_end, extern_type *&__to_nxt) const;
            virtual int do_encoding() const noexcept;
            virtual bool do_always_noconv() const noexcept;
            virtual int do_length(state_type &, const extern_type *__frm, const extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const noexcept;
        };
        template <class _InternT = char, class _ExternT = char, class _StateT = __mbstate_t> class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<char, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit codecvt_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::codecvt_byname<char, char, mbstate_t>() noexcept;
        }
template <class _InternT = wchar_t, class _ExternT = char, class _StateT = __mbstate_t> class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<wchar_t, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit codecvt_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::codecvt_byname<wchar_t, char, mbstate_t>() noexcept;
        }
template <class _InternT = char16_t, class _ExternT = char, class _StateT = __mbstate_t> class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<char16_t, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit codecvt_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::codecvt_byname<char16_t, char, mbstate_t>() noexcept;
        }
template <class _InternT = char32_t, class _ExternT = char, class _StateT = __mbstate_t> class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<char32_t, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit codecvt_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::codecvt_byname<char32_t, char, mbstate_t>() noexcept;
        }
template <class _InternT, class _ExternT, class _StateT> class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<_InternT, _ExternT, _StateT> {
        public:
            explicit codecvt_byname<_InternT, _ExternT, _StateT>(const char *__nm, size_t __refs = 0) : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit codecvt_byname<_InternT, _ExternT, _StateT>(const string &__nm, size_t __refs = 0) : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        protected:
            ~codecvt_byname<_InternT, _ExternT, _StateT>();
        };
        ~codecvt_byname<_InternT, _ExternT, _StateT>()         {
        }


        class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<char, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit codecvt_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::codecvt_byname<char, char, mbstate_t>() noexcept;
        };
        class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<wchar_t, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit codecvt_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::codecvt_byname<wchar_t, char, mbstate_t>() noexcept;
        };
        class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<char16_t, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit codecvt_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::codecvt_byname<char16_t, char, mbstate_t>() noexcept;
        };
        class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<char32_t, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit codecvt_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::codecvt_byname<char32_t, char, mbstate_t>() noexcept;
        };
        void __throw_runtime_error(const char *) __attribute__((visibility("default")));
        template <size_t _Np = 8> struct __narrow_to_utf8 {
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __wb < __we; ++__wb , ++__s) 
                    *__s = *__wb;
                return __s;
            }

;
        }
template <size_t _Np = 16> struct __narrow_to_utf8 : public codecvt<char16_t, char, mbstate_t> {
            __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::__narrow_to_utf8<16>() noexcept;
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__wb < __we && __r != error)
                    {
                        const int __sz = 32;
                        char __buf[32];
                        char *__bn;
                        const char16_t *__wn = (const char16_t *)__wb;
                        __r = this->do_out(__mb, (const char16_t *)__wb, (const char16_t *)__we, __wn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __wn == (const char16_t *)__wb)
                            __throw_runtime_error("locale not supported");
                        for (const char *__p = __buf; __p < __bn; ++__p , ++__s) 
                            *__s = *__p;
                        __wb = (const _CharT *)__wn;
                    }
                return __s;
            }

;
        }
template <size_t _Np = 32> struct __narrow_to_utf8 : public codecvt<char32_t, char, mbstate_t> {
            __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::__narrow_to_utf8<32>() noexcept;
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__wb < __we && __r != error)
                    {
                        const int __sz = 32;
                        char __buf[32];
                        char *__bn;
                        const char32_t *__wn = (const char32_t *)__wb;
                        __r = this->do_out(__mb, (const char32_t *)__wb, (const char32_t *)__we, __wn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __wn == (const char32_t *)__wb)
                            __throw_runtime_error("locale not supported");
                        for (const char *__p = __buf; __p < __bn; ++__p , ++__s) 
                            *__s = *__p;
                        __wb = (const _CharT *)__wn;
                    }
                return __s;
            }

;
        }
template <size_t _Np> struct __narrow_to_utf8 {
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const;
        };
        struct __narrow_to_utf8 {
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __wb < __we; ++__wb , ++__s) 
                    *__s = *__wb;
                return __s;
            }

;
        };
        struct __narrow_to_utf8 : public codecvt<char16_t, char, mbstate_t> {
            __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::__narrow_to_utf8<16>() noexcept;
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__wb < __we && __r != error)
                    {
                        const int __sz = 32;
                        char __buf[32];
                        char *__bn;
                        const char16_t *__wn = (const char16_t *)__wb;
                        __r = this->do_out(__mb, (const char16_t *)__wb, (const char16_t *)__we, __wn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __wn == (const char16_t *)__wb)
                            __throw_runtime_error("locale not supported");
                        for (const char *__p = __buf; __p < __bn; ++__p , ++__s) 
                            *__s = *__p;
                        __wb = (const _CharT *)__wn;
                    }
                return __s;
            }

;
        };
        struct __narrow_to_utf8 : public codecvt<char32_t, char, mbstate_t> {
            __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::__narrow_to_utf8<32>() noexcept;
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__wb < __we && __r != error)
                    {
                        const int __sz = 32;
                        char __buf[32];
                        char *__bn;
                        const char32_t *__wn = (const char32_t *)__wb;
                        __r = this->do_out(__mb, (const char32_t *)__wb, (const char32_t *)__we, __wn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __wn == (const char32_t *)__wb)
                            __throw_runtime_error("locale not supported");
                        for (const char *__p = __buf; __p < __bn; ++__p , ++__s) 
                            *__s = *__p;
                        __wb = (const _CharT *)__wn;
                    }
                return __s;
            }

;
        };
        template <size_t _Np = 8> struct __widen_from_utf8 {
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __nb < __ne; ++__nb , ++__s) 
                    *__s = *__nb;
                return __s;
            }

;
        }
template <size_t _Np = 16> struct __widen_from_utf8 : public codecvt<char16_t, char, mbstate_t> {
            __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::__widen_from_utf8<16>() noexcept;
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__nb < __ne && __r != error)
                    {
                        const int __sz = 32;
                        char16_t __buf[32];
                        char16_t *__bn;
                        const char *__nn = __nb;
                        __r = this->do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __nn == __nb)
                            __throw_runtime_error("locale not supported");
                        for (const char16_t *__p = __buf; __p < __bn; ++__p , ++__s) 
                            *__s = (wchar_t)*__p;
                        __nb = __nn;
                    }
                return __s;
            }

;
        }
template <size_t _Np = 32> struct __widen_from_utf8 : public codecvt<char32_t, char, mbstate_t> {
            __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::__widen_from_utf8<32>() noexcept;
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__nb < __ne && __r != error)
                    {
                        const int __sz = 32;
                        char32_t __buf[32];
                        char32_t *__bn;
                        const char *__nn = __nb;
                        __r = this->do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __nn == __nb)
                            __throw_runtime_error("locale not supported");
                        for (const char32_t *__p = __buf; __p < __bn; ++__p , ++__s) 
                            *__s = (wchar_t)*__p;
                        __nb = __nn;
                    }
                return __s;
            }

;
        }
template <size_t _Np> struct __widen_from_utf8 {
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const;
        };
        struct __widen_from_utf8 {
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                for (; __nb < __ne; ++__nb , ++__s) 
                    *__s = *__nb;
                return __s;
            }

;
        };
        struct __widen_from_utf8 : public codecvt<char16_t, char, mbstate_t> {
            __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::__widen_from_utf8<16>() noexcept;
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__nb < __ne && __r != error)
                    {
                        const int __sz = 32;
                        char16_t __buf[32];
                        char16_t *__bn;
                        const char *__nn = __nb;
                        __r = this->do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __nn == __nb)
                            __throw_runtime_error("locale not supported");
                        for (const char16_t *__p = __buf; __p < __bn; ++__p , ++__s) 
                            *__s = (wchar_t)*__p;
                        __nb = __nn;
                    }
                return __s;
            }

;
        };
        struct __widen_from_utf8 : public codecvt<char32_t, char, mbstate_t> {
            __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~std::__1::__widen_from_utf8<32>() noexcept;
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__nb < __ne && __r != error)
                    {
                        const int __sz = 32;
                        char32_t __buf[32];
                        char32_t *__bn;
                        const char *__nn = __nb;
                        __r = this->do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __nn == __nb)
                            __throw_runtime_error("locale not supported");
                        for (const char32_t *__p = __buf; __p < __bn; ++__p , ++__s) 
                            *__s = (wchar_t)*__p;
                        __nb = __nn;
                    }
                return __s;
            }

;
        };
        template <class _CharT = char> class __attribute__((type_visibility("default"))) numpunct : public locale::facet {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit numpunct(size_t __refs = 0);
            char_type decimal_point() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_decimal_point();
            }


            char_type thousands_sep() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_thousands_sep();
            }


            string grouping() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_grouping();
            }


            string_type truename() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_truename();
            }


            string_type falsename() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_falsename();
            }


            static locale::id id;
        protected:
            ~std::__1::numpunct<char>() noexcept;
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_truename() const;
            virtual string_type do_falsename() const;
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
        }
template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) numpunct : public locale::facet {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit numpunct(size_t __refs = 0);
            char_type decimal_point() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_decimal_point();
            }


            char_type thousands_sep() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_thousands_sep();
            }


            string grouping() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_grouping();
            }


            string_type truename() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_truename();
            }


            string_type falsename() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_falsename();
            }


            static locale::id id;
        protected:
            ~std::__1::numpunct<wchar_t>() noexcept;
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_truename() const;
            virtual string_type do_falsename() const;
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
        }
template <class _CharT> class __attribute__((type_visibility("default"))) numpunct;
        class __attribute__((type_visibility("default"))) numpunct : public locale::facet {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit numpunct(size_t __refs = 0);
            char_type decimal_point() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_decimal_point();
            }


            char_type thousands_sep() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_thousands_sep();
            }


            string grouping() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_grouping();
            }


            string_type truename() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_truename();
            }


            string_type falsename() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_falsename();
            }


            static locale::id id;
        protected:
            ~std::__1::numpunct<char>() noexcept;
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_truename() const;
            virtual string_type do_falsename() const;
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
        };
        class __attribute__((type_visibility("default"))) numpunct : public locale::facet {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit numpunct(size_t __refs = 0);
            char_type decimal_point() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_decimal_point();
            }


            char_type thousands_sep() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_thousands_sep();
            }


            string grouping() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_grouping();
            }


            string_type truename() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_truename();
            }


            string_type falsename() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_falsename();
            }


            static locale::id id;
        protected:
            ~std::__1::numpunct<wchar_t>() noexcept;
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_truename() const;
            virtual string_type do_falsename() const;
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
        };
        template <class _CharT = char> class __attribute__((type_visibility("default"))) numpunct_byname : public numpunct<char> {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit numpunct_byname(const char *__nm, size_t __refs = 0);
            explicit numpunct_byname(const string &__nm, size_t __refs = 0);
        protected:
            ~std::__1::numpunct_byname<char>() noexcept;
        private:
            void __init(const char *);
        }
template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) numpunct_byname : public numpunct<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit numpunct_byname(const char *__nm, size_t __refs = 0);
            explicit numpunct_byname(const string &__nm, size_t __refs = 0);
        protected:
            ~std::__1::numpunct_byname<wchar_t>() noexcept;
        private:
            void __init(const char *);
        }
template <class _CharT> class __attribute__((type_visibility("default"))) numpunct_byname;
        class __attribute__((type_visibility("default"))) numpunct_byname : public numpunct<char> {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit numpunct_byname(const char *__nm, size_t __refs = 0);
            explicit numpunct_byname(const string &__nm, size_t __refs = 0);
        protected:
            ~std::__1::numpunct_byname<char>() noexcept;
        private:
            void __init(const char *);
        };
        class __attribute__((type_visibility("default"))) numpunct_byname : public numpunct<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit numpunct_byname(const char *__nm, size_t __refs = 0);
            explicit numpunct_byname(const string &__nm, size_t __refs = 0);
        protected:
            ~std::__1::numpunct_byname<wchar_t>() noexcept;
        private:
            void __init(const char *);
        };
    }
}
namespace std {
    inline namespace __1 {
        typedef ptrdiff_t streamsize;
        class __attribute__((type_visibility("default"))) ios_base {
        public:
            class __attribute__((type_visibility("default"))) failure;
            typedef unsigned int fmtflags;
            static const fmtflags boolalpha = 1;
            static const fmtflags dec = 2;
            static const fmtflags fixed = 4;
            static const fmtflags hex = 8;
            static const fmtflags internal = 16;
            static const fmtflags left = 32;
            static const fmtflags oct = 64;
            static const fmtflags right = 128;
            static const fmtflags scientific = 256;
            static const fmtflags showbase = 512;
            static const fmtflags showpoint = 1024;
            static const fmtflags showpos = 2048;
            static const fmtflags skipws = 4096;
            static const fmtflags unitbuf = 8192;
            static const fmtflags uppercase = 16384;
            static const fmtflags adjustfield = left | right | internal;
            static const fmtflags basefield = dec | oct | hex;
            static const fmtflags floatfield = scientific | fixed;
            typedef unsigned int iostate;
            typedef iostate io_state;
            static const iostate badbit = 1;
            static const iostate eofbit = 2;
            static const iostate failbit = 4;
            static const iostate goodbit = 0;
            typedef unsigned int openmode;
            typedef openmode open_mode;
            static const openmode app = 1;
            static const openmode ate = 2;
            static const openmode binary = 4;
            static const openmode in = 8;
            static const openmode out = 16;
            static const openmode trunc = 32;
            enum seekdir {
                beg,
                cur,
                end
            };
            typedef std::__1::ios_base::seekdir seek_dir;
            typedef std::__1::streamoff streamoff;
            typedef std::__1::streampos streampos;
            class __attribute__((type_visibility("default"))) Init;
            fmtflags flags() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            fmtflags flags(fmtflags __fmtfl) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            fmtflags setf(fmtflags __fmtfl) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            fmtflags setf(fmtflags __fmtfl, fmtflags __mask) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void unsetf(fmtflags __mask) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            streamsize precision() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            streamsize precision(streamsize __prec) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            streamsize width() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            streamsize width(streamsize __wide) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            std::__1::locale imbue(const std::__1::locale &__loc);
            std::__1::locale getloc() const;
            static int xalloc();
            long &iword(int __index);
            void *&pword(int __index);
            virtual ~std::__1::ios_base() noexcept;
            enum event {
                erase_event,
                imbue_event,
                copyfmt_event
            };
            typedef void (*event_callback)(std::__1::ios_base::event, std::__1::ios_base &, int);
            void register_callback(event_callback __fn, int __index);
        private:
            ios_base(const std::__1::ios_base &);
            std::__1::ios_base &operator=(const std::__1::ios_base &);
        public:
            static bool sync_with_stdio(bool __sync = true);
            iostate rdstate() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void clear(iostate __state = goodbit);
            void setstate(iostate __state) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool good() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool eof() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool fail() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool bad() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            iostate exceptions() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void exceptions(iostate __iostate) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void __set_badbit_and_consider_rethrow();
            void __set_failbit_and_consider_rethrow();
        protected:
            ios_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void init(void *__sb);
            void *rdbuf() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__rdbuf_;
            }


            void rdbuf(void *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__rdbuf_ = __sb;
                this->clear();
            }


            void __call_callbacks(std::__1::ios_base::event);
            void copyfmt(const std::__1::ios_base &);
            void move(std::__1::ios_base &);
            void swap(std::__1::ios_base &) noexcept;
            void set_rdbuf(void *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__rdbuf_ = __sb;
            }


        private:
            fmtflags __fmtflags_;
            streamsize __precision_;
            streamsize __width_;
            iostate __rdstate_;
            iostate __exceptions_;
            void *__rdbuf_;
            void *__loc_;
            event_callback *__fn_;
            int *__index_;
            size_t __event_size_;
            size_t __event_cap_;
            static atomic<int> __xindex_;
            long *__iarray_;
            size_t __iarray_size_;
            size_t __iarray_cap_;
            void **__parray_;
            size_t __parray_size_;
            size_t __parray_cap_;
        };
        enum class io_errc : int {
            stream = 1
        } __attribute__((type_visibility("default")));
        struct __attribute__((type_visibility("default"))) is_error_code_enum : public true_type {
        };
        const std::__1::error_category &iostream_category() noexcept __attribute__((visibility("default")));
        inline std::__1::error_code make_error_code(std::__1::io_errc __e) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::error_code(static_cast<int>(__e), iostream_category());
        }


        inline std::__1::error_condition make_error_condition(std::__1::io_errc __e) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::error_condition(static_cast<int>(__e), iostream_category());
        }


        class __attribute__((visibility("default"))) __attribute__((type_visibility("default"))) failure : public std::__1::system_error {
        public:
            explicit failure(const string &__msg, const std::__1::error_code &__ec = io_errc::stream);
            explicit failure(const char *__msg, const std::__1::error_code &__ec = io_errc::stream);
            virtual ~std::__1::ios_base::failure() throw();
        };
        class __attribute__((type_visibility("default"))) Init {
        public:
            Init();
            ~std::__1::ios_base::Init();
        };
        inline ios_base::fmtflags flags() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__fmtflags_;
        }


        inline ios_base::fmtflags flags(fmtflags __fmtfl) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            fmtflags __r = this->__fmtflags_;
            this->__fmtflags_ = __fmtfl;
            return __r;
        }


        inline ios_base::fmtflags setf(fmtflags __fmtfl) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            fmtflags __r = this->__fmtflags_;
            this->__fmtflags_ |= __fmtfl;
            return __r;
        }


        inline void unsetf(fmtflags __mask) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__fmtflags_ &= ~__mask;
        }


        inline ios_base::fmtflags setf(fmtflags __fmtfl, fmtflags __mask) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            fmtflags __r = this->__fmtflags_;
            this->unsetf(__mask);
            this->__fmtflags_ |= __fmtfl & __mask;
            return __r;
        }


        inline streamsize precision() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__precision_;
        }


        inline streamsize precision(streamsize __prec) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            streamsize __r = this->__precision_;
            this->__precision_ = __prec;
            return __r;
        }


        inline streamsize width() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__width_;
        }


        inline streamsize width(streamsize __wide) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            streamsize __r = this->__width_;
            this->__width_ = __wide;
            return __r;
        }


        inline ios_base::iostate rdstate() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__rdstate_;
        }


        inline void setstate(iostate __state) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->clear(this->__rdstate_ | __state);
        }


        inline bool good() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__rdstate_ == 0;
        }


        inline bool eof() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return (this->__rdstate_ & eofbit) != 0;
        }


        inline bool fail() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return (this->__rdstate_ & (failbit | badbit)) != 0;
        }


        inline bool bad() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return (this->__rdstate_ & badbit) != 0;
        }


        inline ios_base::iostate exceptions() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__exceptions_;
        }


        inline void exceptions(iostate __iostate) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__exceptions_ = __iostate;
            this->clear(this->__rdstate_);
        }


        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_ios : public std::__1::ios_base {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit operator bool() const __attribute__((always_inline));
            bool operator!() const __attribute__((always_inline));
            iostate rdstate() const __attribute__((always_inline));
            void clear(iostate __state) __attribute__((always_inline));
            void setstate(iostate __state) __attribute__((always_inline))             {
                this->ios_base::setstate(__state);
            }


            bool good() const __attribute__((always_inline));
            bool eof() const __attribute__((always_inline));
            bool fail() const __attribute__((always_inline));
            bool bad() const __attribute__((always_inline));
            iostate exceptions() const __attribute__((always_inline));
            void exceptions(iostate __iostate) __attribute__((always_inline));
            explicit basic_ios(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ios<char>() noexcept;
            basic_ostream<char_type, traits_type> *tie() const __attribute__((always_inline));
            basic_ostream<char_type, traits_type> *tie(basic_ostream<char_type, traits_type> *__tiestr) __attribute__((always_inline));
            basic_streambuf<char_type, traits_type> *rdbuf() const __attribute__((always_inline))             {
                return static_cast<basic_streambuf<char_type, traits_type> *>(this->ios_base::rdbuf());
            }


            basic_streambuf<char_type, traits_type> *rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            std::__1::basic_ios<char> &copyfmt(const std::__1::basic_ios<char> &__rhs);
            char_type fill() const __attribute__((always_inline))             {
                if (traits_type::eq_int_type(traits_type::eof(), this->__fill_))
                    this->__fill_ = this->widen(' ');
                return this->__fill_;
            }


            char_type fill(char_type __ch) __attribute__((always_inline));
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((always_inline));
            char narrow(char_type __c, char __dfault) const __attribute__((always_inline));
            char_type widen(char __c) const __attribute__((always_inline))             {
                return use_facet<ctype<char_type> >(this->getloc()).widen(__c);
            }


        protected:
            basic_ios() __attribute__((always_inline));
            void init(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            void move(std::__1::basic_ios<char> &__rhs) __attribute__((always_inline));
            void move(std::__1::basic_ios<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ios<char> &__rhs) noexcept __attribute__((always_inline));
            void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
        private:
            basic_ostream<char_type, traits_type> *__tie_;
            mutable int_type __fill_;
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class __attribute__((type_visibility("default"))) basic_ios : public std::__1::ios_base {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit operator bool() const __attribute__((always_inline));
            bool operator!() const __attribute__((always_inline));
            iostate rdstate() const __attribute__((always_inline));
            void clear(iostate __state) __attribute__((always_inline));
            void setstate(iostate __state) __attribute__((always_inline));
            bool good() const __attribute__((always_inline));
            bool eof() const __attribute__((always_inline));
            bool fail() const __attribute__((always_inline));
            bool bad() const __attribute__((always_inline));
            iostate exceptions() const __attribute__((always_inline));
            void exceptions(iostate __iostate) __attribute__((always_inline));
            explicit basic_ios(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ios<wchar_t>() noexcept;
            basic_ostream<char_type, traits_type> *tie() const __attribute__((always_inline));
            basic_ostream<char_type, traits_type> *tie(basic_ostream<char_type, traits_type> *__tiestr) __attribute__((always_inline));
            basic_streambuf<char_type, traits_type> *rdbuf() const __attribute__((always_inline));
            basic_streambuf<char_type, traits_type> *rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            std::__1::basic_ios<wchar_t> &copyfmt(const std::__1::basic_ios<wchar_t> &__rhs);
            char_type fill() const __attribute__((always_inline));
            char_type fill(char_type __ch) __attribute__((always_inline));
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((always_inline));
            char narrow(char_type __c, char __dfault) const __attribute__((always_inline));
            char_type widen(char __c) const __attribute__((always_inline));
        protected:
            basic_ios() __attribute__((always_inline));
            void init(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            void move(std::__1::basic_ios<wchar_t> &__rhs) __attribute__((always_inline));
            void move(std::__1::basic_ios<wchar_t> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ios<wchar_t> &__rhs) noexcept __attribute__((always_inline));
            void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
        private:
            basic_ostream<char_type, traits_type> *__tie_;
            mutable int_type __fill_;
        }
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ios : public std::__1::ios_base {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit operator bool() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !this->fail();
            }


            bool operator!() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->fail();
            }


            iostate rdstate() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->ios_base::rdstate();
            }


            void clear(iostate __state = goodbit) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->ios_base::clear(__state);
            }


            void setstate(iostate __state) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->ios_base::setstate(__state);
            }


            bool good() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->ios_base::good();
            }


            bool eof() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->ios_base::eof();
            }


            bool fail() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->ios_base::fail();
            }


            bool bad() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->ios_base::bad();
            }


            iostate exceptions() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return ios_base::exceptions();
            }


            void exceptions(iostate __iostate) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                ios_base::exceptions(__iostate);
            }


            explicit basic_ios<_CharT, _Traits>(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            virtual ~basic_ios<_CharT, _Traits>();
            basic_ostream<char_type, traits_type> *tie() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_ostream<char_type, traits_type> *tie(basic_ostream<char_type, traits_type> *__tiestr) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_streambuf<char_type, traits_type> *rdbuf() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_streambuf<char_type, traits_type> *rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs);
            char_type fill() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            char_type fill(char_type __ch) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            char narrow(char_type __c, char __dfault) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            char_type widen(char __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
        protected:
            basic_ios<_CharT, _Traits>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void init(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void move(basic_ios<_CharT, _Traits> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void move(basic_ios<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                move(__rhs);
            }


            void swap(basic_ios<_CharT, _Traits> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")));
        private:
            basic_ostream<char_type, traits_type> *__tie_;
            mutable int_type __fill_;
        };
        inline basic_ios<_CharT, _Traits>(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->init(__sb);
        }


        ~basic_ios<_CharT, _Traits>()         {
        }


        inline void init(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->ios_base::init(__sb);
            this->__tie_ = 0;
            this->__fill_ = traits_type::eof();
        }


        inline basic_ostream<_CharT, _Traits> *tie() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__tie_;
        }


        inline basic_ostream<_CharT, _Traits> *tie(basic_ostream<char_type, traits_type> *__tiestr) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            basic_ostream<char_type, traits_type> *__r = this->__tie_;
            this->__tie_ = __tiestr;
            return __r;
        }


        inline basic_streambuf<_CharT, _Traits> *rdbuf() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<basic_streambuf<char_type, traits_type> *>(ios_base::rdbuf());
        }


        inline basic_streambuf<_CharT, _Traits> *rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            basic_streambuf<char_type, traits_type> *__r = rdbuf();
            ios_base::rdbuf(__sb);
            return __r;
        }


        inline std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::locale __r = this->getloc();
            this->ios_base::imbue(__loc);
            if (rdbuf())
                rdbuf()->pubimbue(__loc);
            return __r;
        }


        inline char narrow(char_type __c, char __dfault) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<char_type> >(this->getloc()).narrow(__c, __dfault);
        }


        inline _CharT widen(char __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return use_facet<ctype<char_type> >(this->getloc()).widen(__c);
        }


        inline _CharT fill() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (traits_type::eq_int_type(traits_type::eof(), this->__fill_))
                this->__fill_ = this->widen(' ');
            return this->__fill_;
        }


        inline _CharT fill(char_type __ch) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            char_type __r = this->__fill_;
            this->__fill_ = __ch;
            return __r;
        }


        basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs)         {
            if (this != &__rhs) {
                this->__call_callbacks(erase_event);
                this->ios_base::copyfmt(__rhs);
                this->__tie_ = __rhs.__tie_;
                this->__fill_ = __rhs.__fill_;
                this->__call_callbacks(copyfmt_event);
                exceptions(__rhs.exceptions());
            }
            return *this;
        }


        inline void move(basic_ios<_CharT, _Traits> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->ios_base::move(__rhs);
            this->__tie_ = __rhs.__tie_;
            __rhs.__tie_ = 0;
            this->__fill_ = __rhs.__fill_;
        }


        inline void swap(basic_ios<_CharT, _Traits> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->ios_base::swap(__rhs);
            std::__1::swap(this->__tie_, __rhs.__tie_);
            std::__1::swap(this->__fill_, __rhs.__fill_);
        }


        inline void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->ios_base::set_rdbuf(__sb);
        }


        inline std::__1::ios_base &boolalpha(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::boolalpha);
            return __str;
        }


        inline std::__1::ios_base &noboolalpha(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.unsetf(ios_base::boolalpha);
            return __str;
        }


        inline std::__1::ios_base &showbase(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::showbase);
            return __str;
        }


        inline std::__1::ios_base &noshowbase(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.unsetf(ios_base::showbase);
            return __str;
        }


        inline std::__1::ios_base &showpoint(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::showpoint);
            return __str;
        }


        inline std::__1::ios_base &noshowpoint(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.unsetf(ios_base::showpoint);
            return __str;
        }


        inline std::__1::ios_base &showpos(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::showpos);
            return __str;
        }


        inline std::__1::ios_base &noshowpos(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.unsetf(ios_base::showpos);
            return __str;
        }


        inline std::__1::ios_base &skipws(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::skipws);
            return __str;
        }


        inline std::__1::ios_base &noskipws(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.unsetf(ios_base::skipws);
            return __str;
        }


        inline std::__1::ios_base &uppercase(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::uppercase);
            return __str;
        }


        inline std::__1::ios_base &nouppercase(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.unsetf(ios_base::uppercase);
            return __str;
        }


        inline std::__1::ios_base &unitbuf(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::unitbuf);
            return __str;
        }


        inline std::__1::ios_base &nounitbuf(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.unsetf(ios_base::unitbuf);
            return __str;
        }


        inline std::__1::ios_base &internal(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::internal, ios_base::adjustfield);
            return __str;
        }


        inline std::__1::ios_base &left(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::left, ios_base::adjustfield);
            return __str;
        }


        inline std::__1::ios_base &right(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::right, ios_base::adjustfield);
            return __str;
        }


        inline std::__1::ios_base &dec(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::dec, ios_base::basefield);
            return __str;
        }


        inline std::__1::ios_base &hex(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::hex, ios_base::basefield);
            return __str;
        }


        inline std::__1::ios_base &oct(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::oct, ios_base::basefield);
            return __str;
        }


        inline std::__1::ios_base &fixed(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::fixed, ios_base::floatfield);
            return __str;
        }


        inline std::__1::ios_base &scientific(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::scientific, ios_base::floatfield);
            return __str;
        }


        inline std::__1::ios_base &hexfloat(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
            return __str;
        }


        inline std::__1::ios_base &defaultfloat(std::__1::ios_base &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __str.unsetf(ios_base::floatfield);
            return __str;
        }


        template <class _CharT, class _Traits> class __save_flags {
            typedef basic_ios<_CharT, _Traits> __stream_type;
            typedef typename __stream_type::fmtflags fmtflags;
            __stream_type &__stream_;
            fmtflags __fmtflags_;
            _CharT __fill_;
            __save_flags<_CharT, _Traits>(const __save_flags<_CharT, _Traits> &);
            __save_flags<_CharT, _Traits> &operator=(const __save_flags<_CharT, _Traits> &);
        public:
            explicit __save_flags<_CharT, _Traits>(__stream_type &__stream) : __stream_(__stream), __fmtflags_(__stream.flags()), __fill_(__stream.fill()) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            ~__save_flags<_CharT, _Traits>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->__stream_.flags(this->__fmtflags_);
                this->__stream_.fill(this->__fill_);
            }


        };
    }
}
namespace std {
    inline namespace __1 {
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_streambuf {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            virtual ~std::__1::basic_streambuf<char>();
            std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((always_inline));
            std::__1::locale getloc() const __attribute__((always_inline));
            std::__1::basic_streambuf<char> *pubsetbuf(char_type *__s, streamsize __n) __attribute__((always_inline));
            pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which) __attribute__((always_inline));
            pos_type pubseekpos(pos_type __sp, ios_base::openmode __which) __attribute__((always_inline));
            int pubsync() __attribute__((always_inline));
            streamsize in_avail() __attribute__((always_inline));
            int_type snextc() __attribute__((always_inline));
            int_type sbumpc() __attribute__((always_inline));
            int_type sgetc() __attribute__((always_inline));
            streamsize sgetn(char_type *__s, streamsize __n) __attribute__((always_inline));
            int_type sputbackc(char_type __c) __attribute__((always_inline));
            int_type sungetc() __attribute__((always_inline));
            int_type sputc(char_type __c) __attribute__((always_inline));
            streamsize sputn(const char_type *__s, streamsize __n) __attribute__((always_inline))             {
                return this->xsputn(__s, __n);
            }


        protected:
            basic_streambuf();
            basic_streambuf(const std::__1::basic_streambuf<char> &__rhs);
            std::__1::basic_streambuf<char> &operator=(const std::__1::basic_streambuf<char> &__rhs);
            void swap(std::__1::basic_streambuf<char> &__rhs);
            char_type *eback() const __attribute__((always_inline));
            char_type *gptr() const __attribute__((always_inline));
            char_type *egptr() const __attribute__((always_inline));
            void gbump(int __n) __attribute__((always_inline));
            void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) __attribute__((always_inline));
            char_type *pbase() const __attribute__((always_inline));
            char_type *pptr() const __attribute__((always_inline));
            char_type *epptr() const __attribute__((always_inline));
            void pbump(int __n) __attribute__((always_inline));
            void setp(char_type *__pbeg, char_type *__pend) __attribute__((always_inline));
            virtual void imbue(const std::__1::locale &__loc);
            virtual std::__1::basic_streambuf<char> *setbuf(char_type *__s, streamsize __n);
            virtual pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which);
            virtual pos_type seekpos(pos_type __sp, ios_base::openmode __which);
            virtual int sync();
            virtual streamsize showmanyc();
            virtual streamsize xsgetn(char_type *__s, streamsize __n);
            virtual int_type underflow();
            virtual int_type uflow();
            virtual int_type pbackfail(int_type __c);
            virtual streamsize xsputn(const char_type *__s, streamsize __n);
            virtual int_type overflow(int_type __c);
        private:
            std::__1::locale __loc_;
            char_type *__binp_;
            char_type *__ninp_;
            char_type *__einp_;
            char_type *__bout_;
            char_type *__nout_;
            char_type *__eout_;
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class __attribute__((type_visibility("default"))) basic_streambuf {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            virtual ~std::__1::basic_streambuf<wchar_t>();
            std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((always_inline));
            std::__1::locale getloc() const __attribute__((always_inline));
            std::__1::basic_streambuf<wchar_t> *pubsetbuf(char_type *__s, streamsize __n) __attribute__((always_inline));
            pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which) __attribute__((always_inline));
            pos_type pubseekpos(pos_type __sp, ios_base::openmode __which) __attribute__((always_inline));
            int pubsync() __attribute__((always_inline));
            streamsize in_avail() __attribute__((always_inline));
            int_type snextc() __attribute__((always_inline));
            int_type sbumpc() __attribute__((always_inline));
            int_type sgetc() __attribute__((always_inline));
            streamsize sgetn(char_type *__s, streamsize __n) __attribute__((always_inline));
            int_type sputbackc(char_type __c) __attribute__((always_inline));
            int_type sungetc() __attribute__((always_inline));
            int_type sputc(char_type __c) __attribute__((always_inline));
            streamsize sputn(const char_type *__s, streamsize __n) __attribute__((always_inline));
        protected:
            basic_streambuf();
            basic_streambuf(const std::__1::basic_streambuf<wchar_t> &__rhs);
            std::__1::basic_streambuf<wchar_t> &operator=(const std::__1::basic_streambuf<wchar_t> &__rhs);
            void swap(std::__1::basic_streambuf<wchar_t> &__rhs);
            char_type *eback() const __attribute__((always_inline));
            char_type *gptr() const __attribute__((always_inline));
            char_type *egptr() const __attribute__((always_inline));
            void gbump(int __n) __attribute__((always_inline));
            void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) __attribute__((always_inline));
            char_type *pbase() const __attribute__((always_inline));
            char_type *pptr() const __attribute__((always_inline));
            char_type *epptr() const __attribute__((always_inline));
            void pbump(int __n) __attribute__((always_inline));
            void setp(char_type *__pbeg, char_type *__pend) __attribute__((always_inline));
            virtual void imbue(const std::__1::locale &__loc);
            virtual std::__1::basic_streambuf<wchar_t> *setbuf(char_type *__s, streamsize __n);
            virtual pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which);
            virtual pos_type seekpos(pos_type __sp, ios_base::openmode __which);
            virtual int sync();
            virtual streamsize showmanyc();
            virtual streamsize xsgetn(char_type *__s, streamsize __n);
            virtual int_type underflow();
            virtual int_type uflow();
            virtual int_type pbackfail(int_type __c);
            virtual streamsize xsputn(const char_type *__s, streamsize __n);
            virtual int_type overflow(int_type __c);
        private:
            std::__1::locale __loc_;
            char_type *__binp_;
            char_type *__ninp_;
            char_type *__einp_;
            char_type *__bout_;
            char_type *__nout_;
            char_type *__eout_;
        }
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_streambuf {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            virtual ~basic_streambuf<_CharT, _Traits>();
            std::__1::locale pubimbue(const std::__1::locale &__loc);
            std::__1::locale getloc() const;
            basic_streambuf<_CharT, _Traits> *pubsetbuf(char_type *__s, streamsize __n);
            pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out);
            pos_type pubseekpos(pos_type __sp, ios_base::openmode __which = ios_base::in | ios_base::out);
            int pubsync();
            streamsize in_avail();
            int_type snextc();
            int_type sbumpc();
            int_type sgetc();
            streamsize sgetn(char_type *__s, streamsize __n);
            int_type sputbackc(char_type __c);
            int_type sungetc();
            int_type sputc(char_type __c);
            streamsize sputn(const char_type *__s, streamsize __n);
        protected:
            basic_streambuf<_CharT, _Traits>();
            basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &__rhs);
            basic_streambuf<_CharT, _Traits> &operator=(const basic_streambuf<_CharT, _Traits> &__rhs);
            void swap(basic_streambuf<_CharT, _Traits> &__rhs);
            char_type *eback() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__binp_;
            }


            char_type *gptr() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ninp_;
            }


            char_type *egptr() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__einp_;
            }


            void gbump(int __n);
            void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend);
            char_type *pbase() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__bout_;
            }


            char_type *pptr() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__nout_;
            }


            char_type *epptr() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__eout_;
            }


            void pbump(int __n);
            void setp(char_type *__pbeg, char_type *__pend);
            virtual void imbue(const std::__1::locale &__loc);
            virtual basic_streambuf<_CharT, _Traits> *setbuf(char_type *__s, streamsize __n);
            virtual pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out);
            virtual pos_type seekpos(pos_type __sp, ios_base::openmode __which = ios_base::in | ios_base::out);
            virtual int sync();
            virtual streamsize showmanyc();
            virtual streamsize xsgetn(char_type *__s, streamsize __n);
            virtual int_type underflow();
            virtual int_type uflow();
            virtual int_type pbackfail(int_type __c = traits_type::eof());
            virtual streamsize xsputn(const char_type *__s, streamsize __n);
            virtual int_type overflow(int_type __c = traits_type::eof());
        private:
            std::__1::locale __loc_;
            char_type *__binp_;
            char_type *__ninp_;
            char_type *__einp_;
            char_type *__bout_;
            char_type *__nout_;
            char_type *__eout_;
        };
        ~basic_streambuf<_CharT, _Traits>()         {
        }


        inline std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->imbue(__loc);
            std::__1::locale __r = this->__loc_;
            this->__loc_ = __loc;
            return __r;
        }


        inline std::__1::locale getloc() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__loc_;
        }


        inline basic_streambuf<_CharT, _Traits> *pubsetbuf(char_type *__s, streamsize __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->setbuf(__s, __n);
        }


        inline typename basic_streambuf<_CharT, _Traits>::pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->seekoff(__off, __way, __which);
        }


        inline typename basic_streambuf<_CharT, _Traits>::pos_type pubseekpos(pos_type __sp, ios_base::openmode __which = ios_base::in | ios_base::out) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->seekpos(__sp, __which);
        }


        inline int pubsync() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->sync();
        }


        inline streamsize in_avail() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__ninp_ < this->__einp_)
                return static_cast<streamsize>(this->__einp_ - this->__ninp_);
            return this->showmanyc();
        }


        inline typename basic_streambuf<_CharT, _Traits>::int_type snextc() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->sbumpc() == traits_type::eof())
                return traits_type::eof();
            return this->sgetc();
        }


        inline typename basic_streambuf<_CharT, _Traits>::int_type sbumpc() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__ninp_ == this->__einp_)
                return this->uflow();
            return traits_type::to_int_type(*this->__ninp_++);
        }


        inline typename basic_streambuf<_CharT, _Traits>::int_type sgetc() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__ninp_ == this->__einp_)
                return this->underflow();
            return traits_type::to_int_type(*this->__ninp_);
        }


        inline streamsize sgetn(char_type *__s, streamsize __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->xsgetn(__s, __n);
        }


        inline typename basic_streambuf<_CharT, _Traits>::int_type sputbackc(char_type __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__binp_ == this->__ninp_ || !traits_type::eq(__c, this->__ninp_[-1]))
                return this->pbackfail(traits_type::to_int_type(__c));
            return traits_type::to_int_type(*--this->__ninp_);
        }


        inline typename basic_streambuf<_CharT, _Traits>::int_type sungetc() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__binp_ == this->__ninp_)
                return this->pbackfail();
            return traits_type::to_int_type(*--this->__ninp_);
        }


        inline typename basic_streambuf<_CharT, _Traits>::int_type sputc(char_type __c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->__nout_ == this->__eout_)
                return this->overflow(traits_type::to_int_type(__c));
            *this->__nout_++ = __c;
            return traits_type::to_int_type(__c);
        }


        inline streamsize sputn(const char_type *__s, streamsize __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->xsputn(__s, __n);
        }


        basic_streambuf<_CharT, _Traits>() : __binp_(0), __ninp_(0), __einp_(0), __bout_(0), __nout_(0), __eout_(0)         {
        }


        basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &__sb) : __loc_(__sb.__loc_), __binp_(__sb.__binp_), __ninp_(__sb.__ninp_), __einp_(__sb.__einp_), __bout_(__sb.__bout_), __nout_(__sb.__nout_), __eout_(__sb.__eout_)         {
        }


        basic_streambuf<_CharT, _Traits> &operator=(const basic_streambuf<_CharT, _Traits> &__sb)         {
            this->__loc_ = __sb.__loc_;
            this->__binp_ = __sb.__binp_;
            this->__ninp_ = __sb.__ninp_;
            this->__einp_ = __sb.__einp_;
            this->__bout_ = __sb.__bout_;
            this->__nout_ = __sb.__nout_;
            this->__eout_ = __sb.__eout_;
            return *this;
        }


        void swap(basic_streambuf<_CharT, _Traits> &__sb)         {
            std::__1::swap(this->__loc_, __sb.__loc_);
            std::__1::swap(this->__binp_, __sb.__binp_);
            std::__1::swap(this->__ninp_, __sb.__ninp_);
            std::__1::swap(this->__einp_, __sb.__einp_);
            std::__1::swap(this->__bout_, __sb.__bout_);
            std::__1::swap(this->__nout_, __sb.__nout_);
            std::__1::swap(this->__eout_, __sb.__eout_);
        }


        inline void gbump(int __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__ninp_ += __n;
        }


        inline void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__binp_ = __gbeg;
            this->__ninp_ = __gnext;
            this->__einp_ = __gend;
        }


        inline void pbump(int __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__nout_ += __n;
        }


        inline void setp(char_type *__pbeg, char_type *__pend) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__bout_ = this->__nout_ = __pbeg;
            this->__eout_ = __pend;
        }


        void imbue(const std::__1::locale &)         {
        }


        basic_streambuf<_CharT, _Traits> *setbuf(char_type *, streamsize)         {
            return this;
        }


        typename basic_streambuf<_CharT, _Traits>::pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out)         {
            return pos_type(off_type(-1));
        }


        typename basic_streambuf<_CharT, _Traits>::pos_type seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out)         {
            return pos_type(off_type(-1));
        }


        int sync()         {
            return 0;
        }


        streamsize showmanyc()         {
            return 0;
        }


        streamsize xsgetn(char_type *__s, streamsize __n)         {
            const int_type __eof = traits_type::eof();
            int_type __c;
            streamsize __i = 0;
            for (; __i < __n; ++__i , ++__s) {
                if (this->__ninp_ < this->__einp_)
                    *__s = *this->__ninp_++;
                else if ((__c = this->uflow()) != __eof)
                    *__s = traits_type::to_char_type(__c);
                else
                    break;
            }
            return __i;
        }


        typename basic_streambuf<_CharT, _Traits>::int_type underflow()         {
            return traits_type::eof();
        }


        typename basic_streambuf<_CharT, _Traits>::int_type uflow()         {
            if (this->underflow() == traits_type::eof())
                return traits_type::eof();
            return traits_type::to_int_type(*this->__ninp_++);
        }


        typename basic_streambuf<_CharT, _Traits>::int_type pbackfail(int_type = traits_type::eof())         {
            return traits_type::eof();
        }


        streamsize xsputn(const char_type *__s, streamsize __n)         {
            streamsize __i = 0;
            int_type __eof = traits_type::eof();
            while (__i < __n)
                {
                    if (this->__nout_ >= this->__eout_) {
                        if (this->overflow(traits_type::to_int_type(*__s)) == __eof)
                            break;
                        ++__s;
                        ++__i;
                    } else {
                        streamsize __chunk_size = std::__1::min(this->__eout_ - this->__nout_, __n - __i);
                        traits_type::copy(this->__nout_, __s, __chunk_size);
                        this->__nout_ += __chunk_size;
                        __s += __chunk_size;
                        __i += __chunk_size;
                    }
                }
            return __i;
        }


        typename basic_streambuf<_CharT, _Traits>::int_type overflow(int_type = traits_type::eof())         {
            return traits_type::eof();
        }


        class __attribute__((type_visibility("default"))) basic_streambuf {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            virtual ~std::__1::basic_streambuf<char>();
            std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((always_inline));
            std::__1::locale getloc() const __attribute__((always_inline));
            std::__1::basic_streambuf<char> *pubsetbuf(char_type *__s, streamsize __n) __attribute__((always_inline));
            pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which) __attribute__((always_inline));
            pos_type pubseekpos(pos_type __sp, ios_base::openmode __which) __attribute__((always_inline));
            int pubsync() __attribute__((always_inline));
            streamsize in_avail() __attribute__((always_inline));
            int_type snextc() __attribute__((always_inline));
            int_type sbumpc() __attribute__((always_inline));
            int_type sgetc() __attribute__((always_inline));
            streamsize sgetn(char_type *__s, streamsize __n) __attribute__((always_inline));
            int_type sputbackc(char_type __c) __attribute__((always_inline));
            int_type sungetc() __attribute__((always_inline));
            int_type sputc(char_type __c) __attribute__((always_inline));
            streamsize sputn(const char_type *__s, streamsize __n) __attribute__((always_inline))             {
                return this->xsputn(__s, __n);
            }


        protected:
            basic_streambuf();
            basic_streambuf(const std::__1::basic_streambuf<char> &__rhs);
            std::__1::basic_streambuf<char> &operator=(const std::__1::basic_streambuf<char> &__rhs);
            void swap(std::__1::basic_streambuf<char> &__rhs);
            char_type *eback() const __attribute__((always_inline));
            char_type *gptr() const __attribute__((always_inline));
            char_type *egptr() const __attribute__((always_inline));
            void gbump(int __n) __attribute__((always_inline));
            void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) __attribute__((always_inline));
            char_type *pbase() const __attribute__((always_inline));
            char_type *pptr() const __attribute__((always_inline));
            char_type *epptr() const __attribute__((always_inline));
            void pbump(int __n) __attribute__((always_inline));
            void setp(char_type *__pbeg, char_type *__pend) __attribute__((always_inline));
            virtual void imbue(const std::__1::locale &__loc);
            virtual std::__1::basic_streambuf<char> *setbuf(char_type *__s, streamsize __n);
            virtual pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which);
            virtual pos_type seekpos(pos_type __sp, ios_base::openmode __which);
            virtual int sync();
            virtual streamsize showmanyc();
            virtual streamsize xsgetn(char_type *__s, streamsize __n);
            virtual int_type underflow();
            virtual int_type uflow();
            virtual int_type pbackfail(int_type __c);
            virtual streamsize xsputn(const char_type *__s, streamsize __n);
            virtual int_type overflow(int_type __c);
        private:
            std::__1::locale __loc_;
            char_type *__binp_;
            char_type *__ninp_;
            char_type *__einp_;
            char_type *__bout_;
            char_type *__nout_;
            char_type *__eout_;
        };
        class __attribute__((type_visibility("default"))) basic_streambuf {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            virtual ~std::__1::basic_streambuf<wchar_t>();
            std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((always_inline));
            std::__1::locale getloc() const __attribute__((always_inline));
            std::__1::basic_streambuf<wchar_t> *pubsetbuf(char_type *__s, streamsize __n) __attribute__((always_inline));
            pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which) __attribute__((always_inline));
            pos_type pubseekpos(pos_type __sp, ios_base::openmode __which) __attribute__((always_inline));
            int pubsync() __attribute__((always_inline));
            streamsize in_avail() __attribute__((always_inline));
            int_type snextc() __attribute__((always_inline));
            int_type sbumpc() __attribute__((always_inline));
            int_type sgetc() __attribute__((always_inline));
            streamsize sgetn(char_type *__s, streamsize __n) __attribute__((always_inline));
            int_type sputbackc(char_type __c) __attribute__((always_inline));
            int_type sungetc() __attribute__((always_inline));
            int_type sputc(char_type __c) __attribute__((always_inline));
            streamsize sputn(const char_type *__s, streamsize __n) __attribute__((always_inline));
        protected:
            basic_streambuf();
            basic_streambuf(const std::__1::basic_streambuf<wchar_t> &__rhs);
            std::__1::basic_streambuf<wchar_t> &operator=(const std::__1::basic_streambuf<wchar_t> &__rhs);
            void swap(std::__1::basic_streambuf<wchar_t> &__rhs);
            char_type *eback() const __attribute__((always_inline));
            char_type *gptr() const __attribute__((always_inline));
            char_type *egptr() const __attribute__((always_inline));
            void gbump(int __n) __attribute__((always_inline));
            void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) __attribute__((always_inline));
            char_type *pbase() const __attribute__((always_inline));
            char_type *pptr() const __attribute__((always_inline));
            char_type *epptr() const __attribute__((always_inline));
            void pbump(int __n) __attribute__((always_inline));
            void setp(char_type *__pbeg, char_type *__pend) __attribute__((always_inline));
            virtual void imbue(const std::__1::locale &__loc);
            virtual std::__1::basic_streambuf<wchar_t> *setbuf(char_type *__s, streamsize __n);
            virtual pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which);
            virtual pos_type seekpos(pos_type __sp, ios_base::openmode __which);
            virtual int sync();
            virtual streamsize showmanyc();
            virtual streamsize xsgetn(char_type *__s, streamsize __n);
            virtual int_type underflow();
            virtual int_type uflow();
            virtual int_type pbackfail(int_type __c);
            virtual streamsize xsputn(const char_type *__s, streamsize __n);
            virtual int_type overflow(int_type __c);
        private:
            std::__1::locale __loc_;
            char_type *__binp_;
            char_type *__ninp_;
            char_type *__einp_;
            char_type *__bout_;
            char_type *__nout_;
            char_type *__eout_;
        };
        class __attribute__((type_visibility("default"))) basic_ios : public std::__1::ios_base {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit operator bool() const __attribute__((always_inline));
            bool operator!() const __attribute__((always_inline));
            iostate rdstate() const __attribute__((always_inline));
            void clear(iostate __state) __attribute__((always_inline));
            void setstate(iostate __state) __attribute__((always_inline))             {
                this->ios_base::setstate(__state);
            }


            bool good() const __attribute__((always_inline));
            bool eof() const __attribute__((always_inline));
            bool fail() const __attribute__((always_inline));
            bool bad() const __attribute__((always_inline));
            iostate exceptions() const __attribute__((always_inline));
            void exceptions(iostate __iostate) __attribute__((always_inline));
            explicit basic_ios(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ios<char>() noexcept;
            basic_ostream<char_type, traits_type> *tie() const __attribute__((always_inline));
            basic_ostream<char_type, traits_type> *tie(basic_ostream<char_type, traits_type> *__tiestr) __attribute__((always_inline));
            basic_streambuf<char_type, traits_type> *rdbuf() const __attribute__((always_inline))             {
                return static_cast<basic_streambuf<char_type, traits_type> *>(this->ios_base::rdbuf());
            }


            basic_streambuf<char_type, traits_type> *rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            std::__1::basic_ios<char> &copyfmt(const std::__1::basic_ios<char> &__rhs);
            char_type fill() const __attribute__((always_inline))             {
                if (traits_type::eq_int_type(traits_type::eof(), this->__fill_))
                    this->__fill_ = this->widen(' ');
                return this->__fill_;
            }


            char_type fill(char_type __ch) __attribute__((always_inline));
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((always_inline));
            char narrow(char_type __c, char __dfault) const __attribute__((always_inline));
            char_type widen(char __c) const __attribute__((always_inline))             {
                return use_facet<ctype<char_type> >(this->getloc()).widen(__c);
            }


        protected:
            basic_ios() __attribute__((always_inline));
            void init(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            void move(std::__1::basic_ios<char> &__rhs) __attribute__((always_inline));
            void move(std::__1::basic_ios<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ios<char> &__rhs) noexcept __attribute__((always_inline));
            void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
        private:
            basic_ostream<char_type, traits_type> *__tie_;
            mutable int_type __fill_;
        };
        class __attribute__((type_visibility("default"))) basic_ios : public std::__1::ios_base {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit operator bool() const __attribute__((always_inline));
            bool operator!() const __attribute__((always_inline));
            iostate rdstate() const __attribute__((always_inline));
            void clear(iostate __state) __attribute__((always_inline));
            void setstate(iostate __state) __attribute__((always_inline));
            bool good() const __attribute__((always_inline));
            bool eof() const __attribute__((always_inline));
            bool fail() const __attribute__((always_inline));
            bool bad() const __attribute__((always_inline));
            iostate exceptions() const __attribute__((always_inline));
            void exceptions(iostate __iostate) __attribute__((always_inline));
            explicit basic_ios(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ios<wchar_t>() noexcept;
            basic_ostream<char_type, traits_type> *tie() const __attribute__((always_inline));
            basic_ostream<char_type, traits_type> *tie(basic_ostream<char_type, traits_type> *__tiestr) __attribute__((always_inline));
            basic_streambuf<char_type, traits_type> *rdbuf() const __attribute__((always_inline));
            basic_streambuf<char_type, traits_type> *rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            std::__1::basic_ios<wchar_t> &copyfmt(const std::__1::basic_ios<wchar_t> &__rhs);
            char_type fill() const __attribute__((always_inline));
            char_type fill(char_type __ch) __attribute__((always_inline));
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((always_inline));
            char narrow(char_type __c, char __dfault) const __attribute__((always_inline));
            char_type widen(char __c) const __attribute__((always_inline));
        protected:
            basic_ios() __attribute__((always_inline));
            void init(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            void move(std::__1::basic_ios<wchar_t> &__rhs) __attribute__((always_inline));
            void move(std::__1::basic_ios<wchar_t> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ios<wchar_t> &__rhs) noexcept __attribute__((always_inline));
            void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
        private:
            basic_ostream<char_type, traits_type> *__tie_;
            mutable int_type __fill_;
        };
    }
}
enum  {
    P_ALL,
    P_PID,
    P_PGID
} typedef idtype_t;
typedef __darwin_pid_t pid_t;
typedef __darwin_id_t id_t;
typedef int sig_atomic_t;
struct __darwin_i386_thread_state {
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
struct __darwin_fp_control {
    unsigned short __invalid : 1;
    unsigned short __denorm : 1;
    unsigned short __zdiv : 1;
    unsigned short __ovrfl : 1;
    unsigned short __undfl : 1;
    unsigned short __precis : 1;
    unsigned short : 2;
    unsigned short __pc : 2;
    unsigned short __rc : 2;
    unsigned short : 1;
    unsigned short : 3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
struct __darwin_fp_status {
    unsigned short __invalid : 1;
    unsigned short __denorm : 1;
    unsigned short __zdiv : 1;
    unsigned short __ovrfl : 1;
    unsigned short __undfl : 1;
    unsigned short __precis : 1;
    unsigned short __stkflt : 1;
    unsigned short __errsumm : 1;
    unsigned short __c0 : 1;
    unsigned short __c1 : 1;
    unsigned short __c2 : 1;
    unsigned short __tos : 3;
    unsigned short __c3 : 1;
    unsigned short __busy : 1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
struct __darwin_mmst_reg {
    char __mmst_reg[10];
    char __mmst_rsrv[6];
};
struct __darwin_xmm_reg {
    char __xmm_reg[16];
};
struct __darwin_i386_float_state {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    char __fpu_rsrv4[224];
    int __fpu_reserved1;
};
struct __darwin_i386_avx_state {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    char __fpu_rsrv4[224];
    int __fpu_reserved1;
    char __avx_reserved1[64];
    struct __darwin_xmm_reg __fpu_ymmh0;
    struct __darwin_xmm_reg __fpu_ymmh1;
    struct __darwin_xmm_reg __fpu_ymmh2;
    struct __darwin_xmm_reg __fpu_ymmh3;
    struct __darwin_xmm_reg __fpu_ymmh4;
    struct __darwin_xmm_reg __fpu_ymmh5;
    struct __darwin_xmm_reg __fpu_ymmh6;
    struct __darwin_xmm_reg __fpu_ymmh7;
};
struct __darwin_i386_exception_state {
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint32_t __faultvaddr;
};
struct __darwin_x86_debug_state32 {
    unsigned int __dr0;
    unsigned int __dr1;
    unsigned int __dr2;
    unsigned int __dr3;
    unsigned int __dr4;
    unsigned int __dr5;
    unsigned int __dr6;
    unsigned int __dr7;
};
struct __darwin_x86_thread_state64 {
    __uint64_t __rax;
    __uint64_t __rbx;
    __uint64_t __rcx;
    __uint64_t __rdx;
    __uint64_t __rdi;
    __uint64_t __rsi;
    __uint64_t __rbp;
    __uint64_t __rsp;
    __uint64_t __r8;
    __uint64_t __r9;
    __uint64_t __r10;
    __uint64_t __r11;
    __uint64_t __r12;
    __uint64_t __r13;
    __uint64_t __r14;
    __uint64_t __r15;
    __uint64_t __rip;
    __uint64_t __rflags;
    __uint64_t __cs;
    __uint64_t __fs;
    __uint64_t __gs;
};
struct __darwin_x86_float_state64 {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    struct __darwin_xmm_reg __fpu_xmm8;
    struct __darwin_xmm_reg __fpu_xmm9;
    struct __darwin_xmm_reg __fpu_xmm10;
    struct __darwin_xmm_reg __fpu_xmm11;
    struct __darwin_xmm_reg __fpu_xmm12;
    struct __darwin_xmm_reg __fpu_xmm13;
    struct __darwin_xmm_reg __fpu_xmm14;
    struct __darwin_xmm_reg __fpu_xmm15;
    char __fpu_rsrv4[96];
    int __fpu_reserved1;
};
struct __darwin_x86_avx_state64 {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    struct __darwin_xmm_reg __fpu_xmm8;
    struct __darwin_xmm_reg __fpu_xmm9;
    struct __darwin_xmm_reg __fpu_xmm10;
    struct __darwin_xmm_reg __fpu_xmm11;
    struct __darwin_xmm_reg __fpu_xmm12;
    struct __darwin_xmm_reg __fpu_xmm13;
    struct __darwin_xmm_reg __fpu_xmm14;
    struct __darwin_xmm_reg __fpu_xmm15;
    char __fpu_rsrv4[96];
    int __fpu_reserved1;
    char __avx_reserved1[64];
    struct __darwin_xmm_reg __fpu_ymmh0;
    struct __darwin_xmm_reg __fpu_ymmh1;
    struct __darwin_xmm_reg __fpu_ymmh2;
    struct __darwin_xmm_reg __fpu_ymmh3;
    struct __darwin_xmm_reg __fpu_ymmh4;
    struct __darwin_xmm_reg __fpu_ymmh5;
    struct __darwin_xmm_reg __fpu_ymmh6;
    struct __darwin_xmm_reg __fpu_ymmh7;
    struct __darwin_xmm_reg __fpu_ymmh8;
    struct __darwin_xmm_reg __fpu_ymmh9;
    struct __darwin_xmm_reg __fpu_ymmh10;
    struct __darwin_xmm_reg __fpu_ymmh11;
    struct __darwin_xmm_reg __fpu_ymmh12;
    struct __darwin_xmm_reg __fpu_ymmh13;
    struct __darwin_xmm_reg __fpu_ymmh14;
    struct __darwin_xmm_reg __fpu_ymmh15;
};
struct __darwin_x86_exception_state64 {
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
struct __darwin_x86_debug_state64 {
    __uint64_t __dr0;
    __uint64_t __dr1;
    __uint64_t __dr2;
    __uint64_t __dr3;
    __uint64_t __dr4;
    __uint64_t __dr5;
    __uint64_t __dr6;
    __uint64_t __dr7;
};
struct __darwin_mcontext32 {
    struct __darwin_i386_exception_state __es;
    struct __darwin_i386_thread_state __ss;
    struct __darwin_i386_float_state __fs;
};
struct __darwin_mcontext_avx32 {
    struct __darwin_i386_exception_state __es;
    struct __darwin_i386_thread_state __ss;
    struct __darwin_i386_avx_state __fs;
};
struct __darwin_mcontext64 {
    struct __darwin_x86_exception_state64 __es;
    struct __darwin_x86_thread_state64 __ss;
    struct __darwin_x86_float_state64 __fs;
};
struct __darwin_mcontext_avx64 {
    struct __darwin_x86_exception_state64 __es;
    struct __darwin_x86_thread_state64 __ss;
    struct __darwin_x86_avx_state64 __fs;
};
typedef struct __darwin_mcontext64 *mcontext_t;
struct __darwin_sigaltstack {
    void *ss_sp;
    __darwin_size_t ss_size;
    int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
struct __darwin_ucontext {
    int uc_onstack;
    __darwin_sigset_t uc_sigmask;
    struct __darwin_sigaltstack uc_stack;
    struct __darwin_ucontext *uc_link;
    __darwin_size_t uc_mcsize;
    struct __darwin_mcontext64 *uc_mcontext;
};
typedef struct __darwin_ucontext ucontext_t;
typedef __darwin_uid_t uid_t;
union sigval {
    int sival_int;
    void *sival_ptr;
};
struct sigevent {
    int sigev_notify;
    int sigev_signo;
    union sigval sigev_value;
    void (*sigev_notify_function)(union sigval);
    pthread_attr_t *sigev_notify_attributes;
};
struct __siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    pid_t si_pid;
    uid_t si_uid;
    int si_status;
    void *si_addr;
    union sigval si_value;
    long si_band;
    unsigned long __pad[7];
};
typedef struct __siginfo siginfo_t;
union __sigaction_u {
    void (*__sa_handler)(int);
    void (*__sa_sigaction)(int, struct __siginfo *, void *);
};
struct __sigaction {
    union __sigaction_u __sigaction_u;
    void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
};
struct sigaction {
    union __sigaction_u __sigaction_u;
    sigset_t sa_mask;
    int sa_flags;
};
typedef void (*sig_t)(int);
struct sigvec {
    void (*sv_handler)(int);
    int sv_mask;
    int sv_flags;
};
struct sigstack {
    char *ss_sp;
    int ss_onstack;
};
extern "C" {
    void (*signal(int, void (*)(int)))(int);
}
struct timeval {
    __darwin_time_t tv_sec;
    __darwin_suseconds_t tv_usec;
};
typedef __uint64_t rlim_t;
struct rusage {
    struct timeval ru_utime;
    struct timeval ru_stime;
    long ru_maxrss;
    long ru_ixrss;
    long ru_idrss;
    long ru_isrss;
    long ru_minflt;
    long ru_majflt;
    long ru_nswap;
    long ru_inblock;
    long ru_oublock;
    long ru_msgsnd;
    long ru_msgrcv;
    long ru_nsignals;
    long ru_nvcsw;
    long ru_nivcsw;
};
typedef void *rusage_info_t;
struct rusage_info_v0 {
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
};
struct rusage_info_v1 {
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
};
struct rusage_info_v2 {
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
};
struct rusage_info_v3 {
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
    uint64_t ri_cpu_time_qos_default;
    uint64_t ri_cpu_time_qos_maintenance;
    uint64_t ri_cpu_time_qos_background;
    uint64_t ri_cpu_time_qos_utility;
    uint64_t ri_cpu_time_qos_legacy;
    uint64_t ri_cpu_time_qos_user_initiated;
    uint64_t ri_cpu_time_qos_user_interactive;
    uint64_t ri_billed_system_time;
    uint64_t ri_serviced_system_time;
};
typedef struct rusage_info_v3 rusage_info_current;
struct rlimit {
    rlim_t rlim_cur;
    rlim_t rlim_max;
};
struct proc_rlimit_control_wakeupmon {
    uint32_t wm_flags;
    int32_t wm_rate;
};
extern "C" {
    int getpriority(int, id_t);
    int getiopolicy_np(int, int) __attribute__((availability(macos, introduced=10.5)));
    int getrlimit(int, struct rlimit *) asm("_getrlimit");
    int getrusage(int, struct rusage *);
    int setpriority(int, id_t, int);
    int setiopolicy_np(int, int, int) __attribute__((availability(macos, introduced=10.5)));
    int setrlimit(int, const struct rlimit *) asm("_setrlimit");
}
static inline __uint16_t _OSSwapInt16(__uint16_t _data) {
    return ((__uint16_t)((_data << 8) | (_data >> 8)));
}


static inline __uint32_t _OSSwapInt32(__uint32_t _data) {
    return __builtin_bswap32(_data);
}


static inline __uint64_t _OSSwapInt64(__uint64_t _data) {
    return __builtin_bswap64(_data);
}


union wait {
    int w_status;
    struct {
        unsigned int w_Termsig : 7;
        unsigned int w_Coredump : 1;
        unsigned int w_Retcode : 8;
        unsigned int w_Filler : 16;
    } w_T;
    struct {
        unsigned int w_Stopval : 8;
        unsigned int w_Stopsig : 8;
        unsigned int w_Filler : 16;
    } w_S;
};
extern "C" {
    pid_t wait(int *) asm("_wait");
    pid_t waitpid(pid_t, int *, int) asm("_waitpid");
    int waitid(idtype_t, id_t, siginfo_t *, int) asm("_waitid");
    pid_t wait3(int *, int, struct rusage *);
    pid_t wait4(pid_t, int *, int, struct rusage *);
}
extern "C" {
    void *alloca(size_t);
}
struct {
    int quot;
    int rem;
} typedef div_t;
struct {
    long quot;
    long rem;
} typedef ldiv_t;
struct {
    long long quot;
    long long rem;
} typedef lldiv_t;
extern "C" {
    void abort();
    int abs(int) __attribute__((const)) __attribute__((nothrow));
    int atexit(void (*)());
    double atof(const char *);
    int atoi(const char *);
    long atol(const char *);
    long long atoll(const char *);
    void *bsearch(const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
    void *calloc(size_t, size_t);
    div_t div(int, int) __attribute__((const));
    void exit(int);
    void free(void *);
    char *getenv(const char *);
    long labs(long) __attribute__((const)) __attribute__((nothrow));
    ldiv_t ldiv(long, long) __attribute__((const));
    long long llabs(long long) __attribute__((nothrow)) __attribute__((const));
    lldiv_t lldiv(long long, long long);
    void *malloc(size_t);
    int mblen(const char *, size_t);
    size_t mbstowcs(wchar_t *, const char *, size_t);
    int mbtowc(wchar_t *, const char *, size_t);
    int posix_memalign(void **, size_t, size_t) __attribute__((availability(macos, introduced=10.6)));
    void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
    int rand();
    void *realloc(void *, size_t);
    void srand(unsigned int);
    double strtod(const char *, char **) asm("_strtod");
    float strtof(const char *, char **) asm("_strtof");
    long strtol(const char *, char **, int);
    long double strtold(const char *, char **);
    long long strtoll(const char *, char **, int);
    unsigned long strtoul(const char *, char **, int);
    unsigned long long strtoull(const char *, char **, int);
    int system(const char *) asm("_system") __attribute__((availability(tvos, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(macos, introduced=10.0)));
    size_t wcstombs(char *, const wchar_t *, size_t);
    int wctomb(char *, wchar_t);
    void _Exit(int);
    long a64l(const char *);
    double drand48();
    char *ecvt(double, int, int *, int *);
    double erand48(unsigned short [3]);
    char *fcvt(double, int, int *, int *);
    char *gcvt(double, int, char *);
    int getsubopt(char **, char *const *, char **);
    int grantpt(int);
    char *initstate(unsigned int, char *, size_t);
    long jrand48(unsigned short [3]);
    char *l64a(long);
    void lcong48(unsigned short [7]);
    long lrand48();
    char *mktemp(char *);
    int mkstemp(char *);
    long mrand48();
    long nrand48(unsigned short [3]);
    int posix_openpt(int);
    char *ptsname(int);
    int putenv(char *) asm("_putenv");
    long random();
    int rand_r(unsigned int *);
    char *realpath(const char *, char *) asm("_realpath$DARWIN_EXTSN");
    unsigned short *seed48(unsigned short [3]);
    int setenv(const char *, const char *, int) asm("_setenv");
    void setkey(const char *) asm("_setkey");
    char *setstate(const char *);
    void srand48(long);
    void srandom(unsigned int);
    int unlockpt(int);
    int unsetenv(const char *) asm("_unsetenv");
    typedef unsigned char u_int8_t;
    typedef unsigned short u_int16_t;
    typedef unsigned int u_int32_t;
    typedef unsigned long long u_int64_t;
    typedef int64_t register_t;
    typedef u_int64_t user_addr_t;
    typedef u_int64_t user_size_t;
    typedef int64_t user_ssize_t;
    typedef int64_t user_long_t;
    typedef u_int64_t user_ulong_t;
    typedef int64_t user_time_t;
    typedef int64_t user_off_t;
    typedef u_int64_t syscall_arg_t;
    typedef __darwin_dev_t dev_t;
    typedef __darwin_mode_t mode_t;
    u_int32_t arc4random();
    void arc4random_addrandom(unsigned char *, int);
    void arc4random_buf(void *, size_t) __attribute__((availability(macos, introduced=10.7)));
    void arc4random_stir();
    u_int32_t arc4random_uniform(u_int32_t) __attribute__((availability(macos, introduced=10.7)));
    int atexit_b(void (^)()) __attribute__((availability(macos, introduced=10.6)));
    void *bsearch_b(const void *, const void *, size_t, size_t, int (^)(const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    char *cgetcap(char *, const char *, int);
    int cgetclose();
    int cgetent(char **, char **, const char *);
    int cgetfirst(char **, char **);
    int cgetmatch(const char *, const char *);
    int cgetnext(char **, char **);
    int cgetnum(char *, const char *, long *);
    int cgetset(const char *);
    int cgetstr(char *, const char *, char **);
    int cgetustr(char *, const char *, char **);
    int daemon(int, int) asm("_daemon$1050") __attribute__((availability(tvos, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(macos, introduced=10.0, deprecated=10.5)));
    char *devname(dev_t, mode_t);
    char *devname_r(dev_t, mode_t, char *buf, int len);
    char *getbsize(int *, long *);
    int getloadavg(double [], int);
    const char *getprogname();
    int heapsort(void *, size_t, size_t, int (*)(const void *, const void *));
    int heapsort_b(void *, size_t, size_t, int (^)(const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    int mergesort(void *, size_t, size_t, int (*)(const void *, const void *));
    int mergesort_b(void *, size_t, size_t, int (^)(const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    void psort(void *, size_t, size_t, int (*)(const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    void psort_b(void *, size_t, size_t, int (^)(const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    void psort_r(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    void qsort_b(void *, size_t, size_t, int (^)(const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    void qsort_r(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *));
    int radixsort(const unsigned char **, int, const unsigned char *, unsigned int);
    void setprogname(const char *);
    int sradixsort(const unsigned char **, int, const unsigned char *, unsigned int);
    void sranddev();
    void srandomdev();
    void *reallocf(void *, size_t);
    long long strtoq(const char *, char **, int);
    unsigned long long strtouq(const char *, char **, int);
    extern char *suboptarg;
    void *valloc(size_t);
}
extern "C" {
    double atof_l(const char *, locale_t);
    int atoi_l(const char *, locale_t);
    long atol_l(const char *, locale_t);
    long long atoll_l(const char *, locale_t);
    int mblen_l(const char *, size_t, locale_t);
    size_t mbstowcs_l(wchar_t *, const char *, size_t, locale_t);
    int mbtowc_l(wchar_t *, const char *, size_t, locale_t);
    double strtod_l(const char *, char **, locale_t) asm("_strtod_l");
    float strtof_l(const char *, char **, locale_t) asm("_strtof_l");
    long strtol_l(const char *, char **, int, locale_t);
    long double strtold_l(const char *, char **, locale_t);
    long long strtoll_l(const char *, char **, int, locale_t);
    long long strtoq_l(const char *, char **, int, locale_t);
    unsigned long strtoul_l(const char *, char **, int, locale_t);
    unsigned long long strtoull_l(const char *, char **, int, locale_t);
    unsigned long long strtouq_l(const char *, char **, int, locale_t);
    size_t wcstombs_l(char *, const wchar_t *, size_t, locale_t);
    int wctomb_l(char *, wchar_t, locale_t);
}
namespace std {
    inline namespace __1 {
        using ::size_t;
        using ::div_t;
        using ::ldiv_t;
        using ::lldiv_t;
        using ::atof;
        using ::atoi;
        using ::atol;
        using ::atoll;
        using ::strtod;
        using ::strtof;
        using ::strtold;
        using ::strtol;
        using ::strtoll;
        using ::strtoul;
        using ::strtoull;
        using ::rand;
        using ::srand;
        using ::calloc;
        using ::free;
        using ::malloc;
        using ::realloc;
        using ::abort;
        using ::atexit;
        using ::exit;
        using ::_Exit;
        using ::getenv;
        using ::system;
        using ::bsearch;
        using ::qsort;
        using ::abs;
        using ::labs;
        using ::llabs;
        using ::div;
        using ::ldiv;
        using ::lldiv;
        using ::mblen;
        using ::mbtowc;
        using ::wctomb;
        using ::mbstowcs;
        using ::wcstombs;
        inline long abs(long __x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return labs(__x);
        }


        inline long long abs(long long __x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return llabs(__x);
        }


        inline ldiv_t div(long __x, long __y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return ldiv(__x, __y);
        }


        inline lldiv_t div(long long __x, long long __y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return lldiv(__x, __y);
        }


    }
}
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t *qaddr_t;
typedef char *caddr_t;
typedef int32_t daddr_t;
typedef u_int32_t fixpt_t;
typedef __darwin_blkcnt_t blkcnt_t;
typedef __darwin_blksize_t blksize_t;
typedef __darwin_gid_t gid_t;
typedef __uint32_t in_addr_t;
typedef __uint16_t in_port_t;
typedef __darwin_ino_t ino_t;
typedef __darwin_ino64_t ino64_t;
typedef __int32_t key_t;
typedef __uint16_t nlink_t;
typedef int32_t segsz_t;
typedef int32_t swblk_t;
static inline __int32_t major(__uint32_t _x) {
    return (__int32_t)(((__uint32_t)_x >> 24) & 255);
}


static inline __int32_t minor(__uint32_t _x) {
    return (__int32_t)((_x) & 16777215);
}


static inline dev_t makedev(__uint32_t _major, __uint32_t _minor) {
    return (dev_t)(((_major) << 24) | (_minor));
}


typedef __darwin_useconds_t useconds_t;
typedef __darwin_suseconds_t suseconds_t;
typedef __darwin_size_t rsize_t;
typedef int errno_t;
extern "C" {
    struct fd_set {
        __int32_t fds_bits[32];
    };
    typedef struct fd_set fd_set;
}
static inline int __darwin_fd_isset(int _n, const struct fd_set *_p) {
    return (_p->fds_bits[(unsigned long)_n / (sizeof(__int32_t) * 8)] & ((__int32_t)(1 << ((unsigned long)_n % (sizeof(__int32_t) * 8)))));
}


typedef __int32_t fd_mask;
typedef __darwin_fsblkcnt_t fsblkcnt_t;
typedef __darwin_fsfilcnt_t fsfilcnt_t;
struct __nl_cat_d {
    void *__data;
    int __size;
};
typedef struct __nl_cat_d *nl_catd;
typedef __darwin_nl_item nl_item;
extern "C" {
    nl_catd catopen(const char *, int);
    char *catgets(nl_catd, int, int, const char *) __attribute__((format_arg(4)));
    int catclose(nl_catd);
}
namespace std {
    inline namespace __1 {
        typedef std::__1::remove_pointer<locale_t>::type __locale_struct;
        typedef std::__1::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;
        template <class _InputIterator, class _ForwardIterator, class _Ctype> _ForwardIterator __scan_keyword(_InputIterator &__b, _InputIterator __e, _ForwardIterator __kb, _ForwardIterator __ke, const _Ctype &__ct, ios_base::iostate &__err, bool __case_sensitive = true) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_InputIterator>::value_type _CharT;
            size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
            const unsigned char __doesnt_match = '\x00';
            const unsigned char __might_match = '\x01';
            const unsigned char __does_match = '\x02';
            unsigned char __statbuf[100];
            unsigned char *__status = __statbuf;
            unique_ptr<unsigned char, void (*)(void *)> __stat_hold(0, free);
            if (__nkw > sizeof (__statbuf)) {
                __status = (unsigned char *)malloc(__nkw);
                if (__status == 0)
                    __throw_bad_alloc();
                __stat_hold.reset(__status);
            }
            size_t __n_might_match = __nkw;
            size_t __n_does_match = 0;
            unsigned char *__st = __status;
            for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky , (void)++__st) {
                if (!__ky->empty())
                    *__st = __might_match;
                else {
                    *__st = __does_match;
                    --__n_might_match;
                    ++__n_does_match;
                }
            }
            for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx) {
                _CharT __c = *__b;
                if (!__case_sensitive)
                    __c = __ct.toupper(__c);
                bool __consume = false;
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky , (void)++__st) {
                    if (*__st == __might_match) {
                        _CharT __kc = (*__ky)[__indx];
                        if (!__case_sensitive)
                            __kc = __ct.toupper(__kc);
                        if (__c == __kc) {
                            __consume = true;
                            if (__ky->size() == __indx + 1) {
                                *__st = __does_match;
                                --__n_might_match;
                                ++__n_does_match;
                            }
                        } else {
                            *__st = __doesnt_match;
                            --__n_might_match;
                        }
                    }
                }
                if (__consume) {
                    ++__b;
                    if (__n_might_match + __n_does_match > 1) {
                        __st = __status;
                        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky , (void)++__st) {
                            if (*__st == __does_match && __ky->size() != __indx + 1) {
                                *__st = __doesnt_match;
                                --__n_does_match;
                            }
                        }
                    }
                }
            }
            if (__b == __e)
                __err |= ios_base::eofbit;
            for (__st = __status; __kb != __ke; ++__kb , (void)++__st) 
                if (*__st == __does_match)
                    break;
            if (__kb == __ke)
                __err |= ios_base::failbit;
            return __kb;
        }

;
        struct __attribute__((type_visibility("default"))) __num_get_base {
            static const int __num_get_buf_sz = 40;
            static int __get_base(std::__1::ios_base &);
            static const char __src[33];
        };
        void __check_grouping(const string &__grouping, unsigned int *__g, unsigned int *__g_end, ios_base::iostate &__err) __attribute__((visibility("default")));
        template <class _CharT = char> struct __attribute__((type_visibility("default"))) __num_get : protected std::__1::__num_get_base {
            static string __stage2_int_prep(std::__1::ios_base &__iob, char *__atoms, char &__thousands_sep);
            static string __stage2_float_prep(std::__1::ios_base &__iob, char *__atoms, char &__decimal_point, char &__thousands_sep);
            static int __stage2_int_loop(char __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, char __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, char *__atoms);
            static int __stage2_float_loop(char __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, char __decimal_point, char __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, char *__atoms);
        }
template <class _CharT = wchar_t> struct __attribute__((type_visibility("default"))) __num_get : protected std::__1::__num_get_base {
            static string __stage2_int_prep(std::__1::ios_base &__iob, wchar_t *__atoms, wchar_t &__thousands_sep);
            static string __stage2_float_prep(std::__1::ios_base &__iob, wchar_t *__atoms, wchar_t &__decimal_point, wchar_t &__thousands_sep);
            static int __stage2_int_loop(wchar_t __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, wchar_t __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, wchar_t *__atoms);
            static int __stage2_float_loop(wchar_t __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, wchar_t __decimal_point, wchar_t __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, wchar_t *__atoms);
        }
template <class _CharT> struct __num_get : protected std::__1::__num_get_base {
            static string __stage2_int_prep(std::__1::ios_base &__iob, _CharT *__atoms, _CharT &__thousands_sep);
            static string __stage2_float_prep(std::__1::ios_base &__iob, _CharT *__atoms, _CharT &__decimal_point, _CharT &__thousands_sep);
            static int __stage2_int_loop(_CharT __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, _CharT __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, _CharT *__atoms);
            static int __stage2_float_loop(_CharT __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, _CharT __decimal_point, _CharT __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, _CharT *__atoms);
        };
        string __stage2_int_prep(std::__1::ios_base &__iob, _CharT *__atoms, _CharT &__thousands_sep)         {
            std::__1::locale __loc = __iob.getloc();
            use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
            const numpunct<_CharT> &__np = use_facet<numpunct<_CharT> >(__loc);
            __thousands_sep = __np.thousands_sep();
            return __np.grouping();
        }


        string __stage2_float_prep(std::__1::ios_base &__iob, _CharT *__atoms, _CharT &__decimal_point, _CharT &__thousands_sep)         {
            std::__1::locale __loc = __iob.getloc();
            use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
            const numpunct<_CharT> &__np = use_facet<numpunct<_CharT> >(__loc);
            __decimal_point = __np.decimal_point();
            __thousands_sep = __np.thousands_sep();
            return __np.grouping();
        }


        int __stage2_int_loop(_CharT __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, _CharT __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, _CharT *__atoms)         {
            if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25])) {
                *__a_end++ = __ct == __atoms[24] ? '+' : '-';
                __dc = 0;
                return 0;
            }
            if (__grouping.size() != 0 && __ct == __thousands_sep) {
                if (__g_end - __g < __num_get_buf_sz) {
                    *__g_end++ = __dc;
                    __dc = 0;
                }
                return 0;
            }
            ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
            if (__f >= 24)
                return -1;
            switch (__base) {
              case 8:
              case 10:
                if (__f >= __base)
                    return -1;
                break;
              case 16:
                if (__f < 22)
                    break;
                if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0') {
                    __dc = 0;
                    *__a_end++ = __src[__f];
                    return 0;
                }
                return -1;
            }
            *__a_end++ = __src[__f];
            ++__dc;
            return 0;
        }


        int __stage2_float_loop(_CharT __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, _CharT __decimal_point, _CharT __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, _CharT *__atoms)         {
            if (__ct == __decimal_point) {
                if (!__in_units)
                    return -1;
                __in_units = false;
                *__a_end++ = '.';
                if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
                    *__g_end++ = __dc;
                return 0;
            }
            if (__ct == __thousands_sep && __grouping.size() != 0) {
                if (!__in_units)
                    return -1;
                if (__g_end - __g < __num_get_buf_sz) {
                    *__g_end++ = __dc;
                    __dc = 0;
                }
                return 0;
            }
            ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
            if (__f >= 32)
                return -1;
            char __x = __src[__f];
            if (__x == '-' || __x == '+') {
                if (__a_end == __a || (__a_end[-1] & 95) == (__exp & 127)) {
                    *__a_end++ = __x;
                    return 0;
                }
                return -1;
            }
            if (__x == 'x' || __x == 'X')
                __exp = 'P';
            else if ((__x & 95) == __exp) {
                __exp |= 128;
                if (__in_units) {
                    __in_units = false;
                    if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
                        *__g_end++ = __dc;
                }
            }
            *__a_end++ = __x;
            if (__f >= 22)
                return 0;
            ++__dc;
            return 0;
        }


        struct __attribute__((type_visibility("default"))) __num_get : protected std::__1::__num_get_base {
            static string __stage2_int_prep(std::__1::ios_base &__iob, char *__atoms, char &__thousands_sep);
            static string __stage2_float_prep(std::__1::ios_base &__iob, char *__atoms, char &__decimal_point, char &__thousands_sep);
            static int __stage2_int_loop(char __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, char __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, char *__atoms);
            static int __stage2_float_loop(char __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, char __decimal_point, char __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, char *__atoms);
        };
        struct __attribute__((type_visibility("default"))) __num_get : protected std::__1::__num_get_base {
            static string __stage2_int_prep(std::__1::ios_base &__iob, wchar_t *__atoms, wchar_t &__thousands_sep);
            static string __stage2_float_prep(std::__1::ios_base &__iob, wchar_t *__atoms, wchar_t &__decimal_point, wchar_t &__thousands_sep);
            static int __stage2_int_loop(wchar_t __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, wchar_t __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, wchar_t *__atoms);
            static int __stage2_float_loop(wchar_t __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, wchar_t __decimal_point, wchar_t __thousands_sep, const string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, wchar_t *__atoms);
        };
        template <class _CharT = char, class _InputIterator = std::__1::istreambuf_iterator<char, std::__1::char_traits<char> >> class __attribute__((type_visibility("default"))) num_get : public locale::facet, private __num_get<char> {
        public:
            typedef char char_type;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            explicit num_get(size_t __refs) __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::num_get<char>() noexcept __attribute__((always_inline));
            template <class _Fp> iter_type __do_get_floating_point(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const;
            template <class _Signed> iter_type __do_get_signed(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const;
            template <class _Unsigned> iter_type __do_get_unsigned(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const;
        }
template <class _CharT = wchar_t, class _InputIterator = std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> >> class __attribute__((type_visibility("default"))) num_get : public locale::facet, private __num_get<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            explicit num_get(size_t __refs) __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::num_get<wchar_t>() noexcept __attribute__((always_inline));
            template <class _Fp> iter_type __do_get_floating_point(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const;
            template <class _Signed> iter_type __do_get_signed(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const;
            template <class _Unsigned> iter_type __do_get_unsigned(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const;
        }
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) num_get : public locale::facet, private __num_get<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _InputIterator iter_type;
            explicit num_get<_CharT, _InputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __iob, __err, __v);
            }


            static locale::id id;
        protected:
            ~num_get<_CharT, _InputIterator>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _Fp> iter_type __do_get_floating_point(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const;
            template <class _Signed> iter_type __do_get_signed(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const;
            template <class _Unsigned> iter_type __do_get_unsigned(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const             {
                return this->__do_get_signed(__b, __e, __iob, __err, __v);
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const             {
                return this->__do_get_signed(__b, __e, __iob, __err, __v);
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const             {
                return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const             {
                return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const             {
                return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const             {
                return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const             {
                return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const             {
                return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const             {
                return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const;
        };
        locale::id id;
        template <class _Tp> _Tp __num_get_signed_integral(const char *__a, const char *__a_end, ios_base::iostate &__err, int __base)         {
            if (__a != __a_end) {
                typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
                (*__error()) = 0;
                char *__p2;
                long long __ll = strtoll_l(__a, &__p2, __base, 0);
                typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
                if (__current_errno == 0)
                    (*__error()) = __save_errno;
                if (__p2 != __a_end) {
                    __err = ios_base::failbit;
                    return 0;
                } else if (__current_errno == 34 || __ll < numeric_limits<_Tp>::min() || numeric_limits<_Tp>::max() < __ll) {
                    __err = ios_base::failbit;
                    if (__ll > 0)
                        return numeric_limits<_Tp>::max();
                    else
                        return numeric_limits<_Tp>::min();
                }
                return static_cast<_Tp>(__ll);
            }
            __err = ios_base::failbit;
            return 0;
        }

;
        template <class _Tp> _Tp __num_get_unsigned_integral(const char *__a, const char *__a_end, ios_base::iostate &__err, int __base)         {
            if (__a != __a_end) {
                if (*__a == '-') {
                    __err = ios_base::failbit;
                    return 0;
                }
                typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
                (*__error()) = 0;
                char *__p2;
                unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
                typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
                if (__current_errno == 0)
                    (*__error()) = __save_errno;
                if (__p2 != __a_end) {
                    __err = ios_base::failbit;
                    return 0;
                } else if (__current_errno == 34 || numeric_limits<_Tp>::max() < __ll) {
                    __err = ios_base::failbit;
                    return numeric_limits<_Tp>::max();
                }
                return static_cast<_Tp>(__ll);
            }
            __err = ios_base::failbit;
            return 0;
        }

;
        template <class _Tp> _Tp __num_get_float(const char *__a, const char *__a_end, ios_base::iostate &__err)         {
            if (__a != __a_end) {
                typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
                (*__error()) = 0;
                char *__p2;
                long double __ld = strtold_l(__a, &__p2, 0);
                typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
                if (__current_errno == 0)
                    (*__error()) = __save_errno;
                if (__p2 != __a_end) {
                    __err = ios_base::failbit;
                    return 0;
                } else if (__current_errno == 34)
                    __err = ios_base::failbit;
                return static_cast<_Tp>(__ld);
            }
            __err = ios_base::failbit;
            return 0;
        }

;
        _InputIterator do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const         {
            if ((__iob.flags() & ios_base::boolalpha) == 0) {
                long __lv = -1;
                __b = do_get(__b, __e, __iob, __err, __lv);
                switch (__lv) {
                  case 0:
                    __v = false;
                    break;
                  case 1:
                    __v = true;
                    break;
                  default:
                    __v = true;
                    __err = ios_base::failbit;
                    break;
                }
                return __b;
            }
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__iob.getloc());
            const numpunct<_CharT> &__np = use_facet<numpunct<_CharT> >(__iob.getloc());
            typedef typename numpunct<_CharT>::string_type string_type;
            const string_type __names[2] = {__np.truename(), __np.falsename()};
            const string_type *__i = __scan_keyword(__b, __e, __names, __names + 2, __ct, __err);
            __v = __i == __names;
            return __b;
        }


        template <class _Signed> _InputIterator __do_get_signed(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const         {
            int __base = this->__get_base(__iob);
            char_type __atoms[26];
            char_type __thousands_sep;
            string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
            string __buf;
            __buf.resize(__buf.capacity());
            char *__a = &__buf[0];
            char *__a_end = __a;
            unsigned int __g[40];
            unsigned int *__g_end = __g;
            unsigned int __dc = 0;
            for (; __b != __e; ++__b) {
                if (__a_end == __a + __buf.size()) {
                    size_t __tmp = __buf.size();
                    __buf.resize(2 * __buf.size());
                    __buf.resize(__buf.capacity());
                    __a = &__buf[0];
                    __a_end = __a + __tmp;
                }
                if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
                    break;
            }
            if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
                *__g_end++ = __dc;
            __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);
            __check_grouping(__grouping, __g, __g_end, __err);
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }

;
        template <class _Unsigned> _InputIterator __do_get_unsigned(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const         {
            int __base = this->__get_base(__iob);
            char_type __atoms[26];
            char_type __thousands_sep;
            string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
            string __buf;
            __buf.resize(__buf.capacity());
            char *__a = &__buf[0];
            char *__a_end = __a;
            unsigned int __g[40];
            unsigned int *__g_end = __g;
            unsigned int __dc = 0;
            for (; __b != __e; ++__b) {
                if (__a_end == __a + __buf.size()) {
                    size_t __tmp = __buf.size();
                    __buf.resize(2 * __buf.size());
                    __buf.resize(__buf.capacity());
                    __a = &__buf[0];
                    __a_end = __a + __tmp;
                }
                if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
                    break;
            }
            if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
                *__g_end++ = __dc;
            __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);
            __check_grouping(__grouping, __g, __g_end, __err);
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }

;
        template <class _Fp> _InputIterator __do_get_floating_point(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const         {
            char_type __atoms[32];
            char_type __decimal_point;
            char_type __thousands_sep;
            string __grouping = this->__stage2_float_prep(__iob, __atoms, __decimal_point, __thousands_sep);
            string __buf;
            __buf.resize(__buf.capacity());
            char *__a = &__buf[0];
            char *__a_end = __a;
            unsigned int __g[40];
            unsigned int *__g_end = __g;
            unsigned int __dc = 0;
            bool __in_units = true;
            char __exp = 'E';
            for (; __b != __e; ++__b) {
                if (__a_end == __a + __buf.size()) {
                    size_t __tmp = __buf.size();
                    __buf.resize(2 * __buf.size());
                    __buf.resize(__buf.capacity());
                    __a = &__buf[0];
                    __a_end = __a + __tmp;
                }
                if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end, __decimal_point, __thousands_sep, __grouping, __g, __g_end, __dc, __atoms))
                    break;
            }
            if (__grouping.size() != 0 && __in_units && __g_end - __g < __num_get_base::__num_get_buf_sz)
                *__g_end++ = __dc;
            __v = __num_get_float<_Fp>(__a, __a_end, __err);
            __check_grouping(__grouping, __g, __g_end, __err);
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }

;
        _InputIterator do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const         {
            int __base = 16;
            char_type __atoms[26];
            char_type __thousands_sep = 0;
            string __grouping;
            use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src, __num_get_base::__src + 26, __atoms);
            string __buf;
            __buf.resize(__buf.capacity());
            char *__a = &__buf[0];
            char *__a_end = __a;
            unsigned int __g[40];
            unsigned int *__g_end = __g;
            unsigned int __dc = 0;
            for (; __b != __e; ++__b) {
                if (__a_end == __a + __buf.size()) {
                    size_t __tmp = __buf.size();
                    __buf.resize(2 * __buf.size());
                    __buf.resize(__buf.capacity());
                    __a = &__buf[0];
                    __a_end = __a + __tmp;
                }
                if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
                    break;
            }
            __buf.resize(__a_end - __a);
            if (sscanf_l(__buf.c_str(), 0, "%p", &__v) != 1)
                __err = ios_base::failbit;
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }


        class __attribute__((type_visibility("default"))) num_get : public locale::facet, private __num_get<char> {
        public:
            typedef char char_type;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            explicit num_get(size_t __refs) __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::num_get<char>() noexcept __attribute__((always_inline));
            template <class _Fp> iter_type __do_get_floating_point(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const;
            template <class _Signed> iter_type __do_get_signed(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const;
            template <class _Unsigned> iter_type __do_get_unsigned(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const;
        };
        class __attribute__((type_visibility("default"))) num_get : public locale::facet, private __num_get<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            explicit num_get(size_t __refs) __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::num_get<wchar_t>() noexcept __attribute__((always_inline));
            template <class _Fp> iter_type __do_get_floating_point(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const;
            template <class _Signed> iter_type __do_get_signed(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const;
            template <class _Unsigned> iter_type __do_get_unsigned(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const;
        };
        struct __attribute__((type_visibility("default"))) __num_put_base {
        protected:
            static void __format_int(char *__fmt, const char *__len, bool __signd, ios_base::fmtflags __flags);
            static bool __format_float(char *__fmt, const char *__len, ios_base::fmtflags __flags);
            static char *__identify_padding(char *__nb, char *__ne, const std::__1::ios_base &__iob);
        };
        template <class _CharT = char> struct __attribute__((type_visibility("default"))) __num_put : protected std::__1::__num_put_base {
            static void __widen_and_group_int(char *__nb, char *__np, char *__ne, char *__ob, char *&__op, char *&__oe, const std::__1::locale &__loc);
            static void __widen_and_group_float(char *__nb, char *__np, char *__ne, char *__ob, char *&__op, char *&__oe, const std::__1::locale &__loc);
        }
template <class _CharT = wchar_t> struct __attribute__((type_visibility("default"))) __num_put : protected std::__1::__num_put_base {
            static void __widen_and_group_int(char *__nb, char *__np, char *__ne, wchar_t *__ob, wchar_t *&__op, wchar_t *&__oe, const std::__1::locale &__loc);
            static void __widen_and_group_float(char *__nb, char *__np, char *__ne, wchar_t *__ob, wchar_t *&__op, wchar_t *&__oe, const std::__1::locale &__loc);
        }
template <class _CharT> struct __num_put : protected std::__1::__num_put_base {
            static void __widen_and_group_int(char *__nb, char *__np, char *__ne, _CharT *__ob, _CharT *&__op, _CharT *&__oe, const std::__1::locale &__loc);
            static void __widen_and_group_float(char *__nb, char *__np, char *__ne, _CharT *__ob, _CharT *&__op, _CharT *&__oe, const std::__1::locale &__loc);
        };
        void __widen_and_group_int(char *__nb, char *__np, char *__ne, _CharT *__ob, _CharT *&__op, _CharT *&__oe, const std::__1::locale &__loc)         {
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__loc);
            const numpunct<_CharT> &__npt = use_facet<numpunct<_CharT> >(__loc);
            string __grouping = __npt.grouping();
            if (__grouping.empty()) {
                __ct.widen(__nb, __ne, __ob);
                __oe = __ob + (__ne - __nb);
            } else {
                __oe = __ob;
                char *__nf = __nb;
                if (*__nf == '-' || *__nf == '+')
                    *__oe++ = __ct.widen(*__nf++);
                if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X')) {
                    *__oe++ = __ct.widen(*__nf++);
                    *__oe++ = __ct.widen(*__nf++);
                }
                reverse(__nf, __ne);
                _CharT __thousands_sep = __npt.thousands_sep();
                unsigned int __dc = 0;
                unsigned int __dg = 0;
                for (char *__p = __nf; __p < __ne; ++__p) {
                    if (static_cast<unsigned int>(__grouping[__dg]) > 0 && __dc == static_cast<unsigned int>(__grouping[__dg])) {
                        *__oe++ = __thousands_sep;
                        __dc = 0;
                        if (__dg < __grouping.size() - 1)
                            ++__dg;
                    }
                    *__oe++ = __ct.widen(*__p);
                    ++__dc;
                }
                reverse(__ob + (__nf - __nb), __oe);
            }
            if (__np == __ne)
                __op = __oe;
            else
                __op = __ob + (__np - __nb);
        }


        void __widen_and_group_float(char *__nb, char *__np, char *__ne, _CharT *__ob, _CharT *&__op, _CharT *&__oe, const std::__1::locale &__loc)         {
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__loc);
            const numpunct<_CharT> &__npt = use_facet<numpunct<_CharT> >(__loc);
            string __grouping = __npt.grouping();
            __oe = __ob;
            char *__nf = __nb;
            if (*__nf == '-' || *__nf == '+')
                *__oe++ = __ct.widen(*__nf++);
            char *__ns;
            if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X')) {
                *__oe++ = __ct.widen(*__nf++);
                *__oe++ = __ct.widen(*__nf++);
                for (__ns = __nf; __ns < __ne; ++__ns) 
                    if (!isxdigit_l(*__ns, 0))
                        break;
            } else {
                for (__ns = __nf; __ns < __ne; ++__ns) 
                    if (!isdigit_l(*__ns, 0))
                        break;
            }
            if (__grouping.empty()) {
                __ct.widen(__nf, __ns, __oe);
                __oe += __ns - __nf;
            } else {
                reverse(__nf, __ns);
                _CharT __thousands_sep = __npt.thousands_sep();
                unsigned int __dc = 0;
                unsigned int __dg = 0;
                for (char *__p = __nf; __p < __ns; ++__p) {
                    if (__grouping[__dg] > 0 && __dc == static_cast<unsigned int>(__grouping[__dg])) {
                        *__oe++ = __thousands_sep;
                        __dc = 0;
                        if (__dg < __grouping.size() - 1)
                            ++__dg;
                    }
                    *__oe++ = __ct.widen(*__p);
                    ++__dc;
                }
                reverse(__ob + (__nf - __nb), __oe);
            }
            for (__nf = __ns; __nf < __ne; ++__nf) {
                if (*__nf == '.') {
                    *__oe++ = __npt.decimal_point();
                    ++__nf;
                    break;
                } else
                    *__oe++ = __ct.widen(*__nf);
            }
            __ct.widen(__nf, __ne, __oe);
            __oe += __ne - __nf;
            if (__np == __ne)
                __op = __oe;
            else
                __op = __ob + (__np - __nb);
        }


        struct __attribute__((type_visibility("default"))) __num_put : protected std::__1::__num_put_base {
            static void __widen_and_group_int(char *__nb, char *__np, char *__ne, char *__ob, char *&__op, char *&__oe, const std::__1::locale &__loc);
            static void __widen_and_group_float(char *__nb, char *__np, char *__ne, char *__ob, char *&__op, char *&__oe, const std::__1::locale &__loc);
        };
        struct __attribute__((type_visibility("default"))) __num_put : protected std::__1::__num_put_base {
            static void __widen_and_group_int(char *__nb, char *__np, char *__ne, wchar_t *__ob, wchar_t *&__op, wchar_t *&__oe, const std::__1::locale &__loc);
            static void __widen_and_group_float(char *__nb, char *__np, char *__ne, wchar_t *__ob, wchar_t *&__op, wchar_t *&__oe, const std::__1::locale &__loc);
        };
        template <class _CharT = char, class _OutputIterator = std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >> class __attribute__((type_visibility("default"))) num_put : public locale::facet, private __num_put<char> {
        public:
            typedef char char_type;
            typedef std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            explicit num_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::num_put<char>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const;
        }
template <class _CharT = wchar_t, class _OutputIterator = std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> >> class __attribute__((type_visibility("default"))) num_put : public locale::facet, private __num_put<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            explicit num_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::num_put<wchar_t>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const;
        }
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) num_put : public locale::facet, private __num_put<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _OutputIterator iter_type;
            explicit num_put<_CharT, _OutputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __iob, __fl, __v);
            }


            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __iob, __fl, __v);
            }


            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __iob, __fl, __v);
            }


            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long __v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __iob, __fl, __v);
            }


            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long __v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __iob, __fl, __v);
            }


            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __iob, __fl, __v);
            }


            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __iob, __fl, __v);
            }


            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __iob, __fl, __v);
            }


            static locale::id id;
        protected:
            ~num_put<_CharT, _OutputIterator>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const;
        };
        locale::id id;
        template <class _CharT = char, class _OutputIterator = std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >> std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > __pad_and_output(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > __s, const char *__ob, const char *__op, const char *__oe, std::__1::ios_base &__iob, char __fl)template <class _CharT, class _OutputIterator> _OutputIterator __pad_and_output(_OutputIterator __s, const _CharT *__ob, const _CharT *__op, const _CharT *__oe, std::__1::ios_base &__iob, _CharT __fl) __attribute__((visibility("hidden")))         {
            streamsize __sz = __oe - __ob;
            streamsize __ns = __iob.width();
            if (__ns > __sz)
                __ns -= __sz;
            else
                __ns = 0;
            for (; __ob < __op; ++__ob , ++__s) 
                *__s = *__ob;
            for (; __ns; --__ns , ++__s) 
                *__s = __fl;
            for (; __ob < __oe; ++__ob , ++__s) 
                *__s = *__ob;
            __iob.width(0);
            return __s;
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> ostreambuf_iterator<char, std::__1::char_traits<char> > __pad_and_output(ostreambuf_iterator<char, std::__1::char_traits<char> > __s, const char *__ob, const char *__op, const char *__oe, std::__1::ios_base &__iob, char __fl)         {
            if (__s.__sbuf_ == nullptr)
                return __s;
            streamsize __sz = __oe - __ob;
            streamsize __ns = __iob.width();
            if (__ns > __sz)
                __ns -= __sz;
            else
                __ns = 0;
            streamsize __np = __op - __ob;
            if (__np > 0) {
                if (__s.__sbuf_->sputn(__ob, __np) != __np) {
                    __s.__sbuf_ = nullptr;
                    return __s;
                }
            }
            if (__ns > 0) {
                basic_string<char, std::__1::char_traits<char> > __sp(__ns, __fl);
                if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns) {
                    __s.__sbuf_ = nullptr;
                    return __s;
                }
            }
            __np = __oe - __op;
            if (__np > 0) {
                if (__s.__sbuf_->sputn(__op, __np) != __np) {
                    __s.__sbuf_ = nullptr;
                    return __s;
                }
            }
            __iob.width(0);
            return __s;
        }

template <class _CharT, class _Traits> ostreambuf_iterator<_CharT, _Traits> __pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s, const _CharT *__ob, const _CharT *__op, const _CharT *__oe, std::__1::ios_base &__iob, _CharT __fl) __attribute__((visibility("hidden")))         {
            if (__s.__sbuf_ == nullptr)
                return __s;
            streamsize __sz = __oe - __ob;
            streamsize __ns = __iob.width();
            if (__ns > __sz)
                __ns -= __sz;
            else
                __ns = 0;
            streamsize __np = __op - __ob;
            if (__np > 0) {
                if (__s.__sbuf_->sputn(__ob, __np) != __np) {
                    __s.__sbuf_ = nullptr;
                    return __s;
                }
            }
            if (__ns > 0) {
                basic_string<_CharT, _Traits> __sp(__ns, __fl);
                if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns) {
                    __s.__sbuf_ = nullptr;
                    return __s;
                }
            }
            __np = __oe - __op;
            if (__np > 0) {
                if (__s.__sbuf_->sputn(__op, __np) != __np) {
                    __s.__sbuf_ = nullptr;
                    return __s;
                }
            }
            __iob.width(0);
            return __s;
        }

;
        _OutputIterator do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const         {
            if ((__iob.flags() & ios_base::boolalpha) == 0)
                return do_put(__s, __iob, __fl, (unsigned long)__v);
            const numpunct<char_type> &__np = use_facet<numpunct<char_type> >(__iob.getloc());
            typedef typename numpunct<char_type>::string_type string_type;
            string_type __nm = __v ? __np.truename() : __np.falsename();
            for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i , ++__s) 
                *__s = *__i;
            return __s;
        }


        _OutputIterator do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const         {
            char __fmt[6] = {'%', 0};
            const char *__len = "l";
            this->__format_int(__fmt + 1, __len, true, __iob.flags());
            const unsigned int __nbuf = (numeric_limits<long>::digits / 3) + ((numeric_limits<long>::digits % 3) != 0) + 1;
            char __nar[22];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            char_type __o[41];
            char_type *__op;
            char_type *__oe;
            this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }


        _OutputIterator do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const         {
            char __fmt[8] = {'%', 0};
            const char *__len = "ll";
            this->__format_int(__fmt + 1, __len, true, __iob.flags());
            const unsigned int __nbuf = (numeric_limits<long long>::digits / 3) + ((numeric_limits<long long>::digits % 3) != 0) + 2;
            char __nar[23];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            char_type __o[43];
            char_type *__op;
            char_type *__oe;
            this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }


        _OutputIterator do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long __v) const         {
            char __fmt[6] = {'%', 0};
            const char *__len = "l";
            this->__format_int(__fmt + 1, __len, false, __iob.flags());
            const unsigned int __nbuf = (numeric_limits<unsigned long>::digits / 3) + ((numeric_limits<unsigned long>::digits % 3) != 0) + 1;
            char __nar[23];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            char_type __o[43];
            char_type *__op;
            char_type *__oe;
            this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }


        _OutputIterator do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long __v) const         {
            char __fmt[8] = {'%', 0};
            const char *__len = "ll";
            this->__format_int(__fmt + 1, __len, false, __iob.flags());
            const unsigned int __nbuf = (numeric_limits<unsigned long long>::digits / 3) + ((numeric_limits<unsigned long long>::digits % 3) != 0) + 1;
            char __nar[23];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            char_type __o[43];
            char_type *__op;
            char_type *__oe;
            this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }


        _OutputIterator do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const         {
            char __fmt[8] = {'%', 0};
            const char *__len = "";
            bool __specify_precision = this->__format_float(__fmt + 1, __len, __iob.flags());
            const unsigned int __nbuf = 30;
            char __nar[30];
            char *__nb = __nar;
            int __nc;
            if (__specify_precision)
                __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);
            else
                __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
            unique_ptr<char, void (*)(void *)> __nbh(0, free);
            if (__nc > static_cast<int>(__nbuf - 1)) {
                if (__specify_precision)
                    __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
                else
                    __nc = asprintf_l(&__nb, 0, __fmt, __v);
                if (__nb == 0)
                    __throw_bad_alloc();
                __nbh.reset(__nb);
            }
            char *__ne = __nb + __nc;
            char *__np = this->__identify_padding(__nb, __ne, __iob);
            char_type __o[57];
            char_type *__ob = __o;
            unique_ptr<char_type, void (*)(void *)> __obh(0, free);
            if (__nb != __nar) {
                __ob = (char_type *)malloc(2 * static_cast<size_t>(__nc) * sizeof(char_type));
                if (__ob == 0)
                    __throw_bad_alloc();
                __obh.reset(__ob);
            }
            char_type *__op;
            char_type *__oe;
            this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
            __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
            return __s;
        }


        _OutputIterator do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const         {
            char __fmt[8] = {'%', 0};
            const char *__len = "L";
            bool __specify_precision = this->__format_float(__fmt + 1, __len, __iob.flags());
            const unsigned int __nbuf = 30;
            char __nar[30];
            char *__nb = __nar;
            int __nc;
            if (__specify_precision)
                __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);
            else
                __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
            unique_ptr<char, void (*)(void *)> __nbh(0, free);
            if (__nc > static_cast<int>(__nbuf - 1)) {
                if (__specify_precision)
                    __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
                else
                    __nc = asprintf_l(&__nb, 0, __fmt, __v);
                if (__nb == 0)
                    __throw_bad_alloc();
                __nbh.reset(__nb);
            }
            char *__ne = __nb + __nc;
            char *__np = this->__identify_padding(__nb, __ne, __iob);
            char_type __o[57];
            char_type *__ob = __o;
            unique_ptr<char_type, void (*)(void *)> __obh(0, free);
            if (__nb != __nar) {
                __ob = (char_type *)malloc(2 * static_cast<size_t>(__nc) * sizeof(char_type));
                if (__ob == 0)
                    __throw_bad_alloc();
                __obh.reset(__ob);
            }
            char_type *__op;
            char_type *__oe;
            this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
            __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
            return __s;
        }


        _OutputIterator do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const         {
            char __fmt[6] = "%p";
            const unsigned int __nbuf = 20;
            char __nar[20];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            char_type __o[37];
            char_type *__op;
            char_type *__oe;
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__iob.getloc());
            __ct.widen(__nar, __ne, __o);
            __oe = __o + (__ne - __nar);
            if (__np == __ne)
                __op = __oe;
            else
                __op = __o + (__np - __nar);
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }


        class __attribute__((type_visibility("default"))) num_put : public locale::facet, private __num_put<char> {
        public:
            typedef char char_type;
            typedef std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            explicit num_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::num_put<char>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const;
        };
        class __attribute__((type_visibility("default"))) num_put : public locale::facet, private __num_put<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            explicit num_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::num_put<wchar_t>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, bool __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long long __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, unsigned long long) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, long double __v) const;
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const void *__v) const;
        };
        template <class _CharT, class _InputIterator> int __get_up_to_n_digits(_InputIterator &__b, _InputIterator __e, ios_base::iostate &__err, const ctype<_CharT> &__ct, int __n) __attribute__((visibility("hidden")))         {
            if (__b == __e) {
                __err |= ios_base::eofbit | ios_base::failbit;
                return 0;
            }
            _CharT __c = *__b;
            if (!__ct.is(ctype_base::digit, __c)) {
                __err |= ios_base::failbit;
                return 0;
            }
            int __r = __ct.narrow(__c, 0) - '0';
            for (++__b , (void)--__n; __b != __e && __n > 0; ++__b , (void)--__n) {
                __c = *__b;
                if (!__ct.is(ctype_base::digit, __c))
                    return __r;
                __r = __r * 10 + __ct.narrow(__c, 0) - '0';
            }
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __r;
        }

;
        class __attribute__((type_visibility("default"))) time_base {
        public:
            enum dateorder {
                no_order,
                dmy,
                mdy,
                ymd,
                ydm
            };
        };
        template <class _CharT = char> class __time_get_c_storage {
        protected:
            typedef basic_string<char> string_type;
            virtual const string_type *__weeks() const;
            virtual const string_type *__months() const;
            virtual const string_type *__am_pm() const;
            virtual const string_type &__c() const;
            virtual const string_type &__r() const;
            virtual const string_type &__x() const;
            virtual const string_type &__X() const;
            ~std::__1::__time_get_c_storage<char>() noexcept __attribute__((always_inline));
        }
template <class _CharT = wchar_t> class __time_get_c_storage {
        protected:
            typedef basic_string<wchar_t> string_type;
            virtual const string_type *__weeks() const;
            virtual const string_type *__months() const;
            virtual const string_type *__am_pm() const;
            virtual const string_type &__c() const;
            virtual const string_type &__r() const;
            virtual const string_type &__x() const;
            virtual const string_type &__X() const;
            ~std::__1::__time_get_c_storage<wchar_t>() noexcept __attribute__((always_inline));
        }
template <class _CharT> class __attribute__((type_visibility("default"))) __time_get_c_storage {
        protected:
            typedef basic_string<_CharT> string_type;
            virtual const string_type *__weeks() const;
            virtual const string_type *__months() const;
            virtual const string_type *__am_pm() const;
            virtual const string_type &__c() const;
            virtual const string_type &__r() const;
            virtual const string_type &__x() const;
            virtual const string_type &__X() const;
            ~__time_get_c_storage<_CharT>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        template <class _CharT = char, class _InputIterator = std::__1::istreambuf_iterator<char, std::__1::char_traits<char> >> class __attribute__((type_visibility("default"))) time_get : public locale::facet, public std::__1::time_base, private __time_get_c_storage<char> {
        public:
            typedef char char_type;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef time_base::dateorder dateorder;
            typedef basic_string<char_type> string_type;
            explicit time_get(size_t __refs) __attribute__((always_inline));
            dateorder date_order() const __attribute__((always_inline));
            iter_type get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const char_type *__fmtb, const char_type *__fmte) const;
            static locale::id id;
        protected:
            ~std::__1::time_get<char>() noexcept __attribute__((always_inline));
            virtual dateorder do_date_order() const;
            virtual iter_type do_get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const;
        private:
            void __get_white_space(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_percent(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekdayname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_monthname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_month(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year4(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_hour(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_12_hour(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_am_pm(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_minute(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_second(int &__s, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekday(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day_year_num(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
        }
template <class _CharT = wchar_t, class _InputIterator = std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> >> class __attribute__((type_visibility("default"))) time_get : public locale::facet, public std::__1::time_base, private __time_get_c_storage<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef time_base::dateorder dateorder;
            typedef basic_string<char_type> string_type;
            explicit time_get(size_t __refs) __attribute__((always_inline));
            dateorder date_order() const __attribute__((always_inline));
            iter_type get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const char_type *__fmtb, const char_type *__fmte) const;
            static locale::id id;
        protected:
            ~std::__1::time_get<wchar_t>() noexcept __attribute__((always_inline));
            virtual dateorder do_date_order() const;
            virtual iter_type do_get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const;
        private:
            void __get_white_space(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_percent(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekdayname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_monthname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_month(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year4(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_hour(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_12_hour(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_am_pm(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_minute(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_second(int &__s, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekday(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day_year_num(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
        }
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) time_get : public locale::facet, public std::__1::time_base, private __time_get_c_storage<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _InputIterator iter_type;
            typedef time_base::dateorder dateorder;
            typedef basic_string<char_type> string_type;
            explicit time_get<_CharT, _InputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            dateorder date_order() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_date_order();
            }


            iter_type get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_get_time(__b, __e, __iob, __err, __tm);
            }


            iter_type get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_get_date(__b, __e, __iob, __err, __tm);
            }


            iter_type get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_get_weekday(__b, __e, __iob, __err, __tm);
            }


            iter_type get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_get_monthname(__b, __e, __iob, __err, __tm);
            }


            iter_type get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_get_year(__b, __e, __iob, __err, __tm);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod = 0) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
            }


            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const char_type *__fmtb, const char_type *__fmte) const;
            static locale::id id;
        protected:
            ~time_get<_CharT, _InputIterator>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual dateorder do_date_order() const;
            virtual iter_type do_get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const;
        private:
            void __get_white_space(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_percent(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekdayname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_monthname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_month(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year4(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_hour(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_12_hour(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_am_pm(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_minute(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_second(int &__s, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekday(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day_year_num(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
        };
        locale::id id;
        void __get_weekdayname(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            const string_type *__wk = this->__weeks();
            ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk + 14, __ct, __err, false) - __wk;
            if (__i < 14)
                __w = __i % 7;
        }


        void __get_monthname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            const string_type *__month = this->__months();
            ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month + 24, __ct, __err, false) - __month;
            if (__i < 24)
                __m = __i % 12;
        }


        void __get_day(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
                __d = __t;
            else
                __err |= ios_base::failbit;
        }


        void __get_month(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
            if (!(__err & ios_base::failbit) && __t <= 11)
                __m = __t;
            else
                __err |= ios_base::failbit;
        }


        void __get_year(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
            if (!(__err & ios_base::failbit)) {
                if (__t < 69)
                    __t += 2000;
                else if (69 <= __t && __t <= 99)
                    __t += 1900;
                __y = __t - 1900;
            }
        }


        void __get_year4(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
            if (!(__err & ios_base::failbit))
                __y = __t - 1900;
        }


        void __get_hour(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && __t <= 23)
                __h = __t;
            else
                __err |= ios_base::failbit;
        }


        void __get_12_hour(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
                __h = __t;
            else
                __err |= ios_base::failbit;
        }


        void __get_minute(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && __t <= 59)
                __m = __t;
            else
                __err |= ios_base::failbit;
        }


        void __get_second(int &__s, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && __t <= 60)
                __s = __t;
            else
                __err |= ios_base::failbit;
        }


        void __get_weekday(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
            if (!(__err & ios_base::failbit) && __t <= 6)
                __w = __t;
            else
                __err |= ios_base::failbit;
        }


        void __get_day_year_num(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
            if (!(__err & ios_base::failbit) && __t <= 365)
                __d = __t;
            else
                __err |= ios_base::failbit;
        }


        void __get_white_space(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b) 
                ;
            if (__b == __e)
                __err |= ios_base::eofbit;
        }


        void __get_am_pm(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            const string_type *__ap = this->__am_pm();
            if (__ap[0].size() + __ap[1].size() == 0) {
                __err |= ios_base::failbit;
                return;
            }
            ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap + 2, __ct, __err, false) - __ap;
            if (__i == 0 && __h == 12)
                __h = 0;
            else if (__i == 1 && __h < 12)
                __h += 12;
        }


        void __get_percent(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const         {
            if (__b == __e) {
                __err |= ios_base::eofbit | ios_base::failbit;
                return;
            }
            if (__ct.narrow(*__b, 0) != '%')
                __err |= ios_base::failbit;
            else if (++__b == __e)
                __err |= ios_base::eofbit;
        }


        _InputIterator get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const char_type *__fmtb, const char_type *__fmte) const         {
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__iob.getloc());
            __err = ios_base::goodbit;
            while (__fmtb != __fmte && __err == ios_base::goodbit)
                {
                    if (__b == __e) {
                        __err = ios_base::failbit;
                        break;
                    }
                    if (__ct.narrow(*__fmtb, 0) == '%') {
                        if (++__fmtb == __fmte) {
                            __err = ios_base::failbit;
                            break;
                        }
                        char __cmd = __ct.narrow(*__fmtb, 0);
                        char __opt = '\x00';
                        if (__cmd == 'E' || __cmd == '0') {
                            if (++__fmtb == __fmte) {
                                __err = ios_base::failbit;
                                break;
                            }
                            __opt = __cmd;
                            __cmd = __ct.narrow(*__fmtb, 0);
                        }
                        __b = this->do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
                        ++__fmtb;
                    } else if (__ct.is(ctype_base::space, *__fmtb)) {
                        for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb) 
                            ;
                        for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b) 
                            ;
                    } else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb)) {
                        ++__b;
                        ++__fmtb;
                    } else
                        __err = ios_base::failbit;
                }
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }


        typename time_get<_CharT, _InputIterator>::dateorder do_date_order() const         {
            return mdy;
        }


        _InputIterator do_get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
            return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof (__fmt) / sizeof (__fmt[0]));
        }


        _InputIterator do_get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const string_type &__fmt = this->__x();
            return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
        }


        _InputIterator do_get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__iob.getloc());
            this->__get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
            return __b;
        }


        _InputIterator do_get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__iob.getloc());
            this->__get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
            return __b;
        }


        _InputIterator do_get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__iob.getloc());
            this->__get_year(__tm->tm_year, __b, __e, __err, __ct);
            return __b;
        }


        _InputIterator do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char) const         {
            __err = ios_base::goodbit;
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__iob.getloc());
            switch (__fmt) {
              case 'a':
              case 'A':
                this->__get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
                break;
              case 'b':
              case 'B':
              case 'h':
                this->__get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
                break;
              case 'c':
                {
                    const string_type &__fm = this->__c();
                    __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
                }
                break;
              case 'd':
              case 'e':
                this->__get_day(__tm->tm_mday, __b, __e, __err, __ct);
                break;
              case 'D':
                {
                    const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'F':
                {
                    const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'H':
                this->__get_hour(__tm->tm_hour, __b, __e, __err, __ct);
                break;
              case 'I':
                this->__get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
                break;
              case 'j':
                this->__get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
                break;
              case 'm':
                this->__get_month(__tm->tm_mon, __b, __e, __err, __ct);
                break;
              case 'M':
                this->__get_minute(__tm->tm_min, __b, __e, __err, __ct);
                break;
              case 'n':
              case 't':
                this->__get_white_space(__b, __e, __err, __ct);
                break;
              case 'p':
                this->__get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
                break;
              case 'r':
                {
                    const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'R':
                {
                    const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'S':
                this->__get_second(__tm->tm_sec, __b, __e, __err, __ct);
                break;
              case 'T':
                {
                    const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'w':
                this->__get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
                break;
              case 'x':
                return this->do_get_date(__b, __e, __iob, __err, __tm);
              case 'X':
                {
                    const string_type &__fm = this->__X();
                    __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
                }
                break;
              case 'y':
                this->__get_year(__tm->tm_year, __b, __e, __err, __ct);
                break;
              case 'Y':
                this->__get_year4(__tm->tm_year, __b, __e, __err, __ct);
                break;
              case '%':
                this->__get_percent(__b, __e, __err, __ct);
                break;
              default:
                __err |= ios_base::failbit;
            }
            return __b;
        }


        class __attribute__((type_visibility("default"))) time_get : public locale::facet, public std::__1::time_base, private __time_get_c_storage<char> {
        public:
            typedef char char_type;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef time_base::dateorder dateorder;
            typedef basic_string<char_type> string_type;
            explicit time_get(size_t __refs) __attribute__((always_inline));
            dateorder date_order() const __attribute__((always_inline));
            iter_type get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const char_type *__fmtb, const char_type *__fmte) const;
            static locale::id id;
        protected:
            ~std::__1::time_get<char>() noexcept __attribute__((always_inline));
            virtual dateorder do_date_order() const;
            virtual iter_type do_get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const;
        private:
            void __get_white_space(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_percent(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekdayname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_monthname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_month(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year4(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_hour(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_12_hour(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_am_pm(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_minute(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_second(int &__s, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekday(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day_year_num(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
        };
        class __attribute__((type_visibility("default"))) time_get : public locale::facet, public std::__1::time_base, private __time_get_c_storage<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef time_base::dateorder dateorder;
            typedef basic_string<char_type> string_type;
            explicit time_get(size_t __refs) __attribute__((always_inline));
            dateorder date_order() const __attribute__((always_inline));
            iter_type get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const char_type *__fmtb, const char_type *__fmte) const;
            static locale::id id;
        protected:
            ~std::__1::time_get<wchar_t>() noexcept __attribute__((always_inline));
            virtual dateorder do_date_order() const;
            virtual iter_type do_get_time(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_date(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_weekday(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_monthname(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get_year(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const;
        private:
            void __get_white_space(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_percent(iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekdayname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_monthname(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_month(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_year4(int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_hour(int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_12_hour(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_am_pm(int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_minute(int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_second(int &__s, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_weekday(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
            void __get_day_year_num(int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err, const ctype<char_type> &__ct) const;
        };
        class __attribute__((type_visibility("default"))) __time_get {
        protected:
            locale_t __loc_;
            __time_get(const char *__nm);
            __time_get(const string &__nm);
            ~std::__1::__time_get() noexcept;
        };
        template <class _CharT = char> class __time_get_storage : public std::__1::__time_get {
        protected:
            typedef basic_string<char> string_type;
            string_type __weeks_[14];
            string_type __months_[24];
            string_type __am_pm_[2];
            string_type __c_;
            string_type __r_;
            string_type __x_;
            string_type __X_;
            explicit __time_get_storage(const char *__nm);
            explicit __time_get_storage(const string &__nm);
            ~std::__1::__time_get_storage<char>() noexcept __attribute__((always_inline));
            time_base::dateorder __do_date_order() const;
        private:
            void init(const ctype<char> &);
            string_type __analyze(char __fmt, const ctype<char> &);
        }
template <class _CharT = wchar_t> class __time_get_storage : public std::__1::__time_get {
        protected:
            typedef basic_string<wchar_t> string_type;
            string_type __weeks_[14];
            string_type __months_[24];
            string_type __am_pm_[2];
            string_type __c_;
            string_type __r_;
            string_type __x_;
            string_type __X_;
            explicit __time_get_storage(const char *__nm);
            explicit __time_get_storage(const string &__nm);
            ~std::__1::__time_get_storage<wchar_t>() noexcept __attribute__((always_inline));
            time_base::dateorder __do_date_order() const;
        private:
            void init(const ctype<wchar_t> &);
            string_type __analyze(char __fmt, const ctype<wchar_t> &);
        }
template <class _CharT> class __attribute__((type_visibility("default"))) __time_get_storage : public std::__1::__time_get {
        protected:
            typedef basic_string<_CharT> string_type;
            string_type __weeks_[14];
            string_type __months_[24];
            string_type __am_pm_[2];
            string_type __c_;
            string_type __r_;
            string_type __x_;
            string_type __X_;
            explicit __time_get_storage<_CharT>(const char *__nm);
            explicit __time_get_storage<_CharT>(const string &__nm);
            ~__time_get_storage<_CharT>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            time_base::dateorder __do_date_order() const;
        private:
            void init(const ctype<_CharT> &);
            string_type __analyze(char __fmt, const ctype<_CharT> &);
        };
        template <class _CharT = char, class _InputIterator = std::__1::istreambuf_iterator<char, std::__1::char_traits<char> >> class __attribute__((type_visibility("default"))) time_get_byname : public time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >, private __time_get_storage<char> {
        public:
            typedef time_base::dateorder dateorder;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit time_get_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_get_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::time_get_byname<char>() noexcept __attribute__((always_inline));
            virtual dateorder do_date_order() const __attribute__((always_inline));
        private:
            virtual const string_type *__weeks() const __attribute__((always_inline));
            virtual const string_type *__months() const __attribute__((always_inline));
            virtual const string_type *__am_pm() const __attribute__((always_inline));
            virtual const string_type &__c() const __attribute__((always_inline));
            virtual const string_type &__r() const __attribute__((always_inline));
            virtual const string_type &__x() const __attribute__((always_inline));
            virtual const string_type &__X() const __attribute__((always_inline));
        }
template <class _CharT = wchar_t, class _InputIterator = std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> >> class __attribute__((type_visibility("default"))) time_get_byname : public time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >, private __time_get_storage<wchar_t> {
        public:
            typedef time_base::dateorder dateorder;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit time_get_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_get_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::time_get_byname<wchar_t>() noexcept __attribute__((always_inline));
            virtual dateorder do_date_order() const __attribute__((always_inline));
        private:
            virtual const string_type *__weeks() const __attribute__((always_inline));
            virtual const string_type *__months() const __attribute__((always_inline));
            virtual const string_type *__am_pm() const __attribute__((always_inline));
            virtual const string_type &__c() const __attribute__((always_inline));
            virtual const string_type &__r() const __attribute__((always_inline));
            virtual const string_type &__x() const __attribute__((always_inline));
            virtual const string_type &__X() const __attribute__((always_inline));
        }
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) time_get_byname : public time_get<_CharT, _InputIterator>, private __time_get_storage<_CharT> {
        public:
            typedef time_base::dateorder dateorder;
            typedef _InputIterator iter_type;
            typedef _CharT char_type;
            typedef basic_string<char_type> string_type;
            explicit time_get_byname<_CharT, _InputIterator>(const char *__nm, size_t __refs = 0) : time_get<_CharT, _InputIterator>(__refs), __time_get_storage<_CharT>(__nm) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit time_get_byname<_CharT, _InputIterator>(const string &__nm, size_t __refs = 0) : time_get<_CharT, _InputIterator>(__refs), __time_get_storage<_CharT>(__nm) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        protected:
            ~time_get_byname<_CharT, _InputIterator>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual dateorder do_date_order() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__do_date_order();
            }


        private:
            virtual const string_type *__weeks() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__weeks_;
            }


            virtual const string_type *__months() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__months_;
            }


            virtual const string_type *__am_pm() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__am_pm_;
            }


            virtual const string_type &__c() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__c_;
            }


            virtual const string_type &__r() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__r_;
            }


            virtual const string_type &__x() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__x_;
            }


            virtual const string_type &__X() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__X_;
            }


        };
        class __attribute__((type_visibility("default"))) time_get_byname : public time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >, private __time_get_storage<char> {
        public:
            typedef time_base::dateorder dateorder;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit time_get_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_get_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::time_get_byname<char>() noexcept __attribute__((always_inline));
            virtual dateorder do_date_order() const __attribute__((always_inline));
        private:
            virtual const string_type *__weeks() const __attribute__((always_inline));
            virtual const string_type *__months() const __attribute__((always_inline));
            virtual const string_type *__am_pm() const __attribute__((always_inline));
            virtual const string_type &__c() const __attribute__((always_inline));
            virtual const string_type &__r() const __attribute__((always_inline));
            virtual const string_type &__x() const __attribute__((always_inline));
            virtual const string_type &__X() const __attribute__((always_inline));
        };
        class __attribute__((type_visibility("default"))) time_get_byname : public time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >, private __time_get_storage<wchar_t> {
        public:
            typedef time_base::dateorder dateorder;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit time_get_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_get_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::time_get_byname<wchar_t>() noexcept __attribute__((always_inline));
            virtual dateorder do_date_order() const __attribute__((always_inline));
        private:
            virtual const string_type *__weeks() const __attribute__((always_inline));
            virtual const string_type *__months() const __attribute__((always_inline));
            virtual const string_type *__am_pm() const __attribute__((always_inline));
            virtual const string_type &__c() const __attribute__((always_inline));
            virtual const string_type &__r() const __attribute__((always_inline));
            virtual const string_type &__x() const __attribute__((always_inline));
            virtual const string_type &__X() const __attribute__((always_inline));
        };
        class __attribute__((type_visibility("default"))) __time_put {
            locale_t __loc_;
        protected:
            __time_put() : __loc_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            __time_put(const char *__nm);
            __time_put(const string &__nm);
            ~std::__1::__time_put() noexcept;
            void __do_put(char *__nb, char *&__ne, const tm *__tm, char __fmt, char __mod) const;
            void __do_put(wchar_t *__wb, wchar_t *&__we, const tm *__tm, char __fmt, char __mod) const;
        };
        template <class _CharT = char, class _OutputIterator = std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >> class __attribute__((type_visibility("default"))) time_put : public locale::facet, private std::__1::__time_put {
        public:
            typedef char char_type;
            typedef std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            explicit time_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, const char_type *__pb, const char_type *__pe) const;
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, char __fmt, char __mod) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::time_put<char>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &, char_type, const tm *__tm, char __fmt, char __mod) const;
            explicit time_put(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_put(const string &__nm, size_t __refs) __attribute__((always_inline));
        }
template <class _CharT = wchar_t, class _OutputIterator = std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> >> class __attribute__((type_visibility("default"))) time_put : public locale::facet, private std::__1::__time_put {
        public:
            typedef wchar_t char_type;
            typedef std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            explicit time_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, const char_type *__pb, const char_type *__pe) const;
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, char __fmt, char __mod) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::time_put<wchar_t>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &, char_type, const tm *__tm, char __fmt, char __mod) const;
            explicit time_put(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_put(const string &__nm, size_t __refs) __attribute__((always_inline));
        }
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) time_put : public locale::facet, private std::__1::__time_put {
        public:
            typedef _CharT char_type;
            typedef _OutputIterator iter_type;
            explicit time_put<_CharT, _OutputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, const char_type *__pb, const char_type *__pe) const;
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, char __fmt, char __mod = 0) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_put(__s, __iob, __fl, __tm, __fmt, __mod);
            }


            static locale::id id;
        protected:
            ~time_put<_CharT, _OutputIterator>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual iter_type do_put(iter_type __s, std::__1::ios_base &, char_type, const tm *__tm, char __fmt, char __mod) const;
            explicit time_put<_CharT, _OutputIterator>(const char *__nm, size_t __refs) : locale::facet(__refs), std::__1::__time_put(__nm) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit time_put<_CharT, _OutputIterator>(const string &__nm, size_t __refs) : locale::facet(__refs), std::__1::__time_put(__nm) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        locale::id id;
        _OutputIterator put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, const char_type *__pb, const char_type *__pe) const         {
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__iob.getloc());
            for (; __pb != __pe; ++__pb) {
                if (__ct.narrow(*__pb, 0) == '%') {
                    if (++__pb == __pe) {
                        *__s++ = __pb[-1];
                        break;
                    }
                    char __mod = 0;
                    char __fmt = __ct.narrow(*__pb, 0);
                    if (__fmt == 'E' || __fmt == 'O') {
                        if (++__pb == __pe) {
                            *__s++ = __pb[-2];
                            *__s++ = __pb[-1];
                            break;
                        }
                        __mod = __fmt;
                        __fmt = __ct.narrow(*__pb, 0);
                    }
                    __s = this->do_put(__s, __iob, __fl, __tm, __fmt, __mod);
                } else
                    *__s++ = *__pb;
            }
            return __s;
        }


        _OutputIterator do_put(iter_type __s, std::__1::ios_base &, char_type, const tm *__tm, char __fmt, char __mod) const         {
            char_type __nar[100];
            char_type *__nb = __nar;
            char_type *__ne = __nb + 100;
            __do_put(__nb, __ne, __tm, __fmt, __mod);
            return std::__1::copy(__nb, __ne, __s);
        }


        class __attribute__((type_visibility("default"))) time_put : public locale::facet, private std::__1::__time_put {
        public:
            typedef char char_type;
            typedef std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            explicit time_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, const char_type *__pb, const char_type *__pe) const;
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, char __fmt, char __mod) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::time_put<char>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &, char_type, const tm *__tm, char __fmt, char __mod) const;
            explicit time_put(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_put(const string &__nm, size_t __refs) __attribute__((always_inline));
        };
        class __attribute__((type_visibility("default"))) time_put : public locale::facet, private std::__1::__time_put {
        public:
            typedef wchar_t char_type;
            typedef std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            explicit time_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, const char_type *__pb, const char_type *__pe) const;
            iter_type put(iter_type __s, std::__1::ios_base &__iob, char_type __fl, const tm *__tm, char __fmt, char __mod) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::time_put<wchar_t>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, std::__1::ios_base &, char_type, const tm *__tm, char __fmt, char __mod) const;
            explicit time_put(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_put(const string &__nm, size_t __refs) __attribute__((always_inline));
        };
        template <class _CharT = char, class _OutputIterator = std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >> class __attribute__((type_visibility("default"))) time_put_byname : public time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > > {
        public:
            explicit time_put_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_put_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::time_put_byname<char>() noexcept __attribute__((always_inline));
        }
template <class _CharT = wchar_t, class _OutputIterator = std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> >> class __attribute__((type_visibility("default"))) time_put_byname : public time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > > {
        public:
            explicit time_put_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_put_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::time_put_byname<wchar_t>() noexcept __attribute__((always_inline));
        }
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) time_put_byname : public time_put<_CharT, _OutputIterator> {
        public:
            explicit time_put_byname<_CharT, _OutputIterator>(const char *__nm, size_t __refs = 0) : time_put<_CharT, _OutputIterator>(__nm, __refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit time_put_byname<_CharT, _OutputIterator>(const string &__nm, size_t __refs = 0) : time_put<_CharT, _OutputIterator>(__nm, __refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        protected:
            ~time_put_byname<_CharT, _OutputIterator>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        class __attribute__((type_visibility("default"))) time_put_byname : public time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > > {
        public:
            explicit time_put_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_put_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::time_put_byname<char>() noexcept __attribute__((always_inline));
        };
        class __attribute__((type_visibility("default"))) time_put_byname : public time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > > {
        public:
            explicit time_put_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit time_put_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::time_put_byname<wchar_t>() noexcept __attribute__((always_inline));
        };
        class __attribute__((type_visibility("default"))) money_base {
        public:
            enum part {
                none,
                space,
                symbol,
                sign,
                value
            };
            struct pattern {
                char field[4];
            };
            money_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        template <class _CharT = char, bool _International = false> class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((always_inline));
            char_type decimal_point() const __attribute__((always_inline));
            char_type thousands_sep() const __attribute__((always_inline));
            string grouping() const __attribute__((always_inline));
            string_type curr_symbol() const __attribute__((always_inline));
            string_type positive_sign() const __attribute__((always_inline));
            string_type negative_sign() const __attribute__((always_inline));
            int frac_digits() const __attribute__((always_inline));
            std::__1::money_base::pattern pos_format() const __attribute__((always_inline));
            std::__1::money_base::pattern neg_format() const __attribute__((always_inline));
            static locale::id id;
            static const bool intl = false;
        protected:
            ~std::__1::moneypunct<char, false>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        }
template <class _CharT = char, bool _International = true> class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((always_inline));
            char_type decimal_point() const __attribute__((always_inline));
            char_type thousands_sep() const __attribute__((always_inline));
            string grouping() const __attribute__((always_inline));
            string_type curr_symbol() const __attribute__((always_inline));
            string_type positive_sign() const __attribute__((always_inline));
            string_type negative_sign() const __attribute__((always_inline));
            int frac_digits() const __attribute__((always_inline));
            std::__1::money_base::pattern pos_format() const __attribute__((always_inline));
            std::__1::money_base::pattern neg_format() const __attribute__((always_inline));
            static locale::id id;
            static const bool intl = true;
        protected:
            ~std::__1::moneypunct<char, true>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        }
template <class _CharT = wchar_t, bool _International = false> class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((always_inline));
            char_type decimal_point() const __attribute__((always_inline));
            char_type thousands_sep() const __attribute__((always_inline));
            string grouping() const __attribute__((always_inline));
            string_type curr_symbol() const __attribute__((always_inline));
            string_type positive_sign() const __attribute__((always_inline));
            string_type negative_sign() const __attribute__((always_inline));
            int frac_digits() const __attribute__((always_inline));
            std::__1::money_base::pattern pos_format() const __attribute__((always_inline));
            std::__1::money_base::pattern neg_format() const __attribute__((always_inline));
            static locale::id id;
            static const bool intl = false;
        protected:
            ~std::__1::moneypunct<wchar_t, false>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        }
template <class _CharT = wchar_t, bool _International = true> class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((always_inline));
            char_type decimal_point() const __attribute__((always_inline));
            char_type thousands_sep() const __attribute__((always_inline));
            string grouping() const __attribute__((always_inline));
            string_type curr_symbol() const __attribute__((always_inline));
            string_type positive_sign() const __attribute__((always_inline));
            string_type negative_sign() const __attribute__((always_inline));
            int frac_digits() const __attribute__((always_inline));
            std::__1::money_base::pattern pos_format() const __attribute__((always_inline));
            std::__1::money_base::pattern neg_format() const __attribute__((always_inline));
            static locale::id id;
            static const bool intl = true;
        protected:
            ~std::__1::moneypunct<wchar_t, true>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        }
template <class _CharT, bool _International = false> class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef _CharT char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct<_CharT, _International>(size_t __refs = 0) : locale::facet(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            char_type decimal_point() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_decimal_point();
            }


            char_type thousands_sep() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_thousands_sep();
            }


            string grouping() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_grouping();
            }


            string_type curr_symbol() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_curr_symbol();
            }


            string_type positive_sign() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_positive_sign();
            }


            string_type negative_sign() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_negative_sign();
            }


            int frac_digits() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_frac_digits();
            }


            std::__1::money_base::pattern pos_format() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_pos_format();
            }


            std::__1::money_base::pattern neg_format() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_neg_format();
            }


            static locale::id id;
            static const bool intl = _International;
        protected:
            ~moneypunct<_CharT, _International>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual char_type do_decimal_point() const             {
                return numeric_limits<char_type>::max();
            }


            virtual char_type do_thousands_sep() const             {
                return numeric_limits<char_type>::max();
            }


            virtual string do_grouping() const             {
                return string();
            }


            virtual string_type do_curr_symbol() const             {
                return string_type();
            }


            virtual string_type do_positive_sign() const             {
                return string_type();
            }


            virtual string_type do_negative_sign() const             {
                return string_type(1, '-');
            }


            virtual int do_frac_digits() const             {
                return 0;
            }


            virtual std::__1::money_base::pattern do_pos_format() const             {
                std::__1::money_base::pattern __p = {{symbol, sign, none, value}};
                return __p;
            }


            virtual std::__1::money_base::pattern do_neg_format() const             {
                std::__1::money_base::pattern __p = {{symbol, sign, none, value}};
                return __p;
            }


        };
        locale::id id;
        const bool intl;
        class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((always_inline));
            char_type decimal_point() const __attribute__((always_inline));
            char_type thousands_sep() const __attribute__((always_inline));
            string grouping() const __attribute__((always_inline));
            string_type curr_symbol() const __attribute__((always_inline));
            string_type positive_sign() const __attribute__((always_inline));
            string_type negative_sign() const __attribute__((always_inline));
            int frac_digits() const __attribute__((always_inline));
            std::__1::money_base::pattern pos_format() const __attribute__((always_inline));
            std::__1::money_base::pattern neg_format() const __attribute__((always_inline));
            static locale::id id;
            static const bool intl = false;
        protected:
            ~std::__1::moneypunct<char, false>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        };
        class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((always_inline));
            char_type decimal_point() const __attribute__((always_inline));
            char_type thousands_sep() const __attribute__((always_inline));
            string grouping() const __attribute__((always_inline));
            string_type curr_symbol() const __attribute__((always_inline));
            string_type positive_sign() const __attribute__((always_inline));
            string_type negative_sign() const __attribute__((always_inline));
            int frac_digits() const __attribute__((always_inline));
            std::__1::money_base::pattern pos_format() const __attribute__((always_inline));
            std::__1::money_base::pattern neg_format() const __attribute__((always_inline));
            static locale::id id;
            static const bool intl = true;
        protected:
            ~std::__1::moneypunct<char, true>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        };
        class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((always_inline));
            char_type decimal_point() const __attribute__((always_inline));
            char_type thousands_sep() const __attribute__((always_inline));
            string grouping() const __attribute__((always_inline));
            string_type curr_symbol() const __attribute__((always_inline));
            string_type positive_sign() const __attribute__((always_inline));
            string_type negative_sign() const __attribute__((always_inline));
            int frac_digits() const __attribute__((always_inline));
            std::__1::money_base::pattern pos_format() const __attribute__((always_inline));
            std::__1::money_base::pattern neg_format() const __attribute__((always_inline));
            static locale::id id;
            static const bool intl = false;
        protected:
            ~std::__1::moneypunct<wchar_t, false>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        };
        class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((always_inline));
            char_type decimal_point() const __attribute__((always_inline));
            char_type thousands_sep() const __attribute__((always_inline));
            string grouping() const __attribute__((always_inline));
            string_type curr_symbol() const __attribute__((always_inline));
            string_type positive_sign() const __attribute__((always_inline));
            string_type negative_sign() const __attribute__((always_inline));
            int frac_digits() const __attribute__((always_inline));
            std::__1::money_base::pattern pos_format() const __attribute__((always_inline));
            std::__1::money_base::pattern neg_format() const __attribute__((always_inline));
            static locale::id id;
            static const bool intl = true;
        protected:
            ~std::__1::moneypunct<wchar_t, true>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        };
        template <class _CharT = char, bool _International = false> class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<char, false> {
        public:
            typedef money_base::pattern pattern;
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit moneypunct_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::moneypunct_byname<char, false>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual pattern do_pos_format() const;
            virtual pattern do_neg_format() const;
        private:
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
            string_type __curr_symbol_;
            string_type __positive_sign_;
            string_type __negative_sign_;
            int __frac_digits_;
            pattern __pos_format_;
            pattern __neg_format_;
            void init(const char *);
        }
template <class _CharT = char, bool _International = true> class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<char, true> {
        public:
            typedef money_base::pattern pattern;
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit moneypunct_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::moneypunct_byname<char, true>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual pattern do_pos_format() const;
            virtual pattern do_neg_format() const;
        private:
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
            string_type __curr_symbol_;
            string_type __positive_sign_;
            string_type __negative_sign_;
            int __frac_digits_;
            pattern __pos_format_;
            pattern __neg_format_;
            void init(const char *);
        }
template <class _CharT = wchar_t, bool _International = false> class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<wchar_t, false> {
        public:
            typedef money_base::pattern pattern;
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit moneypunct_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::moneypunct_byname<wchar_t, false>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual pattern do_pos_format() const;
            virtual pattern do_neg_format() const;
        private:
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
            string_type __curr_symbol_;
            string_type __positive_sign_;
            string_type __negative_sign_;
            int __frac_digits_;
            pattern __pos_format_;
            pattern __neg_format_;
            void init(const char *);
        }
template <class _CharT = wchar_t, bool _International = true> class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<wchar_t, true> {
        public:
            typedef money_base::pattern pattern;
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit moneypunct_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::moneypunct_byname<wchar_t, true>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual pattern do_pos_format() const;
            virtual pattern do_neg_format() const;
        private:
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
            string_type __curr_symbol_;
            string_type __positive_sign_;
            string_type __negative_sign_;
            int __frac_digits_;
            pattern __pos_format_;
            pattern __neg_format_;
            void init(const char *);
        }
template <class _CharT, bool _International = false> class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<_CharT, _International> {
        public:
            typedef money_base::pattern pattern;
            typedef _CharT char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct_byname<_CharT, _International>(const char *__nm, size_t __refs = 0) : moneypunct<_CharT, _International>(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->init(__nm);
            }


            explicit moneypunct_byname<_CharT, _International>(const string &__nm, size_t __refs = 0) : moneypunct<_CharT, _International>(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->init(__nm.c_str());
            }


        protected:
            ~moneypunct_byname<_CharT, _International>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual char_type do_decimal_point() const             {
                return this->__decimal_point_;
            }


            virtual char_type do_thousands_sep() const             {
                return this->__thousands_sep_;
            }


            virtual string do_grouping() const             {
                return this->__grouping_;
            }


            virtual string_type do_curr_symbol() const             {
                return this->__curr_symbol_;
            }


            virtual string_type do_positive_sign() const             {
                return this->__positive_sign_;
            }


            virtual string_type do_negative_sign() const             {
                return this->__negative_sign_;
            }


            virtual int do_frac_digits() const             {
                return this->__frac_digits_;
            }


            virtual pattern do_pos_format() const             {
                return this->__pos_format_;
            }


            virtual pattern do_neg_format() const             {
                return this->__neg_format_;
            }


        private:
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
            string_type __curr_symbol_;
            string_type __positive_sign_;
            string_type __negative_sign_;
            int __frac_digits_;
            pattern __pos_format_;
            pattern __neg_format_;
            void init(const char *);
        };
        void init(const char *);
        void init(const char *);
        void init(const char *);
        void init(const char *);
        class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<char, false> {
        public:
            typedef money_base::pattern pattern;
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit moneypunct_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::moneypunct_byname<char, false>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual pattern do_pos_format() const;
            virtual pattern do_neg_format() const;
        private:
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
            string_type __curr_symbol_;
            string_type __positive_sign_;
            string_type __negative_sign_;
            int __frac_digits_;
            pattern __pos_format_;
            pattern __neg_format_;
            void init(const char *);
        };
        class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<char, true> {
        public:
            typedef money_base::pattern pattern;
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit moneypunct_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::moneypunct_byname<char, true>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual pattern do_pos_format() const;
            virtual pattern do_neg_format() const;
        private:
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
            string_type __curr_symbol_;
            string_type __positive_sign_;
            string_type __negative_sign_;
            int __frac_digits_;
            pattern __pos_format_;
            pattern __neg_format_;
            void init(const char *);
        };
        class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<wchar_t, false> {
        public:
            typedef money_base::pattern pattern;
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit moneypunct_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::moneypunct_byname<wchar_t, false>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual pattern do_pos_format() const;
            virtual pattern do_neg_format() const;
        private:
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
            string_type __curr_symbol_;
            string_type __positive_sign_;
            string_type __negative_sign_;
            int __frac_digits_;
            pattern __pos_format_;
            pattern __neg_format_;
            void init(const char *);
        };
        class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<wchar_t, true> {
        public:
            typedef money_base::pattern pattern;
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((always_inline));
            explicit moneypunct_byname(const string &__nm, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::moneypunct_byname<wchar_t, true>() noexcept __attribute__((always_inline));
            virtual char_type do_decimal_point() const;
            virtual char_type do_thousands_sep() const;
            virtual string do_grouping() const;
            virtual string_type do_curr_symbol() const;
            virtual string_type do_positive_sign() const;
            virtual string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual pattern do_pos_format() const;
            virtual pattern do_neg_format() const;
        private:
            char_type __decimal_point_;
            char_type __thousands_sep_;
            string __grouping_;
            string_type __curr_symbol_;
            string_type __positive_sign_;
            string_type __negative_sign_;
            int __frac_digits_;
            pattern __pos_format_;
            pattern __neg_format_;
            void init(const char *);
        };
        template <class _CharT = char> class __attribute__((type_visibility("default"))) __money_get {
        protected:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            __money_get() __attribute__((always_inline));
            static void __gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__psn, string_type &__nsn, int &__fd);
        }
template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) __money_get {
        protected:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            __money_get() __attribute__((always_inline));
            static void __gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__psn, string_type &__nsn, int &__fd);
        }
template <class _CharT> class __money_get {
        protected:
            typedef _CharT char_type;
            typedef basic_string<char_type> string_type;
            __money_get<_CharT>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            static void __gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__psn, string_type &__nsn, int &__fd);
        };
        void __gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__psn, string_type &__nsn, int &__fd)         {
            if (__intl) {
                const moneypunct<char_type, true> &__mp = use_facet<moneypunct<char_type, true> >(__loc);
                __pat = __mp.neg_format();
                __nsn = __mp.negative_sign();
                __psn = __mp.positive_sign();
                __dp = __mp.decimal_point();
                __ts = __mp.thousands_sep();
                __grp = __mp.grouping();
                __sym = __mp.curr_symbol();
                __fd = __mp.frac_digits();
            } else {
                const moneypunct<char_type, false> &__mp = use_facet<moneypunct<char_type, false> >(__loc);
                __pat = __mp.neg_format();
                __nsn = __mp.negative_sign();
                __psn = __mp.positive_sign();
                __dp = __mp.decimal_point();
                __ts = __mp.thousands_sep();
                __grp = __mp.grouping();
                __sym = __mp.curr_symbol();
                __fd = __mp.frac_digits();
            }
        }


        class __attribute__((type_visibility("default"))) __money_get {
        protected:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            __money_get() __attribute__((always_inline));
            static void __gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__psn, string_type &__nsn, int &__fd);
        };
        class __attribute__((type_visibility("default"))) __money_get {
        protected:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            __money_get() __attribute__((always_inline));
            static void __gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__psn, string_type &__nsn, int &__fd);
        };
        template <class _CharT = char, class _InputIterator = std::__1::istreambuf_iterator<char, std::__1::char_traits<char> >> class __attribute__((type_visibility("default"))) money_get : public locale::facet, private __money_get<char> {
        public:
            typedef char char_type;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_get(size_t __refs) __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::money_get<char>() noexcept __attribute__((always_inline));
            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const;
        private:
            static bool __do_get(iter_type &__b, iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<char_type> &__ct, unique_ptr<char_type, void (*)(void *)> &__wb, char_type *&__wn, char_type *__we);
        }
template <class _CharT = wchar_t, class _InputIterator = std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> >> class __attribute__((type_visibility("default"))) money_get : public locale::facet, private __money_get<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_get(size_t __refs) __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::money_get<wchar_t>() noexcept __attribute__((always_inline));
            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const;
        private:
            static bool __do_get(iter_type &__b, iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<char_type> &__ct, unique_ptr<char_type, void (*)(void *)> &__wb, char_type *&__wn, char_type *__we);
        }
template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) money_get : public locale::facet, private __money_get<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _InputIterator iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_get<_CharT, _InputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __intl, __iob, __err, __v);
            }


            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_get(__b, __e, __intl, __iob, __err, __v);
            }


            static locale::id id;
        protected:
            ~money_get<_CharT, _InputIterator>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const;
        private:
            static bool __do_get(iter_type &__b, iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<char_type> &__ct, unique_ptr<char_type, void (*)(void *)> &__wb, char_type *&__wn, char_type *__we);
        };
        locale::id id;
        void __do_nothing(void *) __attribute__((visibility("default")));
        template <class _Tp = unsigned int> void __double_or_nothing(unique_ptr<unsigned int, void (*)(void *)> &__b, unsigned int *&__n, unsigned int *&__e)template <class _Tp> void __double_or_nothing(unique_ptr<_Tp, void (*)(void *)> &__b, _Tp *&__n, _Tp *&__e) __attribute__((visibility("hidden")))         {
            bool __owns = __b.get_deleter() != __do_nothing;
            size_t __cur_cap = static_cast<size_t>(__e - __b.get()) * sizeof(_Tp);
            size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ? 2 * __cur_cap : numeric_limits<size_t>::max();
            if (__new_cap == 0)
                __new_cap = sizeof(_Tp);
            size_t __n_off = static_cast<size_t>(__n - __b.get());
            _Tp *__t = (_Tp *)realloc(__owns ? __b.get() : 0, __new_cap);
            if (__t == 0)
                __throw_bad_alloc();
            if (__owns)
                __b.release();
            __b = unique_ptr<_Tp, void (*)(void *)>(__t, free);
            __new_cap /= sizeof(_Tp);
            __n = __b.get() + __n_off;
            __e = __b.get() + __new_cap;
        }

;
        bool __do_get(iter_type &__b, iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<char_type> &__ct, unique_ptr<char_type, void (*)(void *)> &__wb, char_type *&__wn, char_type *__we)         {
            const unsigned int __bz = 100;
            unsigned int __gbuf[100];
            unique_ptr<unsigned int, void (*)(void *)> __gb(__gbuf, __do_nothing);
            unsigned int *__gn = __gb.get();
            unsigned int *__ge = __gn + __bz;
            money_base::pattern __pat;
            char_type __dp;
            char_type __ts;
            string __grp;
            string_type __sym;
            string_type __psn;
            string_type __nsn;
            string_type __spaces;
            int __fd;
            __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp, __sym, __psn, __nsn, __fd);
            const string_type *__trailing_sign = 0;
            __wn = __wb.get();
            for (unsigned int __p = 0; __p < 4 && __b != __e; ++__p) {
                switch (__pat.field[__p]) {
                  case money_base::space:
                    if (__p != 3) {
                        if (__ct.is(ctype_base::space, *__b))
                            __spaces.push_back(*__b++);
                        else {
                            __err |= ios_base::failbit;
                            return false;
                        }
                    }
                  case money_base::none:
                    if (__p != 3) {
                        while (__b != __e && __ct.is(ctype_base::space, *__b))
                            __spaces.push_back(*__b++);
                    }
                    break;
                  case money_base::sign:
                    if (__psn.size() + __nsn.size() > 0) {
                        if (__psn.size() == 0 || __nsn.size() == 0) {
                            if (__psn.size() > 0) {
                                if (*__b == __psn[0]) {
                                    ++__b;
                                    if (__psn.size() > 1)
                                        __trailing_sign = &__psn;
                                } else
                                    __neg = true;
                            } else if (*__b == __nsn[0]) {
                                ++__b;
                                __neg = true;
                                if (__nsn.size() > 1)
                                    __trailing_sign = &__nsn;
                            }
                        } else {
                            if (*__b == __psn[0]) {
                                ++__b;
                                if (__psn.size() > 1)
                                    __trailing_sign = &__psn;
                            } else if (*__b == __nsn[0]) {
                                ++__b;
                                __neg = true;
                                if (__nsn.size() > 1)
                                    __trailing_sign = &__nsn;
                            } else {
                                __err |= ios_base::failbit;
                                return false;
                            }
                        }
                    }
                    break;
                  case money_base::symbol:
                    {
                        bool __more_needed = __trailing_sign || (__p < 2) || (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
                        bool __sb = (__flags & ios_base::showbase) != 0;
                        if (__sb || __more_needed) {
                            typename string_type::const_iterator __sym_space_end = __sym.begin();
                            if (__p > 0 && (__pat.field[__p - 1] == money_base::none || __pat.field[__p - 1] == money_base::space)) {
                                while (__sym_space_end != __sym.end() && __ct.is(ctype_base::space, *__sym_space_end))
                                    ++__sym_space_end;
                                const size_t __num_spaces = __sym_space_end - __sym.begin();
                                if (__num_spaces > __spaces.size() || !equal(__spaces.end() - __num_spaces, __spaces.end(), __sym.begin())) {
                                    __sym_space_end = __sym.begin();
                                }
                            }
                            typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                            while (__sym_curr_char != __sym.end() && __b != __e && *__b == *__sym_curr_char)
                                {
                                    ++__b;
                                    ++__sym_curr_char;
                                }
                            if (__sb && __sym_curr_char != __sym.end()) {
                                __err |= ios_base::failbit;
                                return false;
                            }
                        }
                    }
                    break;
                  case money_base::value:
                    {
                        unsigned int __ng = 0;
                        for (; __b != __e; ++__b) {
                            char_type __c = *__b;
                            if (__ct.is(ctype_base::digit, __c)) {
                                if (__wn == __we)
                                    __double_or_nothing(__wb, __wn, __we);
                                *__wn++ = __c;
                                ++__ng;
                            } else if (__grp.size() > 0 && __ng > 0 && __c == __ts) {
                                if (__gn == __ge)
                                    __double_or_nothing(__gb, __gn, __ge);
                                *__gn++ = __ng;
                                __ng = 0;
                            } else
                                break;
                        }
                        if (__gb.get() != __gn && __ng > 0) {
                            if (__gn == __ge)
                                __double_or_nothing(__gb, __gn, __ge);
                            *__gn++ = __ng;
                        }
                        if (__fd > 0) {
                            if (__b == __e || *__b != __dp) {
                                __err |= ios_base::failbit;
                                return false;
                            }
                            for (++__b; __fd > 0; --__fd , ++__b) {
                                if (__b == __e || !__ct.is(ctype_base::digit, *__b)) {
                                    __err |= ios_base::failbit;
                                    return false;
                                }
                                if (__wn == __we)
                                    __double_or_nothing(__wb, __wn, __we);
                                *__wn++ = *__b;
                            }
                        }
                        if (__wn == __wb.get()) {
                            __err |= ios_base::failbit;
                            return false;
                        }
                    }
                    break;
                }
            }
            if (__trailing_sign) {
                for (unsigned int __i = 1; __i < __trailing_sign->size(); ++__i , ++__b) {
                    if (__b == __e || *__b != (*__trailing_sign)[__i]) {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            if (__gb.get() != __gn) {
                ios_base::iostate __et = ios_base::goodbit;
                __check_grouping(__grp, __gb.get(), __gn, __et);
                if (__et) {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            return true;
        }


        _InputIterator do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const         {
            const int __bz = 100;
            char_type __wbuf[100];
            unique_ptr<char_type, void (*)(void *)> __wb(__wbuf, __do_nothing);
            char_type *__wn;
            char_type *__we = __wbuf + __bz;
            std::__1::locale __loc = __iob.getloc();
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__loc);
            bool __neg = false;
            if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb, __wn, __we)) {
                const char __src[] = "0123456789";
                char_type __atoms[10];
                __ct.widen(__src, __src + (sizeof (__src) - 1), __atoms);
                char __nbuf[100];
                char *__nc = __nbuf;
                unique_ptr<char, void (*)(void *)> __h(0, free);
                if (__wn - __wb.get() > __bz - 2) {
                    __h.reset((char *)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
                    if (__h.get() == 0)
                        __throw_bad_alloc();
                    __nc = __h.get();
                }
                if (__neg)
                    *__nc++ = '-';
                for (const char_type *__w = __wb.get(); __w < __wn; ++__w , ++__nc) 
                    *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
                *__nc = char();
                if (sscanf(__nbuf, "%Lf", &__v) != 1)
                    __throw_runtime_error("money_get error");
            }
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }


        _InputIterator do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const         {
            const int __bz = 100;
            char_type __wbuf[100];
            unique_ptr<char_type, void (*)(void *)> __wb(__wbuf, __do_nothing);
            char_type *__wn;
            char_type *__we = __wbuf + __bz;
            std::__1::locale __loc = __iob.getloc();
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__loc);
            bool __neg = false;
            if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb, __wn, __we)) {
                __v.clear();
                if (__neg)
                    __v.push_back(__ct.widen('-'));
                char_type __z = __ct.widen('0');
                char_type *__w;
                for (__w = __wb.get(); __w < __wn - 1; ++__w) 
                    if (*__w != __z)
                        break;
                __v.append(__w, __wn);
            }
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }


        class __attribute__((type_visibility("default"))) money_get : public locale::facet, private __money_get<char> {
        public:
            typedef char char_type;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_get(size_t __refs) __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::money_get<char>() noexcept __attribute__((always_inline));
            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const;
        private:
            static bool __do_get(iter_type &__b, iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<char_type> &__ct, unique_ptr<char_type, void (*)(void *)> &__wb, char_type *&__wn, char_type *__we);
        };
        class __attribute__((type_visibility("default"))) money_get : public locale::facet, private __money_get<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_get(size_t __refs) __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((always_inline));
            iter_type get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::money_get<wchar_t>() noexcept __attribute__((always_inline));
            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, string_type &__v) const;
        private:
            static bool __do_get(iter_type &__b, iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<char_type> &__ct, unique_ptr<char_type, void (*)(void *)> &__wb, char_type *&__wn, char_type *__we);
        };
        template <class _CharT = char> class __attribute__((type_visibility("default"))) __money_put {
        protected:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            __money_put() __attribute__((always_inline));
            static void __gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__sn, int &__fd);
            static void __format(char_type *__mb, char_type *&__mi, char_type *&__me, ios_base::fmtflags __flags, const char_type *__db, const char_type *__de, const ctype<char_type> &__ct, bool __neg, const money_base::pattern &__pat, char_type __dp, char_type __ts, const string &__grp, const string_type &__sym, const string_type &__sn, int __fd);
        }
template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) __money_put {
        protected:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            __money_put() __attribute__((always_inline));
            static void __gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__sn, int &__fd);
            static void __format(char_type *__mb, char_type *&__mi, char_type *&__me, ios_base::fmtflags __flags, const char_type *__db, const char_type *__de, const ctype<char_type> &__ct, bool __neg, const money_base::pattern &__pat, char_type __dp, char_type __ts, const string &__grp, const string_type &__sym, const string_type &__sn, int __fd);
        }
template <class _CharT> class __money_put {
        protected:
            typedef _CharT char_type;
            typedef basic_string<char_type> string_type;
            __money_put<_CharT>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            static void __gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__sn, int &__fd);
            static void __format(char_type *__mb, char_type *&__mi, char_type *&__me, ios_base::fmtflags __flags, const char_type *__db, const char_type *__de, const ctype<char_type> &__ct, bool __neg, const money_base::pattern &__pat, char_type __dp, char_type __ts, const string &__grp, const string_type &__sym, const string_type &__sn, int __fd);
        };
        void __gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__sn, int &__fd)         {
            if (__intl) {
                const moneypunct<char_type, true> &__mp = use_facet<moneypunct<char_type, true> >(__loc);
                if (__neg) {
                    __pat = __mp.neg_format();
                    __sn = __mp.negative_sign();
                } else {
                    __pat = __mp.pos_format();
                    __sn = __mp.positive_sign();
                }
                __dp = __mp.decimal_point();
                __ts = __mp.thousands_sep();
                __grp = __mp.grouping();
                __sym = __mp.curr_symbol();
                __fd = __mp.frac_digits();
            } else {
                const moneypunct<char_type, false> &__mp = use_facet<moneypunct<char_type, false> >(__loc);
                if (__neg) {
                    __pat = __mp.neg_format();
                    __sn = __mp.negative_sign();
                } else {
                    __pat = __mp.pos_format();
                    __sn = __mp.positive_sign();
                }
                __dp = __mp.decimal_point();
                __ts = __mp.thousands_sep();
                __grp = __mp.grouping();
                __sym = __mp.curr_symbol();
                __fd = __mp.frac_digits();
            }
        }


        void __format(char_type *__mb, char_type *&__mi, char_type *&__me, ios_base::fmtflags __flags, const char_type *__db, const char_type *__de, const ctype<char_type> &__ct, bool __neg, const money_base::pattern &__pat, char_type __dp, char_type __ts, const string &__grp, const string_type &__sym, const string_type &__sn, int __fd)         {
            __me = __mb;
            for (unsigned int __p = 0; __p < 4; ++__p) {
                switch (__pat.field[__p]) {
                  case money_base::none:
                    __mi = __me;
                    break;
                  case money_base::space:
                    __mi = __me;
                    *__me++ = __ct.widen(' ');
                    break;
                  case money_base::sign:
                    if (!__sn.empty())
                        *__me++ = __sn[0];
                    break;
                  case money_base::symbol:
                    if (!__sym.empty() && (__flags & ios_base::showbase))
                        __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
                    break;
                  case money_base::value:
                    {
                        char_type *__t = __me;
                        if (__neg)
                            ++__db;
                        const char_type *__d;
                        for (__d = __db; __d < __de; ++__d) 
                            if (!__ct.is(ctype_base::digit, *__d))
                                break;
                        if (__fd > 0) {
                            int __f;
                            for (__f = __fd; __d > __db && __f > 0; --__f) 
                                *__me++ = *--__d;
                            char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                            for (; __f > 0; --__f) 
                                *__me++ = __z;
                            *__me++ = __dp;
                        }
                        if (__d == __db) {
                            *__me++ = __ct.widen('0');
                        } else {
                            unsigned int __ng = 0;
                            unsigned int __ig = 0;
                            unsigned int __gl = __grp.empty() ? numeric_limits<unsigned int>::max() : static_cast<unsigned int>(__grp[__ig]);
                            while (__d != __db)
                                {
                                    if (__ng == __gl) {
                                        *__me++ = __ts;
                                        __ng = 0;
                                        if (++__ig < __grp.size())
                                            __gl = __grp[__ig] == numeric_limits<char>::max() ? numeric_limits<unsigned int>::max() : static_cast<unsigned int>(__grp[__ig]);
                                    }
                                    *__me++ = *--__d;
                                    ++__ng;
                                }
                        }
                        reverse(__t, __me);
                    }
                    break;
                }
            }
            if (__sn.size() > 1)
                __me = std::__1::copy(__sn.begin() + 1, __sn.end(), __me);
            if ((__flags & ios_base::adjustfield) == ios_base::left)
                __mi = __me;
            else if ((__flags & ios_base::adjustfield) != ios_base::internal)
                __mi = __mb;
        }


        class __attribute__((type_visibility("default"))) __money_put {
        protected:
            typedef char char_type;
            typedef basic_string<char_type> string_type;
            __money_put() __attribute__((always_inline));
            static void __gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__sn, int &__fd);
            static void __format(char_type *__mb, char_type *&__mi, char_type *&__me, ios_base::fmtflags __flags, const char_type *__db, const char_type *__de, const ctype<char_type> &__ct, bool __neg, const money_base::pattern &__pat, char_type __dp, char_type __ts, const string &__grp, const string_type &__sym, const string_type &__sn, int __fd);
        };
        class __attribute__((type_visibility("default"))) __money_put {
        protected:
            typedef wchar_t char_type;
            typedef basic_string<char_type> string_type;
            __money_put() __attribute__((always_inline));
            static void __gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, char_type &__dp, char_type &__ts, string &__grp, string_type &__sym, string_type &__sn, int &__fd);
            static void __format(char_type *__mb, char_type *&__mi, char_type *&__me, ios_base::fmtflags __flags, const char_type *__db, const char_type *__de, const ctype<char_type> &__ct, bool __neg, const money_base::pattern &__pat, char_type __dp, char_type __ts, const string &__grp, const string_type &__sym, const string_type &__sn, int __fd);
        };
        template <class _CharT = char, class _OutputIterator = std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >> class __attribute__((type_visibility("default"))) money_put : public locale::facet, private __money_put<char> {
        public:
            typedef char char_type;
            typedef std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const __attribute__((always_inline));
            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::money_put<char>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const;
            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const;
        }
template <class _CharT = wchar_t, class _OutputIterator = std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> >> class __attribute__((type_visibility("default"))) money_put : public locale::facet, private __money_put<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const __attribute__((always_inline));
            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::money_put<wchar_t>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const;
            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const;
        }
template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) money_put : public locale::facet, private __money_put<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _OutputIterator iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_put<_CharT, _OutputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __intl, __iob, __fl, __units);
            }


            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return do_put(__s, __intl, __iob, __fl, __digits);
            }


            static locale::id id;
        protected:
            ~money_put<_CharT, _OutputIterator>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const;
            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const;
        };
        locale::id id;
        _OutputIterator do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const         {
            const size_t __bs = 100;
            char __buf[100];
            char *__bb = __buf;
            char_type __digits[100];
            char_type *__db = __digits;
            size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
            unique_ptr<char, void (*)(void *)> __hn(0, free);
            unique_ptr<char_type, void (*)(void *)> __hd(0, free);
            if (__n > __bs - 1) {
                __n = static_cast<size_t>(asprintf_l(&__bb, 0, "%.0Lf", __units));
                if (__bb == 0)
                    __throw_bad_alloc();
                __hn.reset(__bb);
                __hd.reset((char_type *)malloc(__n * sizeof(char_type)));
                if (__hd == nullptr)
                    __throw_bad_alloc();
                __db = __hd.get();
            }
            std::__1::locale __loc = __iob.getloc();
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__loc);
            __ct.widen(__bb, __bb + __n, __db);
            bool __neg = __n > 0 && __bb[0] == '-';
            money_base::pattern __pat;
            char_type __dp;
            char_type __ts;
            string __grp;
            string_type __sym;
            string_type __sn;
            int __fd;
            this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
            char_type __mbuf[100];
            char_type *__mb = __mbuf;
            unique_ptr<char_type, void (*)(void *)> __hw(0, free);
            size_t __exn = static_cast<int>(__n) > __fd ? (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
            if (__exn > __bs) {
                __hw.reset((char_type *)malloc(__exn * sizeof(char_type)));
                __mb = __hw.get();
                if (__mb == 0)
                    __throw_bad_alloc();
            }
            char_type *__mi;
            char_type *__me;
            this->__format(__mb, __mi, __me, __iob.flags(), __db, __db + __n, __ct, __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
            return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
        }


        _OutputIterator do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const         {
            std::__1::locale __loc = __iob.getloc();
            const ctype<char_type> &__ct = use_facet<ctype<char_type> >(__loc);
            bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
            money_base::pattern __pat;
            char_type __dp;
            char_type __ts;
            string __grp;
            string_type __sym;
            string_type __sn;
            int __fd;
            this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
            char_type __mbuf[100];
            char_type *__mb = __mbuf;
            unique_ptr<char_type, void (*)(void *)> __h(0, free);
            size_t __exn = static_cast<int>(__digits.size()) > __fd ? (__digits.size() - static_cast<size_t>(__fd)) * 2 + __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
            if (__exn > 100) {
                __h.reset((char_type *)malloc(__exn * sizeof(char_type)));
                __mb = __h.get();
                if (__mb == 0)
                    __throw_bad_alloc();
            }
            char_type *__mi;
            char_type *__me;
            this->__format(__mb, __mi, __me, __iob.flags(), __digits.data(), __digits.data() + __digits.size(), __ct, __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
            return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
        }


        class __attribute__((type_visibility("default"))) money_put : public locale::facet, private __money_put<char> {
        public:
            typedef char char_type;
            typedef std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const __attribute__((always_inline));
            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::money_put<char>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const;
            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const;
        };
        class __attribute__((type_visibility("default"))) money_put : public locale::facet, private __money_put<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef basic_string<char_type> string_type;
            explicit money_put(size_t __refs) __attribute__((always_inline));
            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const __attribute__((always_inline));
            iter_type put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::money_put<wchar_t>() noexcept __attribute__((always_inline));
            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, long double __units) const;
            virtual iter_type do_put(iter_type __s, bool __intl, std::__1::ios_base &__iob, char_type __fl, const string_type &__digits) const;
        };
        class __attribute__((type_visibility("default"))) messages_base {
        public:
            typedef ptrdiff_t catalog;
            messages_base() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        template <class _CharT = char> class __attribute__((type_visibility("default"))) messages : public locale::facet, public std::__1::messages_base {
        public:
            typedef char char_type;
            typedef basic_string<char> string_type;
            explicit messages(size_t __refs) __attribute__((always_inline));
            catalog open(const basic_string<char> &__nm, const std::__1::locale &__loc) const __attribute__((always_inline));
            string_type get(catalog __c, int __set, int __msgid, const string_type &__dflt) const __attribute__((always_inline));
            void close(catalog __c) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::messages<char>() noexcept __attribute__((always_inline));
            virtual catalog do_open(const basic_string<char> &, const std::__1::locale &) const;
            virtual string_type do_get(catalog, int __set, int __msgid, const string_type &__dflt) const;
            virtual void do_close(catalog) const;
        }
template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) messages : public locale::facet, public std::__1::messages_base {
        public:
            typedef wchar_t char_type;
            typedef basic_string<wchar_t> string_type;
            explicit messages(size_t __refs) __attribute__((always_inline));
            catalog open(const basic_string<char> &__nm, const std::__1::locale &__loc) const __attribute__((always_inline));
            string_type get(catalog __c, int __set, int __msgid, const string_type &__dflt) const __attribute__((always_inline));
            void close(catalog __c) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::messages<wchar_t>() noexcept __attribute__((always_inline));
            virtual catalog do_open(const basic_string<char> &, const std::__1::locale &) const;
            virtual string_type do_get(catalog, int __set, int __msgid, const string_type &__dflt) const;
            virtual void do_close(catalog) const;
        }
template <class _CharT> class __attribute__((type_visibility("default"))) messages : public locale::facet, public std::__1::messages_base {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            explicit messages<_CharT>(size_t __refs = 0) : locale::facet(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            catalog open(const basic_string<char> &__nm, const std::__1::locale &__loc) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_open(__nm, __loc);
            }


            string_type get(catalog __c, int __set, int __msgid, const string_type &__dflt) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->do_get(__c, __set, __msgid, __dflt);
            }


            void close(catalog __c) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                this->do_close(__c);
            }


            static locale::id id;
        protected:
            ~messages<_CharT>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            virtual catalog do_open(const basic_string<char> &, const std::__1::locale &) const;
            virtual string_type do_get(catalog, int __set, int __msgid, const string_type &__dflt) const;
            virtual void do_close(catalog) const;
        };
        locale::id id;
        typename messages<_CharT>::catalog do_open(const basic_string<char> &__nm, const std::__1::locale &) const         {
            catalog __cat = (catalog)catopen(__nm.c_str(), 1);
            if (__cat != -1)
                __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
            return __cat;
        }


        typename messages<_CharT>::string_type do_get(catalog __c, int __set, int __msgid, const string_type &__dflt) const         {
            string __ndflt;
            __narrow_to_utf8<sizeof(char_type) * 8>()(back_inserter(__ndflt), __dflt.c_str(), __dflt.c_str() + __dflt.size());
            if (__c != -1)
                __c <<= 1;
            nl_catd __cat = (nl_catd)__c;
            char *__n = catgets(__cat, __set, __msgid, __ndflt.c_str());
            string_type __w;
            __widen_from_utf8<sizeof(char_type) * 8>()(back_inserter(__w), __n, __n + strlen(__n));
            return __w;
        }


        void do_close(catalog __c) const         {
            if (__c != -1)
                __c <<= 1;
            nl_catd __cat = (nl_catd)__c;
            catclose(__cat);
        }


        class __attribute__((type_visibility("default"))) messages : public locale::facet, public std::__1::messages_base {
        public:
            typedef char char_type;
            typedef basic_string<char> string_type;
            explicit messages(size_t __refs) __attribute__((always_inline));
            catalog open(const basic_string<char> &__nm, const std::__1::locale &__loc) const __attribute__((always_inline));
            string_type get(catalog __c, int __set, int __msgid, const string_type &__dflt) const __attribute__((always_inline));
            void close(catalog __c) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::messages<char>() noexcept __attribute__((always_inline));
            virtual catalog do_open(const basic_string<char> &, const std::__1::locale &) const;
            virtual string_type do_get(catalog, int __set, int __msgid, const string_type &__dflt) const;
            virtual void do_close(catalog) const;
        };
        class __attribute__((type_visibility("default"))) messages : public locale::facet, public std::__1::messages_base {
        public:
            typedef wchar_t char_type;
            typedef basic_string<wchar_t> string_type;
            explicit messages(size_t __refs) __attribute__((always_inline));
            catalog open(const basic_string<char> &__nm, const std::__1::locale &__loc) const __attribute__((always_inline));
            string_type get(catalog __c, int __set, int __msgid, const string_type &__dflt) const __attribute__((always_inline));
            void close(catalog __c) const __attribute__((always_inline));
            static locale::id id;
        protected:
            ~std::__1::messages<wchar_t>() noexcept __attribute__((always_inline));
            virtual catalog do_open(const basic_string<char> &, const std::__1::locale &) const;
            virtual string_type do_get(catalog, int __set, int __msgid, const string_type &__dflt) const;
            virtual void do_close(catalog) const;
        };
        template <class _CharT = char> class __attribute__((type_visibility("default"))) messages_byname : public messages<char> {
        public:
            typedef messages_base::catalog catalog;
            typedef basic_string<char> string_type;
            explicit messages_byname(const char *, size_t __refs) __attribute__((always_inline));
            explicit messages_byname(const string &, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::messages_byname<char>() noexcept __attribute__((always_inline));
        }
template <class _CharT = wchar_t> class __attribute__((type_visibility("default"))) messages_byname : public messages<wchar_t> {
        public:
            typedef messages_base::catalog catalog;
            typedef basic_string<wchar_t> string_type;
            explicit messages_byname(const char *, size_t __refs) __attribute__((always_inline));
            explicit messages_byname(const string &, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::messages_byname<wchar_t>() noexcept __attribute__((always_inline));
        }
template <class _CharT> class __attribute__((type_visibility("default"))) messages_byname : public messages<_CharT> {
        public:
            typedef messages_base::catalog catalog;
            typedef basic_string<_CharT> string_type;
            explicit messages_byname<_CharT>(const char *, size_t __refs = 0) : messages<_CharT>(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            explicit messages_byname<_CharT>(const string &, size_t __refs = 0) : messages<_CharT>(__refs) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        protected:
            ~messages_byname<_CharT>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        class __attribute__((type_visibility("default"))) messages_byname : public messages<char> {
        public:
            typedef messages_base::catalog catalog;
            typedef basic_string<char> string_type;
            explicit messages_byname(const char *, size_t __refs) __attribute__((always_inline));
            explicit messages_byname(const string &, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::messages_byname<char>() noexcept __attribute__((always_inline));
        };
        class __attribute__((type_visibility("default"))) messages_byname : public messages<wchar_t> {
        public:
            typedef messages_base::catalog catalog;
            typedef basic_string<wchar_t> string_type;
            explicit messages_byname(const char *, size_t __refs) __attribute__((always_inline));
            explicit messages_byname(const string &, size_t __refs) __attribute__((always_inline));
        protected:
            ~std::__1::messages_byname<wchar_t>() noexcept __attribute__((always_inline));
        };
        template <class _Codecvt, class _Elem = wchar_t, class _Wide_alloc = allocator<_Elem>, class _Byte_alloc = allocator<char>> class __attribute__((type_visibility("default"))) wstring_convert {
        public:
            typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
            typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
            typedef typename _Codecvt::state_type state_type;
            typedef typename wide_string::traits_type::int_type int_type;
        private:
            byte_string __byte_err_string_;
            wide_string __wide_err_string_;
            _Codecvt *__cvtptr_;
            state_type __cvtstate_;
            size_t __cvtcount_;
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(const wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &__wc);
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &operator=(const wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &__wc);
        public:
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(_Codecvt *__pcvt = new _Codecvt) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(_Codecvt *__pcvt, state_type __state) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(const byte_string &__byte_err, const wide_string &__wide_err = wide_string());
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &&__wc) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            ~wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>();
            wide_string from_bytes(char __byte) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return from_bytes(&__byte, &__byte + 1);
            }


            wide_string from_bytes(const char *__ptr) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));
            }


            wide_string from_bytes(const byte_string &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return from_bytes(__str.data(), __str.data() + __str.size());
            }


            wide_string from_bytes(const char *__first, const char *__last);
            byte_string to_bytes(_Elem __wchar) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return to_bytes(&__wchar, &__wchar + 1);
            }


            byte_string to_bytes(const _Elem *__wptr) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));
            }


            byte_string to_bytes(const wide_string &__wstr) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());
            }


            byte_string to_bytes(const _Elem *__first, const _Elem *__last);
            size_t converted() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cvtcount_;
            }


            state_type state() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__cvtstate_;
            }


        };
        inline wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(_Codecvt *__pcvt = new _Codecvt) : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(_Codecvt *__pcvt, state_type __state) : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(const byte_string &__byte_err, const wide_string &__wide_err = wide_string()) : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err), __cvtstate_(), __cvtcount_(0)         {
            this->__cvtptr_ = new _Codecvt;
        }


        inline wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &&__wc) : __byte_err_string_(std::__1::move(__wc.__byte_err_string_)), __wide_err_string_(std::__1::move(__wc.__wide_err_string_)), __cvtptr_(__wc.__cvtptr_), __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtstate_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __wc.__cvtptr_ = nullptr;
        }


        ~wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>()         {
            delete this->__cvtptr_;
        }


        typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string from_bytes(const char *__frm, const char *__frm_end)         {
            this->__cvtcount_ = 0;
            if (this->__cvtptr_ != nullptr) {
                wide_string __ws(2 * (__frm_end - __frm), _Elem());
                if (__frm != __frm_end)
                    __ws.resize(__ws.capacity());
                codecvt_base::result __r = codecvt_base::ok;
                state_type __st = this->__cvtstate_;
                if (__frm != __frm_end) {
                    _Elem *__to = &__ws[0];
                    _Elem *__to_end = __to + __ws.size();
                    const char *__frm_nxt;
                    do {
                        _Elem *__to_nxt;
                        __r = this->__cvtptr_->in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
                        this->__cvtcount_ += __frm_nxt - __frm;
                        if (__frm_nxt == __frm) {
                            __r = codecvt_base::error;
                        } else if (__r == codecvt_base::noconv) {
                            __ws.resize(__to - &__ws[0]);
                            __ws.append((const _Elem *)__frm, (const _Elem *)__frm_end);
                            __frm = __frm_nxt;
                            __r = codecvt_base::ok;
                        } else if (__r == codecvt_base::ok) {
                            __ws.resize(__to_nxt - &__ws[0]);
                            __frm = __frm_nxt;
                        } else if (__r == codecvt_base::partial) {
                            ptrdiff_t __s = __to_nxt - &__ws[0];
                            __ws.resize(2 * __s);
                            __to = &__ws[0] + __s;
                            __to_end = &__ws[0] + __ws.size();
                            __frm = __frm_nxt;
                        }
                    } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
                }
                if (__r == codecvt_base::ok)
                    return __ws;
            }
            if (this->__wide_err_string_.empty())
                throw std::range_error("wstring_convert: from_bytes error");
            return this->__wide_err_string_;
        }


        typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string to_bytes(const _Elem *__frm, const _Elem *__frm_end)         {
            this->__cvtcount_ = 0;
            if (this->__cvtptr_ != nullptr) {
                byte_string __bs(2 * (__frm_end - __frm), char());
                if (__frm != __frm_end)
                    __bs.resize(__bs.capacity());
                codecvt_base::result __r = codecvt_base::ok;
                state_type __st = this->__cvtstate_;
                if (__frm != __frm_end) {
                    char *__to = &__bs[0];
                    char *__to_end = __to + __bs.size();
                    const _Elem *__frm_nxt;
                    do {
                        char *__to_nxt;
                        __r = this->__cvtptr_->out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
                        this->__cvtcount_ += __frm_nxt - __frm;
                        if (__frm_nxt == __frm) {
                            __r = codecvt_base::error;
                        } else if (__r == codecvt_base::noconv) {
                            __bs.resize(__to - &__bs[0]);
                            __bs.append((const char *)__frm, (const char *)__frm_end);
                            __frm = __frm_nxt;
                            __r = codecvt_base::ok;
                        } else if (__r == codecvt_base::ok) {
                            __bs.resize(__to_nxt - &__bs[0]);
                            __frm = __frm_nxt;
                        } else if (__r == codecvt_base::partial) {
                            ptrdiff_t __s = __to_nxt - &__bs[0];
                            __bs.resize(2 * __s);
                            __to = &__bs[0] + __s;
                            __to_end = &__bs[0] + __bs.size();
                            __frm = __frm_nxt;
                        }
                    } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
                }
                if (__r == codecvt_base::ok) {
                    size_t __s = __bs.size();
                    __bs.resize(__bs.capacity());
                    char *__to = &__bs[0] + __s;
                    char *__to_end = __to + __bs.size();
                    do {
                        char *__to_nxt;
                        __r = this->__cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                        if (__r == codecvt_base::noconv) {
                            __bs.resize(__to - &__bs[0]);
                            __r = codecvt_base::ok;
                        } else if (__r == codecvt_base::ok) {
                            __bs.resize(__to_nxt - &__bs[0]);
                        } else if (__r == codecvt_base::partial) {
                            ptrdiff_t __sp = __to_nxt - &__bs[0];
                            __bs.resize(2 * __sp);
                            __to = &__bs[0] + __sp;
                            __to_end = &__bs[0] + __bs.size();
                        }
                    } while (__r == codecvt_base::partial);
                    if (__r == codecvt_base::ok)
                        return __bs;
                }
            }
            if (this->__byte_err_string_.empty())
                throw std::range_error("wstring_convert: to_bytes error");
            return this->__byte_err_string_;
        }


        template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem>> class __attribute__((type_visibility("default"))) wbuffer_convert : public basic_streambuf<_Elem, _Tr> {
        public:
            typedef _Elem char_type;
            typedef _Tr traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef typename _Codecvt::state_type state_type;
        private:
            char *__extbuf_;
            const char *__extbufnext_;
            const char *__extbufend_;
            char __extbuf_min_[8];
            size_t __ebs_;
            char_type *__intbuf_;
            size_t __ibs_;
            streambuf *__bufptr_;
            _Codecvt *__cv_;
            state_type __st_;
            ios_base::openmode __cm_;
            bool __owns_eb_;
            bool __owns_ib_;
            bool __always_noconv_;
            wbuffer_convert<_Codecvt, _Elem, _Tr>(const wbuffer_convert<_Codecvt, _Elem, _Tr> &);
            wbuffer_convert<_Codecvt, _Elem, _Tr> &operator=(const wbuffer_convert<_Codecvt, _Elem, _Tr> &);
        public:
            wbuffer_convert<_Codecvt, _Elem, _Tr>(streambuf *__bytebuf = 0, _Codecvt *__pcvt = new _Codecvt, state_type __state = state_type());
            ~wbuffer_convert<_Codecvt, _Elem, _Tr>();
            streambuf *rdbuf() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__bufptr_;
            }


            streambuf *rdbuf(streambuf *__bytebuf) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                streambuf *__r = this->__bufptr_;
                this->__bufptr_ = __bytebuf;
                return __r;
            }


            state_type state() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__st_;
            }


        protected:
            virtual int_type underflow();
            virtual int_type pbackfail(int_type __c = traits_type::eof());
            virtual int_type overflow(int_type __c = traits_type::eof());
            virtual basic_streambuf<char_type, traits_type> *setbuf(char_type *__s, streamsize __n);
            virtual pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __wch = ios_base::in | ios_base::out);
            virtual pos_type seekpos(pos_type __sp, ios_base::openmode __wch = ios_base::in | ios_base::out);
            virtual int sync();
        private:
            bool __read_mode();
            void __write_mode();
            wbuffer_convert<_Codecvt, _Elem, _Tr> *__close();
        };
        wbuffer_convert<_Codecvt, _Elem, _Tr>(streambuf *__bytebuf = 0, _Codecvt *__pcvt = new _Codecvt, state_type __state = state_type()) : __extbuf_(0), __extbufnext_(0), __extbufend_(0), __ebs_(0), __intbuf_(0), __ibs_(0), __bufptr_(__bytebuf), __cv_(__pcvt), __st_(__state), __cm_(0), __owns_eb_(false), __owns_ib_(false), __always_noconv_(this->__cv_ ? this->__cv_->always_noconv() : false)         {
            this->setbuf(0, 4096);
        }


        ~wbuffer_convert<_Codecvt, _Elem, _Tr>()         {
            this->__close();
            delete this->__cv_;
            if (this->__owns_eb_)
                delete [] this->__extbuf_;
            if (this->__owns_ib_)
                delete [] this->__intbuf_;
        }


        typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type underflow()         {
            if (this->__cv_ == 0 || this->__bufptr_ == 0)
                return traits_type::eof();
            bool __initial = this->__read_mode();
            char_type __1buf;
            if (this->gptr() == 0)
                this->setg(&__1buf, &__1buf + 1, &__1buf + 1);
            const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
            int_type __c = traits_type::eof();
            if (this->gptr() == this->egptr()) {
                memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
                if (this->__always_noconv_) {
                    streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
                    __nmemb = this->__bufptr_->sgetn((char *)this->eback() + __unget_sz, __nmemb);
                    if (__nmemb != 0) {
                        this->setg(this->eback(), this->eback() + __unget_sz, this->eback() + __unget_sz + __nmemb);
                        __c = *this->gptr();
                    }
                } else {
                    memmove(this->__extbuf_, this->__extbufnext_, this->__extbufend_ - this->__extbufnext_);
                    this->__extbufnext_ = this->__extbuf_ + (this->__extbufend_ - this->__extbufnext_);
                    this->__extbufend_ = this->__extbuf_ + (this->__extbuf_ == this->__extbuf_min_ ? sizeof (this->__extbuf_min_) : this->__ebs_);
                    streamsize __nmemb = std::__1::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz), static_cast<streamsize>(this->__extbufend_ - this->__extbufnext_));
                    codecvt_base::result __r;
                    state_type __svs = this->__st_;
                    streamsize __nr = this->__bufptr_->sgetn(const_cast<char *>(this->__extbufnext_), __nmemb);
                    if (__nr != 0) {
                        this->__extbufend_ = this->__extbufnext_ + __nr;
                        char_type *__inext;
                        __r = this->__cv_->in(this->__st_, this->__extbuf_, this->__extbufend_, this->__extbufnext_, this->eback() + __unget_sz, this->egptr(), __inext);
                        if (__r == codecvt_base::noconv) {
                            this->setg((char_type *)this->__extbuf_, (char_type *)this->__extbuf_, (char_type *)this->__extbufend_);
                            __c = *this->gptr();
                        } else if (__inext != this->eback() + __unget_sz) {
                            this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                            __c = *this->gptr();
                        }
                    }
                }
            } else
                __c = *this->gptr();
            if (this->eback() == &__1buf)
                this->setg(0, 0, 0);
            return __c;
        }


        typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type pbackfail(int_type __c = traits_type::eof())         {
            if (this->__cv_ != 0 && this->__bufptr_ != 0 && this->eback() < this->gptr()) {
                if (traits_type::eq_int_type(__c, traits_type::eof())) {
                    this->gbump(-1);
                    return traits_type::not_eof(__c);
                }
                if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])) {
                    this->gbump(-1);
                    *this->gptr() = traits_type::to_char_type(__c);
                    return __c;
                }
            }
            return traits_type::eof();
        }


        typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type overflow(int_type __c = traits_type::eof())         {
            if (this->__cv_ == 0 || this->__bufptr_ == 0)
                return traits_type::eof();
            this->__write_mode();
            char_type __1buf;
            char_type *__pb_save = this->pbase();
            char_type *__epb_save = this->epptr();
            if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                if (this->pptr() == 0)
                    this->setp(&__1buf, &__1buf + 1);
                *this->pptr() = traits_type::to_char_type(__c);
                this->pbump(1);
            }
            if (this->pptr() != this->pbase()) {
                if (this->__always_noconv_) {
                    streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
                    if (this->__bufptr_->sputn((const char *)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                } else {
                    char *__extbe = this->__extbuf_;
                    codecvt_base::result __r;
                    do {
                        const char_type *__e;
                        __r = this->__cv_->out(this->__st_, this->pbase(), this->pptr(), __e, this->__extbuf_, this->__extbuf_ + this->__ebs_, __extbe);
                        if (__e == this->pbase())
                            return traits_type::eof();
                        if (__r == codecvt_base::noconv) {
                            streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                            if (this->__bufptr_->sputn((const char *)this->pbase(), __nmemb) != __nmemb)
                                return traits_type::eof();
                        } else if (__r == codecvt_base::ok || __r == codecvt_base::partial) {
                            streamsize __nmemb = static_cast<size_t>(__extbe - this->__extbuf_);
                            if (this->__bufptr_->sputn(this->__extbuf_, __nmemb) != __nmemb)
                                return traits_type::eof();
                            if (__r == codecvt_base::partial) {
                                this->setp((char_type *)__e, this->pptr());
                                this->pbump(this->epptr() - this->pbase());
                            }
                        } else
                            return traits_type::eof();
                    } while (__r == codecvt_base::partial);
                }
                this->setp(__pb_save, __epb_save);
            }
            return traits_type::not_eof(__c);
        }


        basic_streambuf<_Elem, _Tr> *setbuf(char_type *__s, streamsize __n)         {
            this->setg(0, 0, 0);
            this->setp(0, 0);
            if (this->__owns_eb_)
                delete [] this->__extbuf_;
            if (this->__owns_ib_)
                delete [] this->__intbuf_;
            this->__ebs_ = __n;
            if (this->__ebs_ > sizeof (this->__extbuf_min_)) {
                if (this->__always_noconv_ && __s) {
                    this->__extbuf_ = (char *)__s;
                    this->__owns_eb_ = false;
                } else {
                    this->__extbuf_ = new char [this->__ebs_];
                    this->__owns_eb_ = true;
                }
            } else {
                this->__extbuf_ = this->__extbuf_min_;
                this->__ebs_ = sizeof (this->__extbuf_min_);
                this->__owns_eb_ = false;
            }
            if (!this->__always_noconv_) {
                this->__ibs_ = max<streamsize>(__n, sizeof (this->__extbuf_min_));
                if (__s && this->__ibs_ >= sizeof (this->__extbuf_min_)) {
                    this->__intbuf_ = __s;
                    this->__owns_ib_ = false;
                } else {
                    this->__intbuf_ = new char_type [this->__ibs_];
                    this->__owns_ib_ = true;
                }
            } else {
                this->__ibs_ = 0;
                this->__intbuf_ = 0;
                this->__owns_ib_ = false;
            }
            return this;
        }


        typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __om = ios_base::in | ios_base::out)         {
            int __width = this->__cv_->encoding();
            if (this->__cv_ == 0 || this->__bufptr_ == 0 || (__width <= 0 && __off != 0) || this->sync())
                return pos_type(off_type(-1));
            if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
                return pos_type(off_type(-1));
            pos_type __r = this->__bufptr_->pubseekoff(__width * __off, __way, __om);
            __r.state(this->__st_);
            return __r;
        }


        typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type seekpos(pos_type __sp, ios_base::openmode __wch = ios_base::in | ios_base::out)         {
            if (this->__cv_ == 0 || this->__bufptr_ == 0 || this->sync())
                return pos_type(off_type(-1));
            if (this->__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
                return pos_type(off_type(-1));
            return __sp;
        }


        int sync()         {
            if (this->__cv_ == 0 || this->__bufptr_ == 0)
                return 0;
            if (this->__cm_ & ios_base::out) {
                if (this->pptr() != this->pbase())
                    if (this->overflow() == traits_type::eof())
                        return -1;
                codecvt_base::result __r;
                do {
                    char *__extbe;
                    __r = this->__cv_->unshift(this->__st_, this->__extbuf_, this->__extbuf_ + this->__ebs_, __extbe);
                    streamsize __nmemb = static_cast<streamsize>(__extbe - this->__extbuf_);
                    if (this->__bufptr_->sputn(this->__extbuf_, __nmemb) != __nmemb)
                        return -1;
                } while (__r == codecvt_base::partial);
                if (__r == codecvt_base::error)
                    return -1;
                if (this->__bufptr_->pubsync())
                    return -1;
            } else if (this->__cm_ & ios_base::in) {
                off_type __c;
                if (this->__always_noconv_)
                    __c = this->egptr() - this->gptr();
                else {
                    int __width = this->__cv_->encoding();
                    __c = this->__extbufend_ - this->__extbufnext_;
                    if (__width > 0)
                        __c += __width * (this->egptr() - this->gptr());
                    else {
                        if (this->gptr() != this->egptr()) {
                            reverse(this->gptr(), this->egptr());
                            codecvt_base::result __r;
                            const char_type *__e = this->gptr();
                            char *__extbe;
                            do {
                                __r = this->__cv_->out(this->__st_, __e, this->egptr(), __e, this->__extbuf_, this->__extbuf_ + this->__ebs_, __extbe);
                                switch (__r) {
                                  case codecvt_base::noconv:
                                    __c += this->egptr() - this->gptr();
                                    break;
                                  case codecvt_base::ok:
                                  case codecvt_base::partial:
                                    __c += __extbe - this->__extbuf_;
                                    break;
                                  default:
                                    return -1;
                                }
                            } while (__r == codecvt_base::partial);
                        }
                    }
                }
                if (this->__bufptr_->pubseekoff(- __c, ios_base::cur, this->__cm_) == pos_type(off_type(-1)))
                    return -1;
                this->setg(0, 0, 0);
                this->__cm_ = 0;
            }
            return 0;
        }


        bool __read_mode()         {
            if (!(this->__cm_ & ios_base::in)) {
                this->setp(0, 0);
                if (this->__always_noconv_)
                    this->setg((char_type *)this->__extbuf_, (char_type *)this->__extbuf_ + this->__ebs_, (char_type *)this->__extbuf_ + this->__ebs_);
                else
                    this->setg(this->__intbuf_, this->__intbuf_ + this->__ibs_, this->__intbuf_ + this->__ibs_);
                this->__cm_ = ios_base::in;
                return true;
            }
            return false;
        }


        void __write_mode()         {
            if (!(this->__cm_ & ios_base::out)) {
                this->setg(0, 0, 0);
                if (this->__ebs_ > sizeof (this->__extbuf_min_)) {
                    if (this->__always_noconv_)
                        this->setp((char_type *)this->__extbuf_, (char_type *)this->__extbuf_ + (this->__ebs_ - 1));
                    else
                        this->setp(this->__intbuf_, this->__intbuf_ + (this->__ibs_ - 1));
                } else
                    this->setp(0, 0);
                this->__cm_ = ios_base::out;
            }
        }


        wbuffer_convert<_Codecvt, _Elem, _Tr> *__close()         {
            wbuffer_convert<_Codecvt, _Elem, _Tr> *__rt = 0;
            if (this->__cv_ != 0 && this->__bufptr_ != 0) {
                __rt = this;
                if ((this->__cm_ & ios_base::out) && this->sync())
                    __rt = 0;
            }
            return __rt;
        }


    }
}
namespace std {
    inline namespace __1 {
        template <class _Cp = std::__1::__bitset<0, 0>, bool _IsConst = false, typename _Cp::__storage_type = 0> class __bit_iterator {
        public:
            typedef typename __bitset<0, 0>::difference_type difference_type;
            typedef bool value_type;
            typedef std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> pointer;
            typedef typename conditional<false, __bit_const_reference<__bitset<0, 0> >, __bit_reference<__bitset<0, 0> > >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename conditional<false, typename __bitset<0, 0>::__const_storage_pointer, typename __bitset<0, 0>::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = __bitset<0, 0>::__bits_per_word;
            __storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator() noexcept __attribute__((always_inline));
            __bit_iterator(const __bit_iterator<std::__1::__bitset<0, 0>, false> &__it) noexcept : __seg_(__it.__seg_), __ctz_(__it.__ctz_) __attribute__((always_inline))             {
            }


            reference operator*() const noexcept __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator++() __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator++(int) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator--() __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator--(int) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator+=(difference_type __n) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator-=(difference_type __n) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator+(difference_type __n) const __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator-(difference_type __n) const __attribute__((always_inline));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator+(difference_type __n, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__it) __attribute__((always_inline));
            friend difference_type operator-(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            reference operator[](difference_type __n) const __attribute__((always_inline));
            friend bool operator==(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator!=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator<(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator>(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator<=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator>=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
        private:
            __bit_iterator(__storage_pointer __s, unsigned int __ctz) noexcept : __seg_(__s), __ctz_(__ctz) __attribute__((always_inline))             {
            }


            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        }
template <class _Cp = std::__1::__bitset<0, 0>, bool _IsConst = true, typename _Cp::__storage_type = 0> class __bit_iterator {
        public:
            typedef typename __bitset<0, 0>::difference_type difference_type;
            typedef bool value_type;
            typedef std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> pointer;
            typedef typename conditional<true, __bit_const_reference<__bitset<0, 0> >, __bit_reference<__bitset<0, 0> > >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename conditional<true, typename __bitset<0, 0>::__const_storage_pointer, typename __bitset<0, 0>::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = __bitset<0, 0>::__bits_per_word;
            __storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator() noexcept __attribute__((always_inline));
            __bit_iterator(const __bit_iterator<std::__1::__bitset<0, 0>, false> &__it) noexcept __attribute__((always_inline));
            reference operator*() const noexcept __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator++() __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator++(int) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator--() __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator--(int) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator+=(difference_type __n) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator-=(difference_type __n) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator+(difference_type __n) const __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator-(difference_type __n) const __attribute__((always_inline));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator+(difference_type __n, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__it) __attribute__((always_inline));
            friend difference_type operator-(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            reference operator[](difference_type __n) const __attribute__((always_inline));
            friend bool operator==(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator!=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator<(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator>(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator<=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator>=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
        private:
            __bit_iterator(__storage_pointer __s, unsigned int __ctz) noexcept : __seg_(__s), __ctz_(__ctz) __attribute__((always_inline))             {
            }


            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        }
template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
        template <class _Cp = std::__1::__bitset<0, 0>> class __bit_const_reference {
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename __bitset<0, 0>::__const_storage_pointer __storage_pointer;
            __storage_pointer __seg_;
            __storage_type __mask_;
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
        public:
            __bit_const_reference(const __bit_reference<std::__1::__bitset<0, 0> > &__x) noexcept __attribute__((always_inline));
            constexpr operator bool() const noexcept __attribute__((always_inline));
            __bit_iterator<std::__1::__bitset<0, 0>, true> operator&() const noexcept __attribute__((always_inline));
        private:
            constexpr __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept : __seg_(__s), __mask_(__m) __attribute__((always_inline))             {
            }


            std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &operator=(const std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &__x);
        }
template <class _Cp> class __bit_const_reference;
        template <class _Tp = std::__1::__bitset<0, 0>> struct __has_storage_type {
            static const bool value = true;
        }
template <class _Tp> struct __has_storage_type {
            static const bool value = false;
        };
        template <class _Cp = std::__1::__bitset<0, 0>, bool = true> class __bit_reference {
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename __bitset<0, 0>::__storage_pointer __storage_pointer;
            __storage_pointer __seg_;
            __storage_type __mask_;
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, false>;
        public:
            operator bool() const noexcept __attribute__((always_inline));
            bool operator~() const noexcept __attribute__((always_inline));
            std::__1::__bit_reference<std::__1::__bitset<0, 0>, true> &operator=(bool __x) noexcept __attribute__((always_inline));
            std::__1::__bit_reference<std::__1::__bitset<0, 0>, true> &operator=(const std::__1::__bit_reference<std::__1::__bitset<0, 0>, true> &__x) noexcept __attribute__((always_inline));
            void flip() noexcept __attribute__((always_inline));
            __bit_iterator<std::__1::__bitset<0, 0>, false> operator&() const noexcept __attribute__((always_inline));
        private:
            __bit_reference(__storage_pointer __s, __storage_type __m) noexcept : __seg_(__s), __mask_(__m) __attribute__((always_inline))             {
            }


        }
template <class _Cp, bool = __has_storage_type<_Cp>::value> class __bit_reference {
            typedef typename _Cp::__storage_type __storage_type;
            typedef typename _Cp::__storage_pointer __storage_pointer;
            __storage_pointer __seg_;
            __storage_type __mask_;
            friend  typename _Cp::__self;
            friend  class __bit_const_reference<_Cp>;
            friend  class __bit_iterator<_Cp, false>;
        public:
            operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<bool>(*this->__seg_ & this->__mask_);
            }


            bool operator~() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !static_cast<bool>(*this);
            }


            __bit_reference<_Cp, > &operator=(bool __x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__x)
                    *this->__seg_ |= this->__mask_;
                else
                    *this->__seg_ &= ~this->__mask_;
                return *this;
            }


            __bit_reference<_Cp, > &operator=(const __bit_reference<_Cp, > &__x) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return operator=(static_cast<bool>(__x));
            }


            void flip() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                *this->__seg_ ^= this->__mask_;
            }


            __bit_iterator<_Cp, false> operator&() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __bit_iterator<_Cp, false>(this->__seg_, static_cast<unsigned int>(__ctz(this->__mask_)));
            }


        private:
            __bit_reference<_Cp, >(__storage_pointer __s, __storage_type __m) noexcept : __seg_(__s), __mask_(__m) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        class __bit_reference {
        };
        template <class _Cp> inline void swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bool __t = __x;
            __x = __y;
            __y = __t;
        }

;
        template <class _Cp, class _Dp> inline void swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bool __t = __x;
            __x = __y;
            __y = __t;
        }

;
        template <class _Cp> inline void swap(__bit_reference<_Cp> __x, bool &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bool __t = __x;
            __x = __y;
            __y = __t;
        }

;
        template <class _Cp> inline void swap(bool &__x, __bit_reference<_Cp> __y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bool __t = __x;
            __x = __y;
            __y = __t;
        }

;
        template <class _Cp = std::__1::__bitset<0, 0>> class __bit_const_reference {
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename __bitset<0, 0>::__const_storage_pointer __storage_pointer;
            __storage_pointer __seg_;
            __storage_type __mask_;
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
        public:
            __bit_const_reference(const __bit_reference<std::__1::__bitset<0, 0> > &__x) noexcept __attribute__((always_inline));
            constexpr operator bool() const noexcept __attribute__((always_inline));
            __bit_iterator<std::__1::__bitset<0, 0>, true> operator&() const noexcept __attribute__((always_inline));
        private:
            constexpr __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept : __seg_(__s), __mask_(__m) __attribute__((always_inline))             {
            }


            std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &operator=(const std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &__x);
        }
template <class _Cp> class __bit_const_reference {
            typedef typename _Cp::__storage_type __storage_type;
            typedef typename _Cp::__const_storage_pointer __storage_pointer;
            __storage_pointer __seg_;
            __storage_type __mask_;
            friend  typename _Cp::__self;
            friend  class __bit_iterator<_Cp, true>;
        public:
            __bit_const_reference<_Cp>(const __bit_reference<_Cp> &__x) noexcept : __seg_(__x.__seg_), __mask_(__x.__mask_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            constexpr operator bool() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<bool>(*this->__seg_ & this->__mask_);
            }


            __bit_iterator<_Cp, true> operator&() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __bit_iterator<_Cp, true>(this->__seg_, static_cast<unsigned int>(__ctz(this->__mask_)));
            }


        private:
            constexpr __bit_const_reference<_Cp>(__storage_pointer __s, __storage_type __m) noexcept : __seg_(__s), __mask_(__m) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            __bit_const_reference<_Cp> &operator=(const __bit_const_reference<_Cp> &__x);
        };
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, _IsConst> __find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, _IsConst> _It;
            typedef typename _It::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _It::__bits_per_word;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __storage_type __b = *__first.__seg_ & __m;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__ctz(__b)));
                if (__n == __dn)
                    return __first + __n;
                __n -= __dn;
                ++__first.__seg_;
            }
            for (; __n >= __bits_per_word; ++__first.__seg_ , __n -= __bits_per_word) 
                if (*__first.__seg_)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__ctz(*__first.__seg_)));
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b = *__first.__seg_ & __m;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__ctz(__b)));
            }
            return _It(__first.__seg_, static_cast<unsigned int>(__n));
        }

;
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, _IsConst> __find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, _IsConst> _It;
            typedef typename _It::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _It::__bits_per_word;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __storage_type __b = ~*__first.__seg_ & __m;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__ctz(__b)));
                if (__n == __dn)
                    return __first + __n;
                __n -= __dn;
                ++__first.__seg_;
            }
            for (; __n >= __bits_per_word; ++__first.__seg_ , __n -= __bits_per_word) {
                __storage_type __b = ~*__first.__seg_;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__ctz(__b)));
            }
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b = ~*__first.__seg_ & __m;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__ctz(__b)));
            }
            return _It(__first.__seg_, static_cast<unsigned int>(__n));
        }

;
        template <class _Cp, bool _IsConst, class _Tp> inline __bit_iterator<_Cp, _IsConst> find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (static_cast<bool>(__value_))
                return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
            return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
        }

;
        template <class _Cp, bool _IsConst> typename __bit_iterator<_Cp, _IsConst>::difference_type __count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, _IsConst> _It;
            typedef typename _It::__storage_type __storage_type;
            typedef typename _It::difference_type difference_type;
            static const unsigned int __bits_per_word = _It::__bits_per_word;
            difference_type __r = 0;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __r = std::__1::__pop_count(*__first.__seg_ & __m);
                __n -= __dn;
                ++__first.__seg_;
            }
            for (; __n >= __bits_per_word; ++__first.__seg_ , __n -= __bits_per_word) 
                __r += std::__1::__pop_count(*__first.__seg_);
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __r += std::__1::__pop_count(*__first.__seg_ & __m);
            }
            return __r;
        }

;
        template <class _Cp, bool _IsConst> typename __bit_iterator<_Cp, _IsConst>::difference_type __count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, _IsConst> _It;
            typedef typename _It::__storage_type __storage_type;
            typedef typename _It::difference_type difference_type;
            static const unsigned int __bits_per_word = _It::__bits_per_word;
            difference_type __r = 0;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __r = std::__1::__pop_count(~*__first.__seg_ & __m);
                __n -= __dn;
                ++__first.__seg_;
            }
            for (; __n >= __bits_per_word; ++__first.__seg_ , __n -= __bits_per_word) 
                __r += std::__1::__pop_count(~*__first.__seg_);
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __r += std::__1::__pop_count(~*__first.__seg_ & __m);
            }
            return __r;
        }

;
        template <class _Cp, bool _IsConst, class _Tp> inline typename __bit_iterator<_Cp, _IsConst>::difference_type count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (static_cast<bool>(__value_))
                return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
            return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
        }

;
        template <class _Cp> void __fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, false> _It;
            typedef typename _It::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _It::__bits_per_word;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                *__first.__seg_ &= ~__m;
                __n -= __dn;
                ++__first.__seg_;
            }
            __storage_type __nw = __n / __bits_per_word;
            std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
            __n -= __nw * __bits_per_word;
            if (__n > 0) {
                __first.__seg_ += __nw;
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__first.__seg_ &= ~__m;
            }
        }

;
        template <class _Cp> void __fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, false> _It;
            typedef typename _It::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _It::__bits_per_word;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                *__first.__seg_ |= __m;
                __n -= __dn;
                ++__first.__seg_;
            }
            __storage_type __nw = __n / __bits_per_word;
            std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
            __n -= __nw * __bits_per_word;
            if (__n > 0) {
                __first.__seg_ += __nw;
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__first.__seg_ |= __m;
            }
        }

;
        template <class _Cp> inline void fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__n > 0) {
                if (__value_)
                    __fill_n_true(__first, __n);
                else
                    __fill_n_false(__first, __n);
            }
        }

;
        template <class _Cp> inline void fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
        }

;
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)         {
            typedef __bit_iterator<_Cp, _IsConst> _In;
            typedef typename _In::difference_type difference_type;
            typedef typename _In::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _In::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__first.__ctz_ != 0) {
                    unsigned int __clz = __bits_per_word - __first.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
                    __storage_type __b = *__first.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b;
                    __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__dn + __result.__ctz_) % __bits_per_word);
                    ++__first.__seg_;
                }
                __storage_type __nw = __n / __bits_per_word;
                std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_), std::__1::__to_raw_pointer(__first.__seg_), __nw * sizeof(__storage_type));
                __n -= __nw * __bits_per_word;
                __result.__seg_ += __nw;
                if (__n > 0) {
                    __first.__seg_ += __nw;
                    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b = *__first.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b;
                    __result.__ctz_ = static_cast<unsigned int>(__n);
                }
            }
            return __result;
        }

;
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)         {
            typedef __bit_iterator<_Cp, _IsConst> _In;
            typedef typename _In::difference_type difference_type;
            typedef typename _In::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _In::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__first.__ctz_ != 0) {
                    unsigned int __clz_f = __bits_per_word - __first.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                    __storage_type __b = *__first.__seg_ & __m;
                    unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                    __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
                    __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
                    *__result.__seg_ &= ~__m;
                    if (__result.__ctz_ > __first.__ctz_)
                        *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
                    else
                        *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
                    __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__ddn + __result.__ctz_) % __bits_per_word);
                    __dn -= __ddn;
                    if (__dn > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                        *__result.__seg_ &= ~__m;
                        *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                        __result.__ctz_ = static_cast<unsigned int>(__dn);
                    }
                    ++__first.__seg_;
                }
                unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                __storage_type __m = ~__storage_type(0) << __result.__ctz_;
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first.__seg_) {
                    __storage_type __b = *__first.__seg_;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b << __result.__ctz_;
                    ++__result.__seg_;
                    *__result.__seg_ &= __m;
                    *__result.__seg_ |= __b >> __clz_r;
                }
                if (__n > 0) {
                    __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b = *__first.__seg_ & __m;
                    __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
                    __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b << __result.__ctz_;
                    __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__dn + __result.__ctz_) % __bits_per_word);
                    __n -= __dn;
                    if (__n > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __n);
                        *__result.__seg_ &= ~__m;
                        *__result.__seg_ |= __b >> __dn;
                        __result.__ctz_ = static_cast<unsigned int>(__n);
                    }
                }
            }
            return __result;
        }

;
        template <class _Cp, bool _IsConst> inline __bit_iterator<_Cp, false> copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__first.__ctz_ == __result.__ctz_)
                return __copy_aligned(__first, __last, __result);
            return __copy_unaligned(__first, __last, __result);
        }

;
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)         {
            typedef __bit_iterator<_Cp, _IsConst> _In;
            typedef typename _In::difference_type difference_type;
            typedef typename _In::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _In::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__last.__ctz_ != 0) {
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
                    __n -= __dn;
                    unsigned int __clz = __bits_per_word - __last.__ctz_;
                    __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
                    __storage_type __b = *__last.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b;
                    __result.__ctz_ = static_cast<unsigned int>(((- __dn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
                }
                __storage_type __nw = __n / __bits_per_word;
                __result.__seg_ -= __nw;
                __last.__seg_ -= __nw;
                std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_), std::__1::__to_raw_pointer(__last.__seg_), __nw * sizeof(__storage_type));
                __n -= __nw * __bits_per_word;
                if (__n > 0) {
                    __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
                    __storage_type __b = *--__last.__seg_ & __m;
                    *--__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b;
                    __result.__ctz_ = static_cast<unsigned int>(- __n & (__bits_per_word - 1));
                }
            }
            return __result;
        }

;
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)         {
            typedef __bit_iterator<_Cp, _IsConst> _In;
            typedef typename _In::difference_type difference_type;
            typedef typename _In::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _In::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__last.__ctz_ != 0) {
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
                    __n -= __dn;
                    unsigned int __clz_l = __bits_per_word - __last.__ctz_;
                    __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
                    __storage_type __b = *__last.__seg_ & __m;
                    unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                    __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
                    if (__ddn > 0) {
                        __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                        *__result.__seg_ &= ~__m;
                        if (__result.__ctz_ > __last.__ctz_)
                            *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                        else
                            *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                        __result.__ctz_ = static_cast<unsigned int>(((- __ddn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
                        __dn -= __ddn;
                    }
                    if (__dn > 0) {
                        --__result.__seg_;
                        __result.__ctz_ = static_cast<unsigned int>(- __dn & (__bits_per_word - 1));
                        __m = ~__storage_type(0) << __result.__ctz_;
                        *__result.__seg_ &= ~__m;
                        __last.__ctz_ -= __dn + __ddn;
                        *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                    }
                }
                unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                __storage_type __m = ~__storage_type(0) >> __clz_r;
                for (; __n >= __bits_per_word; __n -= __bits_per_word) {
                    __storage_type __b = *--__last.__seg_;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b >> __clz_r;
                    *--__result.__seg_ &= __m;
                    *__result.__seg_ |= __b << __result.__ctz_;
                }
                if (__n > 0) {
                    __m = ~__storage_type(0) << (__bits_per_word - __n);
                    __storage_type __b = *--__last.__seg_ & __m;
                    __clz_r = __bits_per_word - __result.__ctz_;
                    __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
                    __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
                    __result.__ctz_ = static_cast<unsigned int>(((- __dn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
                    __n -= __dn;
                    if (__n > 0) {
                        --__result.__seg_;
                        __result.__ctz_ = static_cast<unsigned int>(- __n & (__bits_per_word - 1));
                        __m = ~__storage_type(0) << __result.__ctz_;
                        *__result.__seg_ &= ~__m;
                        *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
                    }
                }
            }
            return __result;
        }

;
        template <class _Cp, bool _IsConst> inline __bit_iterator<_Cp, false> copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__last.__ctz_ == __result.__ctz_)
                return __copy_backward_aligned(__first, __last, __result);
            return __copy_backward_unaligned(__first, __last, __result);
        }

;
        template <class _Cp, bool _IsConst> inline __bit_iterator<_Cp, false> move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::copy(__first, __last, __result);
        }

;
        template <class _Cp, bool _IsConst> inline __bit_iterator<_Cp, false> move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::copy_backward(__first, __last, __result);
        }

;
        template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last, __bit_iterator<__C2, false> __result)         {
            typedef __bit_iterator<__C1, false> _I1;
            typedef typename _I1::difference_type difference_type;
            typedef typename _I1::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _I1::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__first.__ctz_ != 0) {
                    unsigned int __clz = __bits_per_word - __first.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
                    __storage_type __b1 = *__first.__seg_ & __m;
                    *__first.__seg_ &= ~__m;
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b1;
                    *__first.__seg_ |= __b2;
                    __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__dn + __result.__ctz_) % __bits_per_word);
                    ++__first.__seg_;
                }
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first.__seg_ , ++__result.__seg_) 
                    swap(*__first.__seg_, *__result.__seg_);
                if (__n > 0) {
                    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b1 = *__first.__seg_ & __m;
                    *__first.__seg_ &= ~__m;
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b1;
                    *__first.__seg_ |= __b2;
                    __result.__ctz_ = static_cast<unsigned int>(__n);
                }
            }
            return __result;
        }

;
        template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last, __bit_iterator<__C2, false> __result)         {
            typedef __bit_iterator<__C1, false> _I1;
            typedef typename _I1::difference_type difference_type;
            typedef typename _I1::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _I1::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__first.__ctz_ != 0) {
                    unsigned int __clz_f = __bits_per_word - __first.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                    __storage_type __b1 = *__first.__seg_ & __m;
                    *__first.__seg_ &= ~__m;
                    unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                    __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
                    __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    if (__result.__ctz_ > __first.__ctz_) {
                        unsigned int __s = __result.__ctz_ - __first.__ctz_;
                        *__result.__seg_ |= __b1 << __s;
                        *__first.__seg_ |= __b2 >> __s;
                    } else {
                        unsigned int __s = __first.__ctz_ - __result.__ctz_;
                        *__result.__seg_ |= __b1 >> __s;
                        *__first.__seg_ |= __b2 << __s;
                    }
                    __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__ddn + __result.__ctz_) % __bits_per_word);
                    __dn -= __ddn;
                    if (__dn > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                        __b2 = *__result.__seg_ & __m;
                        *__result.__seg_ &= ~__m;
                        unsigned int __s = __first.__ctz_ + __ddn;
                        *__result.__seg_ |= __b1 >> __s;
                        *__first.__seg_ |= __b2 << __s;
                        __result.__ctz_ = static_cast<unsigned int>(__dn);
                    }
                    ++__first.__seg_;
                }
                __storage_type __m = ~__storage_type(0) << __result.__ctz_;
                unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first.__seg_) {
                    __storage_type __b1 = *__first.__seg_;
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b1 << __result.__ctz_;
                    *__first.__seg_ = __b2 >> __result.__ctz_;
                    ++__result.__seg_;
                    __b2 = *__result.__seg_ & ~__m;
                    *__result.__seg_ &= __m;
                    *__result.__seg_ |= __b1 >> __clz_r;
                    *__first.__seg_ |= __b2 << __clz_r;
                }
                if (__n > 0) {
                    __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b1 = *__first.__seg_ & __m;
                    *__first.__seg_ &= ~__m;
                    __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
                    __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b1 << __result.__ctz_;
                    *__first.__seg_ |= __b2 >> __result.__ctz_;
                    __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__dn + __result.__ctz_) % __bits_per_word);
                    __n -= __dn;
                    if (__n > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __n);
                        __b2 = *__result.__seg_ & __m;
                        *__result.__seg_ &= ~__m;
                        *__result.__seg_ |= __b1 >> __dn;
                        *__first.__seg_ |= __b2 << __dn;
                        __result.__ctz_ = static_cast<unsigned int>(__n);
                    }
                }
            }
            return __result;
        }

;
        template <class __C1, class __C2> inline __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1, __bit_iterator<__C2, false> __first2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__first1.__ctz_ == __first2.__ctz_)
                return __swap_ranges_aligned(__first1, __last1, __first2);
            return __swap_ranges_unaligned(__first1, __last1, __first2);
        }

;
        template <class _Cp = std::__1::__bitset<0, 0>> struct __bit_array
template <class _Cp> struct __bit_array {
            typedef typename _Cp::difference_type difference_type;
            typedef typename _Cp::__storage_type __storage_type;
            typedef typename _Cp::__storage_pointer __storage_pointer;
            typedef typename _Cp::iterator iterator;
            static const unsigned int __bits_per_word = _Cp::__bits_per_word;
            static const unsigned int _Np = 4;
            difference_type __size_;
            __storage_type __word_[_Np];
            static difference_type capacity() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return static_cast<difference_type>(_Np * __bits_per_word);
            }


            explicit __bit_array<_Cp>(difference_type __s) : __size_(__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            iterator begin() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return iterator(pointer_traits<__storage_pointer>::pointer_to(this->__word_[0]), 0);
            }


            iterator end() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return iterator(pointer_traits<__storage_pointer>::pointer_to(this->__word_[0]) + this->__size_ / __bits_per_word, static_cast<unsigned int>(this->__size_ % __bits_per_word));
            }


        };
        template <class _Cp> __bit_iterator<_Cp, false> rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)         {
            typedef __bit_iterator<_Cp, false> _I1;
            typedef typename _I1::difference_type difference_type;
            difference_type __d1 = __middle - __first;
            difference_type __d2 = __last - __middle;
            _I1 __r = __first + __d2;
            while (__d1 != 0 && __d2 != 0)
                {
                    if (__d1 <= __d2) {
                        if (__d1 <= __bit_array<_Cp>::capacity()) {
                            __bit_array<_Cp> __b(__d1);
                            std::__1::copy(__first, __middle, __b.begin());
                            std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                            break;
                        } else {
                            __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                            __first = __middle;
                            __middle = __mp;
                            __d2 -= __d1;
                        }
                    } else {
                        if (__d2 <= __bit_array<_Cp>::capacity()) {
                            __bit_array<_Cp> __b(__d2);
                            std::__1::copy(__middle, __last, __b.begin());
                            std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                            break;
                        } else {
                            __bit_iterator<_Cp, false> __mp = __first + __d2;
                            std::__1::swap_ranges(__first, __mp, __middle);
                            __first = __mp;
                            __d1 -= __d2;
                        }
                    }
                }
            return __r;
        }

;
        template <class _Cp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)         {
            typedef __bit_iterator<_Cp, _IC1> _It;
            typedef typename _It::difference_type difference_type;
            typedef typename _It::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _It::__bits_per_word;
            difference_type __n = __last1 - __first1;
            if (__n > 0) {
                if (__first1.__ctz_ != 0) {
                    unsigned int __clz_f = __bits_per_word - __first1.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                    __storage_type __b = *__first1.__seg_ & __m;
                    unsigned int __clz_r = __bits_per_word - __first2.__ctz_;
                    __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
                    __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
                    if (__first2.__ctz_ > __first1.__ctz_) {
                        if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                            return false;
                    } else {
                        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                            return false;
                    }
                    __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
                    __first2.__ctz_ = static_cast<unsigned int>((__ddn + __first2.__ctz_) % __bits_per_word);
                    __dn -= __ddn;
                    if (__dn > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                            return false;
                        __first2.__ctz_ = static_cast<unsigned int>(__dn);
                    }
                    ++__first1.__seg_;
                }
                unsigned int __clz_r = __bits_per_word - __first2.__ctz_;
                __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first1.__seg_) {
                    __storage_type __b = *__first1.__seg_;
                    if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                        return false;
                    ++__first2.__seg_;
                    if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                        return false;
                }
                if (__n > 0) {
                    __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b = *__first1.__seg_ & __m;
                    __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
                    __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
                    if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                        return false;
                    __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
                    __first2.__ctz_ = static_cast<unsigned int>((__dn + __first2.__ctz_) % __bits_per_word);
                    __n -= __dn;
                    if (__n > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __n);
                        if ((*__first2.__seg_ & __m) != (__b >> __dn))
                            return false;
                    }
                }
            }
            return true;
        }

;
        template <class _Cp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)         {
            typedef __bit_iterator<_Cp, _IC1> _It;
            typedef typename _It::difference_type difference_type;
            typedef typename _It::__storage_type __storage_type;
            static const unsigned int __bits_per_word = _It::__bits_per_word;
            difference_type __n = __last1 - __first1;
            if (__n > 0) {
                if (__first1.__ctz_ != 0) {
                    unsigned int __clz = __bits_per_word - __first1.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
                    if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                        return false;
                    ++__first2.__seg_;
                    ++__first1.__seg_;
                }
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first1.__seg_ , ++__first2.__seg_) 
                    if (*__first2.__seg_ != *__first1.__seg_)
                        return false;
                if (__n > 0) {
                    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                        return false;
                }
            }
            return true;
        }

;
        template <class _Cp, bool _IC1, bool _IC2> inline bool equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (__first1.__ctz_ == __first2.__ctz_)
                return __equal_aligned(__first1, __last1, __first2);
            return __equal_unaligned(__first1, __last1, __first2);
        }

;
        template <class _Cp = std::__1::__bitset<0, 0>, bool _IsConst = false, typename _Cp::__storage_type = 0> class __bit_iterator {
        public:
            typedef typename __bitset<0, 0>::difference_type difference_type;
            typedef bool value_type;
            typedef std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> pointer;
            typedef typename conditional<false, __bit_const_reference<__bitset<0, 0> >, __bit_reference<__bitset<0, 0> > >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename conditional<false, typename __bitset<0, 0>::__const_storage_pointer, typename __bitset<0, 0>::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = __bitset<0, 0>::__bits_per_word;
            __storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator() noexcept __attribute__((always_inline));
            __bit_iterator(const __bit_iterator<std::__1::__bitset<0, 0>, false> &__it) noexcept : __seg_(__it.__seg_), __ctz_(__it.__ctz_) __attribute__((always_inline))             {
            }


            reference operator*() const noexcept __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator++() __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator++(int) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator--() __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator--(int) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator+=(difference_type __n) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator-=(difference_type __n) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator+(difference_type __n) const __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator-(difference_type __n) const __attribute__((always_inline));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator+(difference_type __n, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__it) __attribute__((always_inline));
            friend difference_type operator-(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            reference operator[](difference_type __n) const __attribute__((always_inline));
            friend bool operator==(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator!=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator<(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator>(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator<=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
            friend bool operator>=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((always_inline));
        private:
            __bit_iterator(__storage_pointer __s, unsigned int __ctz) noexcept : __seg_(__s), __ctz_(__ctz) __attribute__((always_inline))             {
            }


            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        }
template <class _Cp = std::__1::__bitset<0, 0>, bool _IsConst = true, typename _Cp::__storage_type = 0> class __bit_iterator {
        public:
            typedef typename __bitset<0, 0>::difference_type difference_type;
            typedef bool value_type;
            typedef std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> pointer;
            typedef typename conditional<true, __bit_const_reference<__bitset<0, 0> >, __bit_reference<__bitset<0, 0> > >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename conditional<true, typename __bitset<0, 0>::__const_storage_pointer, typename __bitset<0, 0>::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = __bitset<0, 0>::__bits_per_word;
            __storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator() noexcept __attribute__((always_inline));
            __bit_iterator(const __bit_iterator<std::__1::__bitset<0, 0>, false> &__it) noexcept __attribute__((always_inline));
            reference operator*() const noexcept __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator++() __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator++(int) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator--() __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator--(int) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator+=(difference_type __n) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator-=(difference_type __n) __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator+(difference_type __n) const __attribute__((always_inline));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator-(difference_type __n) const __attribute__((always_inline));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator+(difference_type __n, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__it) __attribute__((always_inline));
            friend difference_type operator-(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            reference operator[](difference_type __n) const __attribute__((always_inline));
            friend bool operator==(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator!=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator<(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator>(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator<=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
            friend bool operator>=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((always_inline));
        private:
            __bit_iterator(__storage_pointer __s, unsigned int __ctz) noexcept : __seg_(__s), __ctz_(__ctz) __attribute__((always_inline))             {
            }


            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        }
template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator {
        public:
            typedef typename _Cp::difference_type difference_type;
            typedef bool value_type;
            typedef __bit_iterator<_Cp, _IsConst, > pointer;
            typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename _Cp::__storage_type __storage_type;
            typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer, typename _Cp::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = _Cp::__bits_per_word;
            __storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator<_Cp, _IsConst, >() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            __bit_iterator<_Cp, _IsConst, >(const __bit_iterator<_Cp, false> &__it) noexcept : __seg_(__it.__seg_), __ctz_(__it.__ctz_) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            reference operator*() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reference(this->__seg_, __storage_type(1) << this->__ctz_);
            }


            __bit_iterator<_Cp, _IsConst, > &operator++() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (this->__ctz_ != __bits_per_word - 1)
                    ++this->__ctz_;
                else {
                    this->__ctz_ = 0;
                    ++this->__seg_;
                }
                return *this;
            }


            __bit_iterator<_Cp, _IsConst, > operator++(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __bit_iterator<_Cp, _IsConst, > __tmp = *this;
                ++(*this);
                return __tmp;
            }


            __bit_iterator<_Cp, _IsConst, > &operator--() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (this->__ctz_ != 0)
                    --this->__ctz_;
                else {
                    this->__ctz_ = __bits_per_word - 1;
                    --this->__seg_;
                }
                return *this;
            }


            __bit_iterator<_Cp, _IsConst, > operator--(int) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __bit_iterator<_Cp, _IsConst, > __tmp = *this;
                --(*this);
                return __tmp;
            }


            __bit_iterator<_Cp, _IsConst, > &operator+=(difference_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                if (__n >= 0)
                    this->__seg_ += (__n + this->__ctz_) / __bits_per_word;
                else
                    this->__seg_ += static_cast<difference_type>(__n - __bits_per_word + this->__ctz_ + 1) / static_cast<difference_type>(__bits_per_word);
                __n &= (__bits_per_word - 1);
                this->__ctz_ = static_cast<unsigned int>((__n + this->__ctz_) % __bits_per_word);
                return *this;
            }


            __bit_iterator<_Cp, _IsConst, > &operator-=(difference_type __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *this += - __n;
            }


            __bit_iterator<_Cp, _IsConst, > operator+(difference_type __n) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __bit_iterator<_Cp, _IsConst, > __t(*this);
                __t += __n;
                return __t;
            }


            __bit_iterator<_Cp, _IsConst, > operator-(difference_type __n) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                __bit_iterator<_Cp, _IsConst, > __t(*this);
                __t -= __n;
                return __t;
            }


            friend __bit_iterator<_Cp, _IsConst, > operator+(difference_type __n, const __bit_iterator<_Cp, _IsConst, > &__it) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __it + __n;
            }

;
            friend difference_type operator-(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;
            }

;
            reference operator[](difference_type __n) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return *(*this + __n);
            }


            friend bool operator==(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;
            }

;
            friend bool operator!=(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__x == __y);
            }

;
            friend bool operator<(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);
            }

;
            friend bool operator>(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __y < __x;
            }

;
            friend bool operator<=(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__y < __x);
            }

;
            friend bool operator>=(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !(__x < __y);
            }

;
        private:
            __bit_iterator<_Cp, _IsConst, >(__storage_pointer __s, unsigned int __ctz) noexcept : __seg_(__s), __ctz_(__ctz) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            friend  typename _Cp::__self;
            friend  class __bit_reference<_Cp>;
            friend  class __bit_const_reference<_Cp>;
            friend  class __bit_iterator<_Cp, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        };
    }
}
namespace std {
    inline namespace __1 {
        template <size_t _N_words = 0, size_t _Size = 0> class __bitset {
        public:
            typedef ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef size_type __storage_type;
        protected:
            typedef std::__1::__bitset<0, 0> __self;
            typedef __storage_type *__storage_pointer;
            typedef const __storage_type *__const_storage_pointer;
            static const unsigned int __bits_per_word = static_cast<unsigned int>(sizeof(__storage_type) * 8);
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, false>;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend  struct __bit_array<__bitset<0, 0> >;
            typedef __bit_reference<std::__1::__bitset<0, 0> > reference;
            typedef __bit_const_reference<std::__1::__bitset<0, 0> > const_reference;
            typedef __bit_iterator<std::__1::__bitset<0, 0>, false> iterator;
            typedef __bit_iterator<std::__1::__bitset<0, 0>, true> const_iterator;
            constexpr __bitset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            constexpr explicit __bitset(unsigned long long) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            reference __make_ref(size_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reference(0, 1);
            }


            constexpr const_reference __make_ref(size_t) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_reference(0, 1);
            }


            iterator __make_iter(size_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return iterator(0, 0);
            }


            const_iterator __make_iter(size_t) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_iterator(0, 0);
            }


            void operator&=(const std::__1::__bitset<0, 0> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void operator|=(const std::__1::__bitset<0, 0> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void operator^=(const std::__1::__bitset<0, 0> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void flip() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            unsigned long to_ulong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0;
            }


            unsigned long long to_ullong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0;
            }


            bool all() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return true;
            }


            bool any() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return false;
            }


            size_t __hash_code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0;
            }


        }
template <size_t _N_words, size_t _Size> class __bitset;
        struct __has_storage_type {
            static const bool value = true;
        };
        template <size_t _N_words = 0, size_t _Size = 0> class __bitset {
        public:
            typedef ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef size_type __storage_type;
        protected:
            typedef std::__1::__bitset<0, 0> __self;
            typedef __storage_type *__storage_pointer;
            typedef const __storage_type *__const_storage_pointer;
            static const unsigned int __bits_per_word = static_cast<unsigned int>(sizeof(__storage_type) * 8);
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, false>;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend  struct __bit_array<__bitset<0, 0> >;
            typedef __bit_reference<std::__1::__bitset<0, 0> > reference;
            typedef __bit_const_reference<std::__1::__bitset<0, 0> > const_reference;
            typedef __bit_iterator<std::__1::__bitset<0, 0>, false> iterator;
            typedef __bit_iterator<std::__1::__bitset<0, 0>, true> const_iterator;
            constexpr __bitset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            constexpr explicit __bitset(unsigned long long) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            reference __make_ref(size_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reference(0, 1);
            }


            constexpr const_reference __make_ref(size_t) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_reference(0, 1);
            }


            iterator __make_iter(size_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return iterator(0, 0);
            }


            const_iterator __make_iter(size_t) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_iterator(0, 0);
            }


            void operator&=(const std::__1::__bitset<0, 0> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void operator|=(const std::__1::__bitset<0, 0> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void operator^=(const std::__1::__bitset<0, 0> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void flip() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            unsigned long to_ulong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0;
            }


            unsigned long long to_ullong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0;
            }


            bool all() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return true;
            }


            bool any() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return false;
            }


            size_t __hash_code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0;
            }


        }
template <size_t _N_words, size_t _Size> class __bitset {
        public:
            typedef ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef size_type __storage_type;
        protected:
            typedef __bitset<_N_words, _Size> __self;
            typedef __storage_type *__storage_pointer;
            typedef const __storage_type *__const_storage_pointer;
            static const unsigned int __bits_per_word = static_cast<unsigned int>(sizeof(__storage_type) * 8);
            friend  class __bit_reference<__bitset<_N_words, _Size> >;
            friend  class __bit_const_reference<__bitset<_N_words, _Size> >;
            friend  class __bit_iterator<__bitset<_N_words, _Size>, false>;
            friend  class __bit_iterator<__bitset<_N_words, _Size>, true>;
            friend  struct __bit_array<__bitset<_N_words, _Size> >;
            __storage_type __first_[_N_words];
            typedef __bit_reference<__bitset<_N_words, _Size> > reference;
            typedef __bit_const_reference<__bitset<_N_words, _Size> > const_reference;
            typedef __bit_iterator<__bitset<_N_words, _Size>, false> iterator;
            typedef __bit_iterator<__bitset<_N_words, _Size>, true> const_iterator;
            constexpr __bitset<_N_words, _Size>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            constexpr explicit __bitset<_N_words, _Size>(unsigned long long __v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            reference __make_ref(size_t __pos) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reference(this->__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
            }


            constexpr const_reference __make_ref(size_t __pos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_reference(this->__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
            }


            iterator __make_iter(size_t __pos) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return iterator(this->__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
            }


            const_iterator __make_iter(size_t __pos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_iterator(this->__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
            }


            void operator&=(const __bitset<_N_words, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void operator|=(const __bitset<_N_words, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void operator^=(const __bitset<_N_words, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void flip() noexcept;
            unsigned long to_ulong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());
            }


            unsigned long long to_ullong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());
            }


            bool all() const noexcept;
            bool any() const noexcept;
            size_t __hash_code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        private:
            unsigned long to_ulong(false_type) const;
            unsigned long to_ulong(true_type) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            unsigned long long to_ullong(false_type) const;
            unsigned long long to_ullong(true_type) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            unsigned long long to_ullong(true_type, false_type) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            unsigned long long to_ullong(true_type, true_type) const;
        };
        inline constexpr __bitset<_N_words, _Size>() noexcept : __first_({0}) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline constexpr __bitset<_N_words, _Size>(unsigned long long __v) noexcept : __first_({__v}) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline void operator&=(const __bitset<_N_words, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (size_type __i = 0; __i < _N_words; ++__i) 
                this->__first_[__i] &= __v.__first_[__i];
        }


        inline void operator|=(const __bitset<_N_words, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (size_type __i = 0; __i < _N_words; ++__i) 
                this->__first_[__i] |= __v.__first_[__i];
        }


        inline void operator^=(const __bitset<_N_words, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            for (size_type __i = 0; __i < _N_words; ++__i) 
                this->__first_[__i] ^= __v.__first_[__i];
        }


        void flip() noexcept         {
            size_type __n = _Size;
            __storage_pointer __p = this->__first_;
            for (; __n >= __bits_per_word; ++__p , __n -= __bits_per_word) 
                *__p = ~*__p;
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b = *__p & __m;
                *__p &= ~__m;
                *__p |= ~__b & __m;
            }
        }


        unsigned long to_ulong(false_type) const         {
            const_iterator __e = __make_iter(_Size);
            const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
            if (__i != __e)
                throw std::overflow_error("bitset to_ulong overflow error");
            return this->__first_[0];
        }


        inline unsigned long to_ulong(true_type) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__first_[0];
        }


        unsigned long long to_ullong(false_type) const         {
            const_iterator __e = __make_iter(_Size);
            const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
            if (__i != __e)
                throw std::overflow_error("bitset to_ullong overflow error");
            return to_ullong(true_type());
        }


        inline unsigned long long to_ullong(true_type) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
        }


        inline unsigned long long to_ullong(true_type, false_type) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__first_[0];
        }


        unsigned long long to_ullong(true_type, true_type) const         {
            unsigned long long __r = this->__first_[0];
            for (std::size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i) 
                __r |= static_cast<unsigned long long>(this->__first_[__i]) << (sizeof(__storage_type) * 8);
            return __r;
        }


        bool all() const noexcept         {
            size_type __n = _Size;
            __const_storage_pointer __p = this->__first_;
            for (; __n >= __bits_per_word; ++__p , __n -= __bits_per_word) 
                if (~*__p)
                    return false;
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if (~*__p & __m)
                    return false;
            }
            return true;
        }


        bool any() const noexcept         {
            size_type __n = _Size;
            __const_storage_pointer __p = this->__first_;
            for (; __n >= __bits_per_word; ++__p , __n -= __bits_per_word) 
                if (*__p)
                    return true;
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if (*__p & __m)
                    return true;
            }
            return false;
        }


        inline size_t __hash_code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            size_t __h = 0;
            for (size_type __i = 0; __i < _N_words; ++__i) 
                __h ^= this->__first_[__i];
            return __h;
        }


        class __bitset {
        public:
            typedef ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef size_type __storage_type;
        protected:
            typedef __bitset<1, _Size> __self;
            typedef __storage_type *__storage_pointer;
            typedef const __storage_type *__const_storage_pointer;
            static const unsigned int __bits_per_word = static_cast<unsigned int>(sizeof(__storage_type) * 8);
            friend  class __bit_reference<__bitset<1, _Size> >;
            friend  class __bit_const_reference<__bitset<1, _Size> >;
            friend  class __bit_iterator<__bitset<1, _Size>, false>;
            friend  class __bit_iterator<__bitset<1, _Size>, true>;
            friend  struct __bit_array<__bitset<1, _Size> >;
            __storage_type __first_;
            typedef __bit_reference<__bitset<1, _Size> > reference;
            typedef __bit_const_reference<__bitset<1, _Size> > const_reference;
            typedef __bit_iterator<__bitset<1, _Size>, false> iterator;
            typedef __bit_iterator<__bitset<1, _Size>, true> const_iterator;
            constexpr __bitset<1, _Size>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            constexpr explicit __bitset<1, _Size>(unsigned long long __v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            reference __make_ref(size_t __pos) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reference(&this->__first_, __storage_type(1) << __pos);
            }


            constexpr const_reference __make_ref(size_t __pos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_reference(&this->__first_, __storage_type(1) << __pos);
            }


            iterator __make_iter(size_t __pos) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return iterator(&this->__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
            }


            const_iterator __make_iter(size_t __pos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_iterator(&this->__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
            }


            void operator&=(const __bitset<1, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void operator|=(const __bitset<1, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void operator^=(const __bitset<1, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void flip() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            unsigned long to_ulong() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            unsigned long long to_ullong() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool all() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool any() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_t __hash_code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        };
        inline constexpr __bitset<1, _Size>() noexcept : __first_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline constexpr __bitset<1, _Size>(unsigned long long __v) noexcept : __first_(static_cast<__storage_type>(__v)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline void operator&=(const __bitset<1, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__first_ &= __v.__first_;
        }


        inline void operator|=(const __bitset<1, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__first_ |= __v.__first_;
        }


        inline void operator^=(const __bitset<1, _Size> &__v) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->__first_ ^= __v.__first_;
        }


        inline void flip() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
            this->__first_ = ~this->__first_;
            this->__first_ &= __m;
        }


        inline unsigned long to_ulong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__first_;
        }


        inline unsigned long long to_ullong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__first_;
        }


        inline bool all() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
            return !(~this->__first_ & __m);
        }


        inline bool any() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
            return this->__first_ & __m;
        }


        inline size_t __hash_code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return this->__first_;
        }


        class __bitset {
        public:
            typedef ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef size_type __storage_type;
        protected:
            typedef std::__1::__bitset<0, 0> __self;
            typedef __storage_type *__storage_pointer;
            typedef const __storage_type *__const_storage_pointer;
            static const unsigned int __bits_per_word = static_cast<unsigned int>(sizeof(__storage_type) * 8);
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, false>;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend  struct __bit_array<__bitset<0, 0> >;
            typedef __bit_reference<std::__1::__bitset<0, 0> > reference;
            typedef __bit_const_reference<std::__1::__bitset<0, 0> > const_reference;
            typedef __bit_iterator<std::__1::__bitset<0, 0>, false> iterator;
            typedef __bit_iterator<std::__1::__bitset<0, 0>, true> const_iterator;
            constexpr __bitset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            constexpr explicit __bitset(unsigned long long) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            reference __make_ref(size_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return reference(0, 1);
            }


            constexpr const_reference __make_ref(size_t) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_reference(0, 1);
            }


            iterator __make_iter(size_t) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return iterator(0, 0);
            }


            const_iterator __make_iter(size_t) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return const_iterator(0, 0);
            }


            void operator&=(const std::__1::__bitset<0, 0> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void operator|=(const std::__1::__bitset<0, 0> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void operator^=(const std::__1::__bitset<0, 0> &) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            void flip() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            unsigned long to_ulong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0;
            }


            unsigned long long to_ullong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0;
            }


            bool all() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return true;
            }


            bool any() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return false;
            }


            size_t __hash_code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return 0;
            }


        };
        inline constexpr __bitset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline constexpr __bitset(unsigned long long) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        template <size_t _Size> class __attribute__((type_visibility("default"))) bitset;
        struct __attribute__((type_visibility("default"))) hash;
        template <size_t _Size> class __attribute__((type_visibility("default"))) bitset : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size> {
        public:
            static const unsigned int __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
            typedef __bitset<__n_words, _Size> base;
        public:
            typedef typename base::reference reference;
            typedef typename base::const_reference const_reference;
            constexpr bitset<_Size>() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            constexpr bitset<_Size>(unsigned long long __v) noexcept : base(__v) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


            template <class _CharT> explicit bitset<_Size>(const _CharT *__str, typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos, _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
            template <class _CharT, class _Traits, class _Allocator> explicit bitset<_Size>(const basic_string<_CharT, _Traits, _Allocator> &__str, typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos = 0, typename basic_string<_CharT, _Traits, _Allocator>::size_type __n = (basic_string<_CharT, _Traits, _Allocator>::npos), _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
            bitset<_Size> &operator&=(const bitset<_Size> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bitset<_Size> &operator|=(const bitset<_Size> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bitset<_Size> &operator^=(const bitset<_Size> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bitset<_Size> &operator<<=(size_t __pos) noexcept;
            bitset<_Size> &operator>>=(size_t __pos) noexcept;
            bitset<_Size> &set() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bitset<_Size> &set(size_t __pos, bool __val = true);
            bitset<_Size> &reset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bitset<_Size> &reset(size_t __pos);
            bitset<_Size> operator~() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bitset<_Size> &flip() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bitset<_Size> &flip(size_t __pos);
            constexpr const_reference operator[](size_t __p) const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return base::__make_ref(__p);
            }


            reference operator[](size_t __p) __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return base::__make_ref(__p);
            }


            unsigned long to_ulong() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            unsigned long long to_ullong() const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
            template <class _CharT, class _Traits> basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            template <class _CharT> basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0', char __one = '1') const __attribute__((always_inline)) __attribute__((visibility("hidden")));
            size_t count() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            constexpr size_t size() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return _Size;
            }


            bool operator==(const bitset<_Size> &__rhs) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool operator!=(const bitset<_Size> &__rhs) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool test(size_t __pos) const;
            bool all() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool any() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bool none() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return !this->any();
            }


            bitset<_Size> operator<<(size_t __pos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
            bitset<_Size> operator>>(size_t __pos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")));
        private:
            size_t __hash_code() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return base::__hash_code();
            }


            friend  struct hash<bitset<_Size> >;
        };
        template <class _CharT> bitset<_Size>(const _CharT *__str, typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos, _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))         {
            size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
            for (size_t __i = 0; __i < __rlen; ++__i) 
                if (__str[__i] != __zero && __str[__i] != __one)
                    throw std::invalid_argument("bitset string ctor has invalid argument");
            size_t _Mp = std::__1::min(__rlen, _Size);
            size_t __i = 0;
            for (; __i < _Mp; ++__i) {
                _CharT __c = __str[_Mp - 1 - __i];
                if (__c == __zero)
                    (*this)[__i] = false;
                else
                    (*this)[__i] = true;
            }
            std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
        }

;
        template <class _CharT, class _Traits, class _Allocator> bitset<_Size>(const basic_string<_CharT, _Traits, _Allocator> &__str, typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos = 0, typename basic_string<_CharT, _Traits, _Allocator>::size_type __n = (basic_string<_CharT, _Traits, _Allocator>::npos), _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))         {
            if (__pos > __str.size())
                throw std::out_of_range("bitset string pos out of range");
            size_t __rlen = std::__1::min(__n, __str.size() - __pos);
            for (size_t __i = __pos; __i < __pos + __rlen; ++__i) 
                if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
                    throw std::invalid_argument("bitset string ctor has invalid argument");
            size_t _Mp = std::__1::min(__rlen, _Size);
            size_t __i = 0;
            for (; __i < _Mp; ++__i) {
                _CharT __c = __str[__pos + _Mp - 1 - __i];
                if (_Traits::eq(__c, __zero))
                    (*this)[__i] = false;
                else
                    (*this)[__i] = true;
            }
            std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
        }

;
        inline bitset<_Size> &operator&=(const bitset<_Size> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            base::operator&=(__rhs);
            return *this;
        }


        inline bitset<_Size> &operator|=(const bitset<_Size> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            base::operator|=(__rhs);
            return *this;
        }


        inline bitset<_Size> &operator^=(const bitset<_Size> &__rhs) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            base::operator^=(__rhs);
            return *this;
        }


        bitset<_Size> &operator<<=(size_t __pos) noexcept         {
            __pos = std::__1::min(__pos, _Size);
            std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
            std::__1::fill_n(base::__make_iter(0), __pos, false);
            return *this;
        }


        bitset<_Size> &operator>>=(size_t __pos) noexcept         {
            __pos = std::__1::min(__pos, _Size);
            std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
            std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
            return *this;
        }


        inline bitset<_Size> &set() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::fill_n(base::__make_iter(0), _Size, true);
            return *this;
        }


        bitset<_Size> &set(size_t __pos, bool __val = true)         {
            if (__pos >= _Size)
                throw std::out_of_range("bitset set argument out of range");
            (*this)[__pos] = __val;
            return *this;
        }


        inline bitset<_Size> &reset() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::fill_n(base::__make_iter(0), _Size, false);
            return *this;
        }


        bitset<_Size> &reset(size_t __pos)         {
            if (__pos >= _Size)
                throw std::out_of_range("bitset reset argument out of range");
            (*this)[__pos] = false;
            return *this;
        }


        inline bitset<_Size> operator~() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bitset<_Size> __x(*this);
            __x.flip();
            return __x;
        }


        inline bitset<_Size> &flip() noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            base::flip();
            return *this;
        }


        bitset<_Size> &flip(size_t __pos)         {
            if (__pos >= _Size)
                throw std::out_of_range("bitset flip argument out of range");
            reference r = base::__make_ref(__pos);
            r = ~r;
            return *this;
        }


        inline unsigned long to_ulong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return base::to_ulong();
        }


        inline unsigned long long to_ullong() const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return base::to_ullong();
        }


        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const         {
            basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
            for (size_t __i = 0; __i < _Size; ++__i) {
                if ((*this)[__i])
                    __r[_Size - 1 - __i] = __one;
            }
            return __r;
        }

;
        template <class _CharT, class _Traits> inline basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
        }

;
        template <class _CharT> inline basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
        }

;
        inline basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0', char __one = '1') const __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
        }


        inline size_t count() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return static_cast<size_t>(std::__1::count(base::__make_iter(0), base::__make_iter(_Size), true));
        }


        inline bool operator==(const bitset<_Size> &__rhs) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
        }


        inline bool operator!=(const bitset<_Size> &__rhs) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return !(*this == __rhs);
        }


        bool test(size_t __pos) const         {
            if (__pos >= _Size)
                throw std::out_of_range("bitset test argument out of range");
            return (*this)[__pos];
        }


        inline bool all() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return base::all();
        }


        inline bool any() const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return base::any();
        }


        inline bitset<_Size> operator<<(size_t __pos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bitset<_Size> __r = *this;
            __r <<= __pos;
            return __r;
        }


        inline bitset<_Size> operator>>(size_t __pos) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bitset<_Size> __r = *this;
            __r >>= __pos;
            return __r;
        }


        template <size_t _Size> inline bitset<_Size> operator&(const bitset<_Size> &__x, const bitset<_Size> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bitset<_Size> __r = __x;
            __r &= __y;
            return __r;
        }

;
        template <size_t _Size> inline bitset<_Size> operator|(const bitset<_Size> &__x, const bitset<_Size> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bitset<_Size> __r = __x;
            __r |= __y;
            return __r;
        }

;
        template <size_t _Size> inline bitset<_Size> operator^(const bitset<_Size> &__x, const bitset<_Size> &__y) noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            bitset<_Size> __r = __x;
            __r ^= __y;
            return __r;
        }

;
        struct __attribute__((type_visibility("default"))) hash : public unary_function<bitset<_Size>, size_t> {
            size_t operator()(const bitset<_Size> &__bs) const noexcept __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return __bs.__hash_code();
            }


        };
        template <class _CharT, class _Traits, size_t _Size> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, bitset<_Size> &__x);
        template <class _CharT, class _Traits, size_t _Size> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const bitset<_Size> &__x);
    }
}
namespace std {
    inline namespace __1 {
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_ostream : virtual public basic_ios<char, std::__1::char_traits<char> > {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_ostream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ostream<char>() noexcept;
        protected:
            basic_ostream(std::__1::basic_ostream<char> &&__rhs) __attribute__((always_inline));
            std::__1::basic_ostream<char> &operator=(std::__1::basic_ostream<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ostream<char> &__rhs) __attribute__((always_inline));
            basic_ostream(const std::__1::basic_ostream<char> &__rhs) = delete
            std::__1::basic_ostream<char> &operator=(const std::__1::basic_ostream<char> &__rhs) = delete
        public:
            class sentry {
                bool __ok_;
                basic_ostream<char, std::__1::char_traits<char> > &__os_;
                sentry(const std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &);
                std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &operator=(const std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &);
            public:
                explicit sentry(basic_ostream<char, std::__1::char_traits<char> > &__os);
                ~std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry() noexcept;
                explicit operator bool() const __attribute__((always_inline))                 {
                    return this->__ok_;
                }


            };
            std::__1::basic_ostream<char> &operator<<(std::__1::basic_ostream<char> &(*__pf)(std::__1::basic_ostream<char> &)) __attribute__((always_inline))             {
                return __pf(*this);
            }


            std::__1::basic_ostream<char> &operator<<(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_ostream<char> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline))             {
                __pf(*this);
                return *this;
            }


            std::__1::basic_ostream<char> &operator<<(bool __n);
            std::__1::basic_ostream<char> &operator<<(short __n);
            std::__1::basic_ostream<char> &operator<<(unsigned short __n);
            std::__1::basic_ostream<char> &operator<<(int __n);
            std::__1::basic_ostream<char> &operator<<(unsigned int __n);
            std::__1::basic_ostream<char> &operator<<(long __n);
            std::__1::basic_ostream<char> &operator<<(unsigned long __n);
            std::__1::basic_ostream<char> &operator<<(long long __n);
            std::__1::basic_ostream<char> &operator<<(unsigned long long __n);
            std::__1::basic_ostream<char> &operator<<(float __f);
            std::__1::basic_ostream<char> &operator<<(double __f);
            std::__1::basic_ostream<char> &operator<<(long double __f);
            std::__1::basic_ostream<char> &operator<<(const void *__p);
            std::__1::basic_ostream<char> &operator<<(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_ostream<char> &put(char_type __c);
            std::__1::basic_ostream<char> &write(const char_type *__s, streamsize __n);
            std::__1::basic_ostream<char> &flush();
            pos_type tellp() __attribute__((always_inline));
            std::__1::basic_ostream<char> &seekp(pos_type __pos) __attribute__((always_inline));
            std::__1::basic_ostream<char> &seekp(off_type __off, ios_base::seekdir __dir) __attribute__((always_inline));
        protected:
            basic_ostream() __attribute__((always_inline));
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class __attribute__((type_visibility("default"))) basic_ostream : virtual public basic_ios<wchar_t, std::__1::char_traits<wchar_t> > {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_ostream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ostream<wchar_t>() noexcept;
        protected:
            basic_ostream(std::__1::basic_ostream<wchar_t> &&__rhs) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator=(std::__1::basic_ostream<wchar_t> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ostream<wchar_t> &__rhs) __attribute__((always_inline));
            basic_ostream(const std::__1::basic_ostream<wchar_t> &__rhs) = delete
            std::__1::basic_ostream<wchar_t> &operator=(const std::__1::basic_ostream<wchar_t> &__rhs) = delete
        public:
            class sentry {
                bool __ok_;
                basic_ostream<wchar_t, std::__1::char_traits<wchar_t> > &__os_;
                sentry(const std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
                std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &operator=(const std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
            public:
                explicit sentry(basic_ostream<wchar_t, std::__1::char_traits<wchar_t> > &__os);
                ~std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry();
                explicit operator bool() const __attribute__((always_inline));
            };
            std::__1::basic_ostream<wchar_t> &operator<<(std::__1::basic_ostream<wchar_t> &(*__pf)(std::__1::basic_ostream<wchar_t> &)) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator<<(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator<<(bool __n);
            std::__1::basic_ostream<wchar_t> &operator<<(short __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned short __n);
            std::__1::basic_ostream<wchar_t> &operator<<(int __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned int __n);
            std::__1::basic_ostream<wchar_t> &operator<<(long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(long long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned long long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(float __f);
            std::__1::basic_ostream<wchar_t> &operator<<(double __f);
            std::__1::basic_ostream<wchar_t> &operator<<(long double __f);
            std::__1::basic_ostream<wchar_t> &operator<<(const void *__p);
            std::__1::basic_ostream<wchar_t> &operator<<(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_ostream<wchar_t> &put(char_type __c);
            std::__1::basic_ostream<wchar_t> &write(const char_type *__s, streamsize __n);
            std::__1::basic_ostream<wchar_t> &flush();
            pos_type tellp() __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &seekp(pos_type __pos) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &seekp(off_type __off, ios_base::seekdir __dir) __attribute__((always_inline));
        protected:
            basic_ostream() __attribute__((always_inline));
        }
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ostream : virtual public basic_ios<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_ostream<_CharT, _Traits>(basic_streambuf<char_type, traits_type> *__sb);
            virtual ~basic_ostream<_CharT, _Traits>();
        protected:
            basic_ostream<_CharT, _Traits>(basic_ostream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_ostream<_CharT, _Traits> &operator=(basic_ostream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void swap(basic_ostream<_CharT, _Traits> &__rhs);
            basic_ostream<_CharT, _Traits>(const basic_ostream<_CharT, _Traits> &__rhs) = delete
            basic_ostream<_CharT, _Traits> &operator=(const basic_ostream<_CharT, _Traits> &__rhs) = delete
        public:
            class __attribute__((type_visibility("default"))) sentry;
            basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &(*__pf)(basic_ostream<_CharT, _Traits> &));
            basic_ostream<_CharT, _Traits> &operator<<(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &));
            basic_ostream<_CharT, _Traits> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &));
            basic_ostream<_CharT, _Traits> &operator<<(bool __n);
            basic_ostream<_CharT, _Traits> &operator<<(short __n);
            basic_ostream<_CharT, _Traits> &operator<<(unsigned short __n);
            basic_ostream<_CharT, _Traits> &operator<<(int __n);
            basic_ostream<_CharT, _Traits> &operator<<(unsigned int __n);
            basic_ostream<_CharT, _Traits> &operator<<(long __n);
            basic_ostream<_CharT, _Traits> &operator<<(unsigned long __n);
            basic_ostream<_CharT, _Traits> &operator<<(long long __n);
            basic_ostream<_CharT, _Traits> &operator<<(unsigned long long __n);
            basic_ostream<_CharT, _Traits> &operator<<(float __f);
            basic_ostream<_CharT, _Traits> &operator<<(double __f);
            basic_ostream<_CharT, _Traits> &operator<<(long double __f);
            basic_ostream<_CharT, _Traits> &operator<<(const void *__p);
            basic_ostream<_CharT, _Traits> &operator<<(basic_streambuf<char_type, traits_type> *__sb);
            basic_ostream<_CharT, _Traits> &put(char_type __c);
            basic_ostream<_CharT, _Traits> &write(const char_type *__s, streamsize __n);
            basic_ostream<_CharT, _Traits> &flush();
            pos_type tellp();
            basic_ostream<_CharT, _Traits> &seekp(pos_type __pos);
            basic_ostream<_CharT, _Traits> &seekp(off_type __off, ios_base::seekdir __dir);
        protected:
            basic_ostream<_CharT, _Traits>() __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
            }


        };
        class __attribute__((type_visibility("default"))) sentry {
            bool __ok_;
            basic_ostream<_CharT, _Traits> &__os_;
            sentry(const std::__1::basic_ostream::sentry &);
            std::__1::basic_ostream::sentry &operator=(const std::__1::basic_ostream::sentry &);
        public:
            explicit sentry(basic_ostream<_CharT, _Traits> &__os);
            ~std::__1::basic_ostream::sentry();
            explicit operator bool() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ok_;
            }


        };
        sentry(basic_ostream<_CharT, _Traits> &__os) : __ok_(false), __os_(__os)         {
            if (__os.good()) {
                if (__os.tie())
                    __os.tie()->flush();
                this->__ok_ = true;
            }
        }


        ~std::__1::basic_ostream::sentry()         {
            if (this->__os_.rdbuf() && this->__os_.good() && (this->__os_.flags() & ios_base::unitbuf) && !uncaught_exception()) {
                try {
                    if (this->__os_.rdbuf()->pubsync() == -1)
                        this->__os_.setstate(ios_base::badbit);
                } catch (...) {
                }
            }
        }


        inline basic_ostream<_CharT, _Traits>(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->init(__sb);
        }


        inline basic_ostream<_CharT, _Traits>(basic_ostream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->move(__rhs);
        }


        inline basic_ostream<_CharT, _Traits> &operator=(basic_ostream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->swap(__rhs);
            return *this;
        }


        ~basic_ostream<_CharT, _Traits>()         {
        }


        inline void swap(basic_ostream<_CharT, _Traits> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            basic_ios<char_type, traits_type>::swap(__rhs);
        }


        inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &(*__pf)(basic_ostream<_CharT, _Traits> &)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __pf(*this);
        }


        inline basic_ostream<_CharT, _Traits> &operator<<(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __pf(*this);
            return *this;
        }


        inline basic_ostream<_CharT, _Traits> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __pf(*this);
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(basic_streambuf<char_type, traits_type> *__sb)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    if (__sb) {
                        try {
                            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                            _Ip __i(__sb);
                            _Ip __eof;
                            _Op __o(*this);
                            size_t __c = 0;
                            for (; __i != __eof; ++__i , ++__o , ++__c) {
                                *__o = *__i;
                                if (__o.failed())
                                    break;
                            }
                            if (__c == 0)
                                this->setstate(ios_base::failbit);
                        } catch (...) {
                            this->__set_failbit_and_consider_rethrow();
                        }
                    } else
                        this->setstate(ios_base::badbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(bool __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(short __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __flags == ios_base::oct || __flags == ios_base::hex ? static_cast<long>(static_cast<unsigned short>(__n)) : static_cast<long>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(unsigned short __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(int __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __flags == ios_base::oct || __flags == ios_base::hex ? static_cast<long>(static_cast<unsigned int>(__n)) : static_cast<long>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(unsigned int __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(long __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(unsigned long __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(long long __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(unsigned long long __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(float __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(double __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(long double __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &operator<<(const void *__n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &__put_character_sequence(basic_ostream<char, std::__1::char_traits<char> > &__os, const char *__str, size_t __len)         {
            try {
                typename basic_ostream<char, char_traits<char> >::sentry __s(__os);
                if (__s) {
                    typedef ostreambuf_iterator<char, std::__1::char_traits<char> > _Ip;
                    if (__pad_and_output(_Ip(__os), __str, (__os.flags() & ios_base::adjustfield) == ios_base::left ? __str + __len : __str, __str + __len, __os, __os.fill()).failed())
                        __os.setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }

template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &__put_character_sequence(basic_ostream<_CharT, _Traits> &__os, const _CharT *__str, size_t __len)         {
            try {
                typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
                if (__s) {
                    typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
                    if (__pad_and_output(_Ip(__os), __str, (__os.flags() & ios_base::adjustfield) == ios_base::left ? __str + __len : __str, __str + __len, __os, __os.fill()).failed())
                        __os.setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, char __c)template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, _CharT __c)         {
            return std::__1::__put_character_sequence(__os, & __c, 1);
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, char __cn)template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, char __cn)         {
            try {
                typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
                if (__s) {
                    _CharT __c = __os.widen(__cn);
                    typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
                    if (__pad_and_output(_Ip(__os), & __c, (__os.flags() & ios_base::adjustfield) == ios_base::left ? & __c + 1 : & __c, & __c + 1, __os, __os.fill()).failed())
                        __os.setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }

;
        template <class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, char __c)template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, char __c)         {
            return std::__1::__put_character_sequence(__os, &__c, 1);
        }

;
        template <class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, signed char __c)template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, signed char __c)         {
            return std::__1::__put_character_sequence(__os, (char *)&__c, 1);
        }

;
        template <class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, unsigned char __c)template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, unsigned char __c)         {
            return std::__1::__put_character_sequence(__os, (char *)&__c, 1);
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, const char *__str)template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const _CharT *__str)         {
            return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, const char *__strn)template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const char *__strn)         {
            try {
                typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
                if (__s) {
                    typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
                    size_t __len = char_traits<char>::length(__strn);
                    const int __bs = 100;
                    _CharT __wbb[100];
                    _CharT *__wb = __wbb;
                    unique_ptr<_CharT, void (*)(void *)> __h(0, free);
                    if (__len > __bs) {
                        __wb = (_CharT *)malloc(__len * sizeof(_CharT));
                        if (__wb == 0)
                            __throw_bad_alloc();
                        __h.reset(__wb);
                    }
                    for (_CharT *__p = __wb; *__strn != '\x00'; ++__strn , ++__p) 
                        *__p = __os.widen(*__strn);
                    if (__pad_and_output(_Ip(__os), __wb, (__os.flags() & ios_base::adjustfield) == ios_base::left ? __wb + __len : __wb, __wb + __len, __os, __os.fill()).failed())
                        __os.setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }

;
        template <class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, const char *__str)         {
            return std::__1::__put_character_sequence(__os, __str, char_traits<char>::length(__str));
        }

template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, const char *__str)         {
            return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
        }

;
        template <class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, const signed char *__str)template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, const signed char *__str)         {
            const char *__s = (const char *)__str;
            return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
        }

;
        template <class _Traits = std::__1::char_traits<char>> basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, const unsigned char *__str)template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, const unsigned char *__str)         {
            const char *__s = (const char *)__str;
            return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
        }

;
        basic_ostream<_CharT, _Traits> &put(char_type __c)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Op __o(*this);
                    *__o = __c;
                    if (__o.failed())
                        this->setstate(ios_base::badbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &write(const char_type *__s, streamsize __n)         {
            try {
                std::__1::basic_ostream::sentry __sen(*this);
                if (__sen && __n) {
                    if (this->rdbuf()->sputn(__s, __n) != __n)
                        this->setstate(ios_base::badbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_ostream<_CharT, _Traits> &flush()         {
            try {
                if (this->rdbuf()) {
                    std::__1::basic_ostream::sentry __s(*this);
                    if (__s) {
                        if (this->rdbuf()->pubsync() == -1)
                            this->setstate(ios_base::badbit);
                    }
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        inline typename basic_ostream<_CharT, _Traits>::pos_type tellp() __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            if (this->fail())
                return pos_type(-1);
            return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        }


        inline basic_ostream<_CharT, _Traits> &seekp(pos_type __pos) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::basic_ostream::sentry __s(*this);
            if (!this->fail()) {
                if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
                    this->setstate(ios_base::failbit);
            }
            return *this;
        }


        inline basic_ostream<_CharT, _Traits> &seekp(off_type __off, ios_base::seekdir __dir) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::basic_ostream::sentry __s(*this);
            if (!this->fail()) {
                if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
                    this->setstate(ios_base::failbit);
            }
            return *this;
        }


        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> inline basic_ostream<char, std::__1::char_traits<char> > &endl(basic_ostream<char, std::__1::char_traits<char> > &__os) __attribute__((always_inline))         {
            __os.put(__os.widen('\n'));
            __os.flush();
            return __os;
        }

template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> &endl(basic_ostream<_CharT, _Traits> &__os) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __os.put(__os.widen('\n'));
            __os.flush();
            return __os;
        }

;
        template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> &ends(basic_ostream<_CharT, _Traits> &__os) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __os.put(_CharT());
            return __os;
        }

;
        template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> &flush(basic_ostream<_CharT, _Traits> &__os) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __os.flush();
            return __os;
        }

;
        template <class _Stream, class _Tp> inline typename enable_if<!is_lvalue_reference<_Stream>::value && is_base_of<ios_base, _Stream>::value, _Stream &&>::type operator<<(_Stream &&__os, const _Tp &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __os << __x;
            return std::__1::move(__os);
        }

;
        template <class _CharT, class _Traits, class _Allocator> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Allocator> &__str)         {
            return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> inline basic_ostream<char, std::__1::char_traits<char> > &operator<<(basic_ostream<char, std::__1::char_traits<char> > &__os, const std::__1::error_code &__ec) __attribute__((always_inline))template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::__1::error_code &__ec) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __os << __ec.category().name() << ':' << __ec.value();
        }

;
        template <class _CharT, class _Traits, class _Yp> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const shared_ptr<_Yp> &__p) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __os << __p.get();
        }

;
        template <class _CharT, class _Traits, size_t _Size> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const bitset<_Size> &__x)         {
            return __os << __x.template to_string<_CharT, _Traits>(use_facet<ctype<_CharT> >(__os.getloc()).widen('0'), use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
        }

;
        class __attribute__((type_visibility("default"))) basic_ostream : virtual public basic_ios<char, std::__1::char_traits<char> > {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_ostream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ostream<char>() noexcept;
        protected:
            basic_ostream(std::__1::basic_ostream<char> &&__rhs) __attribute__((always_inline));
            std::__1::basic_ostream<char> &operator=(std::__1::basic_ostream<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ostream<char> &__rhs) __attribute__((always_inline));
            basic_ostream(const std::__1::basic_ostream<char> &__rhs) = delete
            std::__1::basic_ostream<char> &operator=(const std::__1::basic_ostream<char> &__rhs) = delete
        public:
            class sentry {
                bool __ok_;
                basic_ostream<char, std::__1::char_traits<char> > &__os_;
                sentry(const std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &);
                std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &operator=(const std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &);
            public:
                explicit sentry(basic_ostream<char, std::__1::char_traits<char> > &__os);
                ~std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry() noexcept;
                explicit operator bool() const __attribute__((always_inline))                 {
                    return this->__ok_;
                }


            };
            std::__1::basic_ostream<char> &operator<<(std::__1::basic_ostream<char> &(*__pf)(std::__1::basic_ostream<char> &)) __attribute__((always_inline))             {
                return __pf(*this);
            }


            std::__1::basic_ostream<char> &operator<<(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_ostream<char> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline))             {
                __pf(*this);
                return *this;
            }


            std::__1::basic_ostream<char> &operator<<(bool __n);
            std::__1::basic_ostream<char> &operator<<(short __n);
            std::__1::basic_ostream<char> &operator<<(unsigned short __n);
            std::__1::basic_ostream<char> &operator<<(int __n);
            std::__1::basic_ostream<char> &operator<<(unsigned int __n);
            std::__1::basic_ostream<char> &operator<<(long __n);
            std::__1::basic_ostream<char> &operator<<(unsigned long __n);
            std::__1::basic_ostream<char> &operator<<(long long __n);
            std::__1::basic_ostream<char> &operator<<(unsigned long long __n);
            std::__1::basic_ostream<char> &operator<<(float __f);
            std::__1::basic_ostream<char> &operator<<(double __f);
            std::__1::basic_ostream<char> &operator<<(long double __f);
            std::__1::basic_ostream<char> &operator<<(const void *__p);
            std::__1::basic_ostream<char> &operator<<(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_ostream<char> &put(char_type __c);
            std::__1::basic_ostream<char> &write(const char_type *__s, streamsize __n);
            std::__1::basic_ostream<char> &flush();
            pos_type tellp() __attribute__((always_inline));
            std::__1::basic_ostream<char> &seekp(pos_type __pos) __attribute__((always_inline));
            std::__1::basic_ostream<char> &seekp(off_type __off, ios_base::seekdir __dir) __attribute__((always_inline));
        protected:
            basic_ostream() __attribute__((always_inline));
        };
        class __attribute__((type_visibility("default"))) basic_ostream : virtual public basic_ios<wchar_t, std::__1::char_traits<wchar_t> > {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_ostream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_ostream<wchar_t>() noexcept;
        protected:
            basic_ostream(std::__1::basic_ostream<wchar_t> &&__rhs) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator=(std::__1::basic_ostream<wchar_t> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_ostream<wchar_t> &__rhs) __attribute__((always_inline));
            basic_ostream(const std::__1::basic_ostream<wchar_t> &__rhs) = delete
            std::__1::basic_ostream<wchar_t> &operator=(const std::__1::basic_ostream<wchar_t> &__rhs) = delete
        public:
            class sentry {
                bool __ok_;
                basic_ostream<wchar_t, std::__1::char_traits<wchar_t> > &__os_;
                sentry(const std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
                std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &operator=(const std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
            public:
                explicit sentry(basic_ostream<wchar_t, std::__1::char_traits<wchar_t> > &__os);
                ~std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry();
                explicit operator bool() const __attribute__((always_inline));
            };
            std::__1::basic_ostream<wchar_t> &operator<<(std::__1::basic_ostream<wchar_t> &(*__pf)(std::__1::basic_ostream<wchar_t> &)) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator<<(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &operator<<(bool __n);
            std::__1::basic_ostream<wchar_t> &operator<<(short __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned short __n);
            std::__1::basic_ostream<wchar_t> &operator<<(int __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned int __n);
            std::__1::basic_ostream<wchar_t> &operator<<(long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(long long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned long long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(float __f);
            std::__1::basic_ostream<wchar_t> &operator<<(double __f);
            std::__1::basic_ostream<wchar_t> &operator<<(long double __f);
            std::__1::basic_ostream<wchar_t> &operator<<(const void *__p);
            std::__1::basic_ostream<wchar_t> &operator<<(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_ostream<wchar_t> &put(char_type __c);
            std::__1::basic_ostream<wchar_t> &write(const char_type *__s, streamsize __n);
            std::__1::basic_ostream<wchar_t> &flush();
            pos_type tellp() __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &seekp(pos_type __pos) __attribute__((always_inline));
            std::__1::basic_ostream<wchar_t> &seekp(off_type __off, ios_base::seekdir __dir) __attribute__((always_inline));
        protected:
            basic_ostream() __attribute__((always_inline));
        };
    }
}
namespace std {
    inline namespace __1 {
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_istream : virtual public basic_ios<char, std::__1::char_traits<char> > {
            streamsize __gc_;
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_istream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_istream<char>() noexcept;
        protected:
            basic_istream(std::__1::basic_istream<char> &&__rhs) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator=(std::__1::basic_istream<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_istream<char> &__rhs) __attribute__((always_inline));
        public:
            class sentry {
                bool __ok_;
                sentry(const std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &);
                std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &operator=(const std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &);
            public:
                explicit sentry(basic_istream<char, std::__1::char_traits<char> > &__is, bool __noskipws);
                explicit operator bool() const __attribute__((always_inline));
            };
            std::__1::basic_istream<char> &operator>>(std::__1::basic_istream<char> &(*__pf)(std::__1::basic_istream<char> &)) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator>>(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator>>(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_istream<char> &operator>>(bool &__n);
            std::__1::basic_istream<char> &operator>>(short &__n);
            std::__1::basic_istream<char> &operator>>(unsigned short &__n);
            std::__1::basic_istream<char> &operator>>(int &__n);
            std::__1::basic_istream<char> &operator>>(unsigned int &__n);
            std::__1::basic_istream<char> &operator>>(long &__n);
            std::__1::basic_istream<char> &operator>>(unsigned long &__n);
            std::__1::basic_istream<char> &operator>>(long long &__n);
            std::__1::basic_istream<char> &operator>>(unsigned long long &__n);
            std::__1::basic_istream<char> &operator>>(float &__f);
            std::__1::basic_istream<char> &operator>>(double &__f);
            std::__1::basic_istream<char> &operator>>(long double &__f);
            std::__1::basic_istream<char> &operator>>(void *&__p);
            streamsize gcount() const __attribute__((always_inline));
            int_type get();
            std::__1::basic_istream<char> &get(char_type &__c) __attribute__((always_inline));
            std::__1::basic_istream<char> &get(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<char> &get(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<char> &get(basic_streambuf<char_type, traits_type> &__sb) __attribute__((always_inline));
            std::__1::basic_istream<char> &get(basic_streambuf<char_type, traits_type> &__sb, char_type __dlm);
            std::__1::basic_istream<char> &getline(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<char> &getline(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<char> &ignore(streamsize __n, int_type __dlm);
            int_type peek();
            std::__1::basic_istream<char> &read(char_type *__s, streamsize __n);
            streamsize readsome(char_type *__s, streamsize __n);
            std::__1::basic_istream<char> &putback(char_type __c);
            std::__1::basic_istream<char> &unget();
            int sync();
            pos_type tellg();
            std::__1::basic_istream<char> &seekg(pos_type __pos);
            std::__1::basic_istream<char> &seekg(off_type __off, ios_base::seekdir __dir);
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class __attribute__((type_visibility("default"))) basic_istream : virtual public basic_ios<wchar_t, std::__1::char_traits<wchar_t> > {
            streamsize __gc_;
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_istream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_istream<wchar_t>() noexcept;
        protected:
            basic_istream(std::__1::basic_istream<wchar_t> &&__rhs) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator=(std::__1::basic_istream<wchar_t> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_istream<wchar_t> &__rhs) __attribute__((always_inline));
        public:
            class sentry {
                bool __ok_;
                sentry(const std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
                std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &operator=(const std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
            public:
                explicit sentry(basic_istream<wchar_t, std::__1::char_traits<wchar_t> > &__is, bool __noskipws);
                explicit operator bool() const __attribute__((always_inline));
            };
            std::__1::basic_istream<wchar_t> &operator>>(std::__1::basic_istream<wchar_t> &(*__pf)(std::__1::basic_istream<wchar_t> &)) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator>>(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator>>(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_istream<wchar_t> &operator>>(bool &__n);
            std::__1::basic_istream<wchar_t> &operator>>(short &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned short &__n);
            std::__1::basic_istream<wchar_t> &operator>>(int &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned int &__n);
            std::__1::basic_istream<wchar_t> &operator>>(long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(long long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned long long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(float &__f);
            std::__1::basic_istream<wchar_t> &operator>>(double &__f);
            std::__1::basic_istream<wchar_t> &operator>>(long double &__f);
            std::__1::basic_istream<wchar_t> &operator>>(void *&__p);
            streamsize gcount() const __attribute__((always_inline));
            int_type get();
            std::__1::basic_istream<wchar_t> &get(char_type &__c) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &get(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &get(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<wchar_t> &get(basic_streambuf<char_type, traits_type> &__sb) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &get(basic_streambuf<char_type, traits_type> &__sb, char_type __dlm);
            std::__1::basic_istream<wchar_t> &getline(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &getline(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<wchar_t> &ignore(streamsize __n, int_type __dlm);
            int_type peek();
            std::__1::basic_istream<wchar_t> &read(char_type *__s, streamsize __n);
            streamsize readsome(char_type *__s, streamsize __n);
            std::__1::basic_istream<wchar_t> &putback(char_type __c);
            std::__1::basic_istream<wchar_t> &unget();
            int sync();
            pos_type tellg();
            std::__1::basic_istream<wchar_t> &seekg(pos_type __pos);
            std::__1::basic_istream<wchar_t> &seekg(off_type __off, ios_base::seekdir __dir);
        }
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_istream : virtual public basic_ios<_CharT, _Traits> {
            streamsize __gc_;
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_istream<_CharT, _Traits>(basic_streambuf<char_type, traits_type> *__sb);
            virtual ~basic_istream<_CharT, _Traits>();
        protected:
            basic_istream<_CharT, _Traits>(basic_istream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_istream<_CharT, _Traits> &operator=(basic_istream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void swap(basic_istream<_CharT, _Traits> &__rhs);
        public:
            class __attribute__((type_visibility("default"))) sentry;
            basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &(*__pf)(basic_istream<_CharT, _Traits> &));
            basic_istream<_CharT, _Traits> &operator>>(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &));
            basic_istream<_CharT, _Traits> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &));
            basic_istream<_CharT, _Traits> &operator>>(basic_streambuf<char_type, traits_type> *__sb);
            basic_istream<_CharT, _Traits> &operator>>(bool &__n);
            basic_istream<_CharT, _Traits> &operator>>(short &__n);
            basic_istream<_CharT, _Traits> &operator>>(unsigned short &__n);
            basic_istream<_CharT, _Traits> &operator>>(int &__n);
            basic_istream<_CharT, _Traits> &operator>>(unsigned int &__n);
            basic_istream<_CharT, _Traits> &operator>>(long &__n);
            basic_istream<_CharT, _Traits> &operator>>(unsigned long &__n);
            basic_istream<_CharT, _Traits> &operator>>(long long &__n);
            basic_istream<_CharT, _Traits> &operator>>(unsigned long long &__n);
            basic_istream<_CharT, _Traits> &operator>>(float &__f);
            basic_istream<_CharT, _Traits> &operator>>(double &__f);
            basic_istream<_CharT, _Traits> &operator>>(long double &__f);
            basic_istream<_CharT, _Traits> &operator>>(void *&__p);
            streamsize gcount() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__gc_;
            }


            int_type get();
            basic_istream<_CharT, _Traits> &get(char_type &__c);
            basic_istream<_CharT, _Traits> &get(char_type *__s, streamsize __n);
            basic_istream<_CharT, _Traits> &get(char_type *__s, streamsize __n, char_type __dlm);
            basic_istream<_CharT, _Traits> &get(basic_streambuf<char_type, traits_type> &__sb);
            basic_istream<_CharT, _Traits> &get(basic_streambuf<char_type, traits_type> &__sb, char_type __dlm);
            basic_istream<_CharT, _Traits> &getline(char_type *__s, streamsize __n);
            basic_istream<_CharT, _Traits> &getline(char_type *__s, streamsize __n, char_type __dlm);
            basic_istream<_CharT, _Traits> &ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
            int_type peek();
            basic_istream<_CharT, _Traits> &read(char_type *__s, streamsize __n);
            streamsize readsome(char_type *__s, streamsize __n);
            basic_istream<_CharT, _Traits> &putback(char_type __c);
            basic_istream<_CharT, _Traits> &unget();
            int sync();
            pos_type tellg();
            basic_istream<_CharT, _Traits> &seekg(pos_type __pos);
            basic_istream<_CharT, _Traits> &seekg(off_type __off, ios_base::seekdir __dir);
        };
        class __attribute__((type_visibility("default"))) sentry {
            bool __ok_;
            sentry(const std::__1::basic_istream::sentry &);
            std::__1::basic_istream::sentry &operator=(const std::__1::basic_istream::sentry &);
        public:
            explicit sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false);
            explicit operator bool() const __attribute__((always_inline)) __attribute__((visibility("hidden")))             {
                return this->__ok_;
            }


        };
        sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false) : __ok_(false)         {
            if (__is.good()) {
                if (__is.tie())
                    __is.tie()->flush();
                if (!__noskipws && (__is.flags() & ios_base::skipws)) {
                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    _Ip __i(__is);
                    _Ip __eof;
                    for (; __i != __eof; ++__i) 
                        if (!__ct.is(__ct.space, *__i))
                            break;
                    if (__i == __eof)
                        __is.setstate(ios_base::failbit | ios_base::eofbit);
                }
                this->__ok_ = __is.good();
            } else
                __is.setstate(ios_base::failbit);
        }


        inline basic_istream<_CharT, _Traits>(basic_streambuf<char_type, traits_type> *__sb) : __gc_(0) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->init(__sb);
        }


        inline basic_istream<_CharT, _Traits>(basic_istream<_CharT, _Traits> &&__rhs) : __gc_(__rhs.__gc_) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __rhs.__gc_ = 0;
            this->move(__rhs);
        }


        inline basic_istream<_CharT, _Traits> &operator=(basic_istream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->swap(__rhs);
            return *this;
        }


        ~basic_istream<_CharT, _Traits>()         {
        }


        inline void swap(basic_istream<_CharT, _Traits> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            std::__1::swap(this->__gc_, __rhs.__gc_);
            basic_ios<char_type, traits_type>::swap(__rhs);
        }


        basic_istream<_CharT, _Traits> &operator>>(unsigned short &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(unsigned int &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(long &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(unsigned long &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(long long &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(unsigned long long &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(float &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(double &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(long double &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(bool &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(void *&__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(short &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    long __temp;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
                    if (__temp < numeric_limits<short>::min()) {
                        __err |= ios_base::failbit;
                        __n = numeric_limits<short>::min();
                    } else if (__temp > numeric_limits<short>::max()) {
                        __err |= ios_base::failbit;
                        __n = numeric_limits<short>::max();
                    } else
                        __n = static_cast<short>(__temp);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &operator>>(int &__n)         {
            try {
                std::__1::basic_istream::sentry __s(*this);
                if (__s) {
                    typedef istreambuf_iterator<char_type, traits_type> _Ip;
                    typedef num_get<char_type, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    long __temp;
                    use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
                    if (__temp < numeric_limits<int>::min()) {
                        __err |= ios_base::failbit;
                        __n = numeric_limits<int>::min();
                    } else if (__temp > numeric_limits<int>::max()) {
                        __err |= ios_base::failbit;
                        __n = numeric_limits<int>::max();
                    } else
                        __n = static_cast<int>(__temp);
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        inline basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &(*__pf)(basic_istream<_CharT, _Traits> &)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __pf(*this);
        }


        inline basic_istream<_CharT, _Traits> &operator>>(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __pf(*this);
            return *this;
        }


        inline basic_istream<_CharT, _Traits> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __pf(*this);
            return *this;
        }


        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, _CharT *__s)         {
            try {
                typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
                if (__sen) {
                    streamsize __n = __is.width();
                    if (__n <= 0)
                        __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
                    streamsize __c = 0;
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    ios_base::iostate __err = ios_base::goodbit;
                    while (__c < __n - 1)
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __err |= ios_base::eofbit;
                                break;
                            }
                            _CharT __ch = _Traits::to_char_type(__i);
                            if (__ct.is(__ct.space, __ch))
                                break;
                            *__s++ = __ch;
                            ++__c;
                            __is.rdbuf()->sbumpc();
                        }
                    *__s = _CharT();
                    __is.width(0);
                    if (__c == 0)
                        __err |= ios_base::failbit;
                    __is.setstate(__err);
                }
            } catch (...) {
                __is.__set_badbit_and_consider_rethrow();
            }
            return __is;
        }

;
        template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__is, unsigned char *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __is >> (char *)__s;
        }

;
        template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__is, signed char *__s) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __is >> (char *)__s;
        }

;
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, _CharT &__c)         {
            try {
                typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
                if (__sen) {
                    typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                    if (_Traits::eq_int_type(__i, _Traits::eof()))
                        __is.setstate(ios_base::eofbit | ios_base::failbit);
                    else
                        __c = _Traits::to_char_type(__i);
                }
            } catch (...) {
                __is.__set_badbit_and_consider_rethrow();
            }
            return __is;
        }

;
        template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__is, unsigned char &__c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __is >> (char &)__c;
        }

;
        template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__is, signed char &__c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return __is >> (char &)__c;
        }

;
        basic_istream<_CharT, _Traits> &operator>>(basic_streambuf<char_type, traits_type> *__sb)         {
            this->__gc_ = 0;
            try {
                std::__1::basic_istream::sentry __s(*this, true);
                if (__s) {
                    if (__sb) {
                        try {
                            ios_base::iostate __err = ios_base::goodbit;
                            while (true)
                                {
                                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                                    if (traits_type::eq_int_type(__i, _Traits::eof())) {
                                        __err |= ios_base::eofbit;
                                        break;
                                    }
                                    if (traits_type::eq_int_type(__sb->sputc(traits_type::to_char_type(__i)), traits_type::eof()))
                                        break;
                                    ++this->__gc_;
                                    this->rdbuf()->sbumpc();
                                }
                            if (this->__gc_ == 0)
                                __err |= ios_base::failbit;
                            this->setstate(__err);
                        } catch (...) {
                            if (this->__gc_ == 0)
                                this->__set_failbit_and_consider_rethrow();
                        }
                    } else
                        this->setstate(ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        typename basic_istream<_CharT, _Traits>::int_type get()         {
            this->__gc_ = 0;
            int_type __r = traits_type::eof();
            try {
                std::__1::basic_istream::sentry __s(*this, true);
                if (__s) {
                    __r = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__r, traits_type::eof()))
                        this->setstate(ios_base::failbit | ios_base::eofbit);
                    else
                        this->__gc_ = 1;
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return __r;
        }


        inline basic_istream<_CharT, _Traits> &get(char_type &__c) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            int_type __ch = get();
            if (__ch != traits_type::eof())
                __c = traits_type::to_char_type(__ch);
            return *this;
        }


        basic_istream<_CharT, _Traits> &get(char_type *__s, streamsize __n, char_type __dlm)         {
            this->__gc_ = 0;
            try {
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    if (__n > 0) {
                        ios_base::iostate __err = ios_base::goodbit;
                        while (this->__gc_ < __n - 1)
                            {
                                int_type __i = this->rdbuf()->sgetc();
                                if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                    __err |= ios_base::eofbit;
                                    break;
                                }
                                char_type __ch = traits_type::to_char_type(__i);
                                if (traits_type::eq(__ch, __dlm))
                                    break;
                                *__s++ = __ch;
                                ++this->__gc_;
                                this->rdbuf()->sbumpc();
                            }
                        *__s = char_type();
                        if (this->__gc_ == 0)
                            __err |= ios_base::failbit;
                        this->setstate(__err);
                    } else
                        this->setstate(ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        inline basic_istream<_CharT, _Traits> &get(char_type *__s, streamsize __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return get(__s, __n, this->widen('\n'));
        }


        basic_istream<_CharT, _Traits> &get(basic_streambuf<char_type, traits_type> &__sb, char_type __dlm)         {
            this->__gc_ = 0;
            try {
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    ios_base::iostate __err = ios_base::goodbit;
                    try {
                        while (true)
                            {
                                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                                if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                    __err |= ios_base::eofbit;
                                    break;
                                }
                                char_type __ch = traits_type::to_char_type(__i);
                                if (traits_type::eq(__ch, __dlm))
                                    break;
                                if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                                    break;
                                ++this->__gc_;
                                this->rdbuf()->sbumpc();
                            }
                    } catch (...) {
                    }
                    if (this->__gc_ == 0)
                        __err |= ios_base::failbit;
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        inline basic_istream<_CharT, _Traits> &get(basic_streambuf<char_type, traits_type> &__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return get(__sb, this->widen('\n'));
        }


        basic_istream<_CharT, _Traits> &getline(char_type *__s, streamsize __n, char_type __dlm)         {
            this->__gc_ = 0;
            try {
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    ios_base::iostate __err = ios_base::goodbit;
                    while (true)
                        {
                            typename traits_type::int_type __i = this->rdbuf()->sgetc();
                            if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                __err |= ios_base::eofbit;
                                break;
                            }
                            char_type __ch = traits_type::to_char_type(__i);
                            if (traits_type::eq(__ch, __dlm)) {
                                this->rdbuf()->sbumpc();
                                ++this->__gc_;
                                break;
                            }
                            if (this->__gc_ >= __n - 1) {
                                __err |= ios_base::failbit;
                                break;
                            }
                            *__s++ = __ch;
                            this->rdbuf()->sbumpc();
                            ++this->__gc_;
                        }
                    if (__n > 0)
                        *__s = char_type();
                    if (this->__gc_ == 0)
                        __err |= ios_base::failbit;
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        inline basic_istream<_CharT, _Traits> &getline(char_type *__s, streamsize __n) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return getline(__s, __n, this->widen('\n'));
        }


        basic_istream<_CharT, _Traits> &ignore(streamsize __n = 1, int_type __dlm = traits_type::eof())         {
            this->__gc_ = 0;
            try {
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    ios_base::iostate __err = ios_base::goodbit;
                    if (__n == numeric_limits<streamsize>::max()) {
                        while (true)
                            {
                                typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                                if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                    __err |= ios_base::eofbit;
                                    break;
                                }
                                ++this->__gc_;
                                if (traits_type::eq_int_type(__i, __dlm))
                                    break;
                            }
                    } else {
                        while (this->__gc_ < __n)
                            {
                                typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                                if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                    __err |= ios_base::eofbit;
                                    break;
                                }
                                ++this->__gc_;
                                if (traits_type::eq_int_type(__i, __dlm))
                                    break;
                            }
                    }
                    this->setstate(__err);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        typename basic_istream<_CharT, _Traits>::int_type peek()         {
            this->__gc_ = 0;
            int_type __r = traits_type::eof();
            try {
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    __r = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__r, traits_type::eof()))
                        this->setstate(ios_base::eofbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return __r;
        }


        basic_istream<_CharT, _Traits> &read(char_type *__s, streamsize __n)         {
            this->__gc_ = 0;
            try {
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    this->__gc_ = this->rdbuf()->sgetn(__s, __n);
                    if (this->__gc_ != __n)
                        this->setstate(ios_base::failbit | ios_base::eofbit);
                } else
                    this->setstate(ios_base::failbit);
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        streamsize readsome(char_type *__s, streamsize __n)         {
            this->__gc_ = 0;
            streamsize __c = this->rdbuf()->in_avail();
            switch (__c) {
              case -1:
                this->setstate(ios_base::eofbit);
                break;
              case 0:
                break;
              default:
                this->read(__s, std::__1::min(__c, __n));
                break;
            }
            return this->__gc_;
        }


        basic_istream<_CharT, _Traits> &putback(char_type __c)         {
            this->__gc_ = 0;
            try {
                this->clear(this->rdstate() & ~ios_base::eofbit);
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                        this->setstate(ios_base::badbit);
                } else
                    this->setstate(ios_base::failbit);
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &unget()         {
            this->__gc_ = 0;
            try {
                this->clear(this->rdstate() & ~ios_base::eofbit);
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())
                        this->setstate(ios_base::badbit);
                } else
                    this->setstate(ios_base::failbit);
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        int sync()         {
            int __r = 0;
            try {
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    if (this->rdbuf() == 0)
                        return -1;
                    if (this->rdbuf()->pubsync() == -1) {
                        this->setstate(ios_base::badbit);
                        return -1;
                    }
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return __r;
        }


        typename basic_istream<_CharT, _Traits>::pos_type tellg()         {
            pos_type __r(-1);
            try {
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen)
                    __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return __r;
        }


        basic_istream<_CharT, _Traits> &seekg(pos_type __pos)         {
            try {
                this->clear(this->rdstate() & ~ios_base::eofbit);
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                        this->setstate(ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        basic_istream<_CharT, _Traits> &seekg(off_type __off, ios_base::seekdir __dir)         {
            try {
                this->clear(this->rdstate() & ~ios_base::eofbit);
                std::__1::basic_istream::sentry __sen(*this, true);
                if (__sen) {
                    if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                        this->setstate(ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }


        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__is)         {
            try {
                typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
                if (__sen) {
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    while (true)
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __is.setstate(ios_base::eofbit);
                                break;
                            }
                            if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                                break;
                            __is.rdbuf()->sbumpc();
                        }
                }
            } catch (...) {
                __is.__set_badbit_and_consider_rethrow();
            }
            return __is;
        }

;
        template <class _CharT, class _Traits, class _Tp> inline basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &&__is, _Tp &__x) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            __is >> __x;
            return __is;
        }

;
        template <class _CharT = char, class _Traits = std::__1::char_traits<char>> class __attribute__((type_visibility("default"))) basic_iostream : public basic_istream<char, std::__1::char_traits<char> >, public basic_ostream<char, std::__1::char_traits<char> > {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_iostream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_iostream<char>() noexcept;
        protected:
            basic_iostream(std::__1::basic_iostream<char> &&__rhs) __attribute__((always_inline));
            std::__1::basic_iostream<char> &operator=(std::__1::basic_iostream<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_iostream<char> &__rhs) __attribute__((always_inline));
        public:
        }
template <class _CharT = wchar_t, class _Traits = std::__1::char_traits<wchar_t>> class basic_iostream
template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_iostream : public basic_istream<_CharT, _Traits>, public basic_ostream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_iostream<_CharT, _Traits>(basic_streambuf<char_type, traits_type> *__sb);
            virtual ~basic_iostream<_CharT, _Traits>();
        protected:
            basic_iostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            basic_iostream<_CharT, _Traits> &operator=(basic_iostream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")));
            void swap(basic_iostream<_CharT, _Traits> &__rhs);
        public:
        };
        inline basic_iostream<_CharT, _Traits>(basic_streambuf<char_type, traits_type> *__sb) : basic_istream<_CharT, _Traits>(__sb) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline basic_iostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &&__rhs) : basic_istream<_CharT, _Traits>(std::__1::move(__rhs)) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
        }


        inline basic_iostream<_CharT, _Traits> &operator=(basic_iostream<_CharT, _Traits> &&__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            this->swap(__rhs);
            return *this;
        }


        ~basic_iostream<_CharT, _Traits>()         {
        }


        inline void swap(basic_iostream<_CharT, _Traits> &__rhs) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            basic_istream<char_type, traits_type>::swap(__rhs);
        }


        template <class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str)         {
            try {
                typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
                if (__sen) {
                    __str.clear();
                    streamsize __n = __is.width();
                    if (__n <= 0)
                        __n = __str.max_size();
                    if (__n <= 0)
                        __n = numeric_limits<streamsize>::max();
                    streamsize __c = 0;
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    ios_base::iostate __err = ios_base::goodbit;
                    while (__c < __n)
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __err |= ios_base::eofbit;
                                break;
                            }
                            _CharT __ch = _Traits::to_char_type(__i);
                            if (__ct.is(__ct.space, __ch))
                                break;
                            __str.push_back(__ch);
                            ++__c;
                            __is.rdbuf()->sbumpc();
                        }
                    __is.width(0);
                    if (__c == 0)
                        __err |= ios_base::failbit;
                    __is.setstate(__err);
                } else
                    __is.setstate(ios_base::failbit);
            } catch (...) {
                __is.__set_badbit_and_consider_rethrow();
            }
            return __is;
        }

;
        template <class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm)         {
            try {
                typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
                if (__sen) {
                    __str.clear();
                    ios_base::iostate __err = ios_base::goodbit;
                    streamsize __extr = 0;
                    while (true)
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __err |= ios_base::eofbit;
                                break;
                            }
                            ++__extr;
                            _CharT __ch = _Traits::to_char_type(__i);
                            if (_Traits::eq(__ch, __dlm))
                                break;
                            __str.push_back(__ch);
                            if (__str.size() == __str.max_size()) {
                                __err |= ios_base::failbit;
                                break;
                            }
                        }
                    if (__extr == 0)
                        __err |= ios_base::failbit;
                    __is.setstate(__err);
                }
            } catch (...) {
                __is.__set_badbit_and_consider_rethrow();
            }
            return __is;
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return getline(__is, __str, __is.widen('\n'));
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return getline(__is, __str, __dlm);
        }

;
        template <class _CharT, class _Traits, class _Allocator> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((always_inline)) __attribute__((visibility("hidden")))         {
            return getline(__is, __str, __is.widen('\n'));
        }

;
        template <class _CharT, class _Traits, size_t _Size> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, bitset<_Size> &__x)         {
            try {
                typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
                if (__sen) {
                    basic_string<_CharT, _Traits> __str;
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    streamsize __c = 0;
                    ios_base::iostate __err = ios_base::goodbit;
                    _CharT __zero = __ct.widen('0');
                    _CharT __one = __ct.widen('1');
                    while (__c < _Size)
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __err |= ios_base::eofbit;
                                break;
                            }
                            _CharT __ch = _Traits::to_char_type(__i);
                            if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                                break;
                            __str.push_back(__ch);
                            ++__c;
                            __is.rdbuf()->sbumpc();
                        }
                    __x = bitset<_Size>(__str);
                    if (__c == 0)
                        __err |= ios_base::failbit;
                    __is.setstate(__err);
                } else
                    __is.setstate(ios_base::failbit);
            } catch (...) {
                __is.__set_badbit_and_consider_rethrow();
            }
            return __is;
        }

;
        class __attribute__((type_visibility("default"))) basic_istream : virtual public basic_ios<char, std::__1::char_traits<char> > {
            streamsize __gc_;
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_istream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_istream<char>() noexcept;
        protected:
            basic_istream(std::__1::basic_istream<char> &&__rhs) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator=(std::__1::basic_istream<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_istream<char> &__rhs) __attribute__((always_inline));
        public:
            class sentry {
                bool __ok_;
                sentry(const std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &);
                std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &operator=(const std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &);
            public:
                explicit sentry(basic_istream<char, std::__1::char_traits<char> > &__is, bool __noskipws);
                explicit operator bool() const __attribute__((always_inline));
            };
            std::__1::basic_istream<char> &operator>>(std::__1::basic_istream<char> &(*__pf)(std::__1::basic_istream<char> &)) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator>>(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline));
            std::__1::basic_istream<char> &operator>>(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_istream<char> &operator>>(bool &__n);
            std::__1::basic_istream<char> &operator>>(short &__n);
            std::__1::basic_istream<char> &operator>>(unsigned short &__n);
            std::__1::basic_istream<char> &operator>>(int &__n);
            std::__1::basic_istream<char> &operator>>(unsigned int &__n);
            std::__1::basic_istream<char> &operator>>(long &__n);
            std::__1::basic_istream<char> &operator>>(unsigned long &__n);
            std::__1::basic_istream<char> &operator>>(long long &__n);
            std::__1::basic_istream<char> &operator>>(unsigned long long &__n);
            std::__1::basic_istream<char> &operator>>(float &__f);
            std::__1::basic_istream<char> &operator>>(double &__f);
            std::__1::basic_istream<char> &operator>>(long double &__f);
            std::__1::basic_istream<char> &operator>>(void *&__p);
            streamsize gcount() const __attribute__((always_inline));
            int_type get();
            std::__1::basic_istream<char> &get(char_type &__c) __attribute__((always_inline));
            std::__1::basic_istream<char> &get(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<char> &get(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<char> &get(basic_streambuf<char_type, traits_type> &__sb) __attribute__((always_inline));
            std::__1::basic_istream<char> &get(basic_streambuf<char_type, traits_type> &__sb, char_type __dlm);
            std::__1::basic_istream<char> &getline(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<char> &getline(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<char> &ignore(streamsize __n, int_type __dlm);
            int_type peek();
            std::__1::basic_istream<char> &read(char_type *__s, streamsize __n);
            streamsize readsome(char_type *__s, streamsize __n);
            std::__1::basic_istream<char> &putback(char_type __c);
            std::__1::basic_istream<char> &unget();
            int sync();
            pos_type tellg();
            std::__1::basic_istream<char> &seekg(pos_type __pos);
            std::__1::basic_istream<char> &seekg(off_type __off, ios_base::seekdir __dir);
        };
        class __attribute__((type_visibility("default"))) basic_istream : virtual public basic_ios<wchar_t, std::__1::char_traits<wchar_t> > {
            streamsize __gc_;
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_istream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_istream<wchar_t>() noexcept;
        protected:
            basic_istream(std::__1::basic_istream<wchar_t> &&__rhs) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator=(std::__1::basic_istream<wchar_t> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_istream<wchar_t> &__rhs) __attribute__((always_inline));
        public:
            class sentry {
                bool __ok_;
                sentry(const std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
                std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &operator=(const std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
            public:
                explicit sentry(basic_istream<wchar_t, std::__1::char_traits<wchar_t> > &__is, bool __noskipws);
                explicit operator bool() const __attribute__((always_inline));
            };
            std::__1::basic_istream<wchar_t> &operator>>(std::__1::basic_istream<wchar_t> &(*__pf)(std::__1::basic_istream<wchar_t> &)) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator>>(basic_ios<char_type, traits_type> &(*__pf)(basic_ios<char_type, traits_type> &)) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &operator>>(basic_streambuf<char_type, traits_type> *__sb);
            std::__1::basic_istream<wchar_t> &operator>>(bool &__n);
            std::__1::basic_istream<wchar_t> &operator>>(short &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned short &__n);
            std::__1::basic_istream<wchar_t> &operator>>(int &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned int &__n);
            std::__1::basic_istream<wchar_t> &operator>>(long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(long long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned long long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(float &__f);
            std::__1::basic_istream<wchar_t> &operator>>(double &__f);
            std::__1::basic_istream<wchar_t> &operator>>(long double &__f);
            std::__1::basic_istream<wchar_t> &operator>>(void *&__p);
            streamsize gcount() const __attribute__((always_inline));
            int_type get();
            std::__1::basic_istream<wchar_t> &get(char_type &__c) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &get(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &get(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<wchar_t> &get(basic_streambuf<char_type, traits_type> &__sb) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &get(basic_streambuf<char_type, traits_type> &__sb, char_type __dlm);
            std::__1::basic_istream<wchar_t> &getline(char_type *__s, streamsize __n) __attribute__((always_inline));
            std::__1::basic_istream<wchar_t> &getline(char_type *__s, streamsize __n, char_type __dlm);
            std::__1::basic_istream<wchar_t> &ignore(streamsize __n, int_type __dlm);
            int_type peek();
            std::__1::basic_istream<wchar_t> &read(char_type *__s, streamsize __n);
            streamsize readsome(char_type *__s, streamsize __n);
            std::__1::basic_istream<wchar_t> &putback(char_type __c);
            std::__1::basic_istream<wchar_t> &unget();
            int sync();
            pos_type tellg();
            std::__1::basic_istream<wchar_t> &seekg(pos_type __pos);
            std::__1::basic_istream<wchar_t> &seekg(off_type __off, ios_base::seekdir __dir);
        };
        class __attribute__((type_visibility("default"))) basic_iostream : public basic_istream<char, std::__1::char_traits<char> >, public basic_ostream<char, std::__1::char_traits<char> > {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            explicit basic_iostream(basic_streambuf<char_type, traits_type> *__sb) __attribute__((always_inline));
            virtual ~std::__1::basic_iostream<char>() noexcept;
        protected:
            basic_iostream(std::__1::basic_iostream<char> &&__rhs) __attribute__((always_inline));
            std::__1::basic_iostream<char> &operator=(std::__1::basic_iostream<char> &&__rhs) __attribute__((always_inline));
            void swap(std::__1::basic_iostream<char> &__rhs) __attribute__((always_inline));
        public:
        };
    }
}
namespace std {
    inline namespace __1 {
        extern istream cin __attribute__((visibility("default")));
        extern wistream wcin __attribute__((visibility("default")));
        extern ostream cout __attribute__((visibility("default")));
        extern wostream wcout __attribute__((visibility("default")));
        extern ostream cerr __attribute__((visibility("default")));
        extern wostream wcerr __attribute__((visibility("default")));
        extern ostream clog __attribute__((visibility("default")));
        extern wostream wclog __attribute__((visibility("default")));
    }
}
template <class T = short> typename std::enable_if<std::is_integral<short>::value, bool>::type is_odd(short i) {
    return bool(i % 2);
}

template <class T> typename std::enable_if<std::is_integral<T>::value, bool>::type is_odd(T i) {
    return bool(i % 2);
}

;
template <class T = short, class  = void> bool is_even(short i) {
    return !bool(i % 2);
}

template <class T, class  = typename std::enable_if<std::is_integral<T>::value>::type> bool is_even(T i) {
    return !bool(i % 2);
}

;
int main() {
    short i = 1;
    std::cout << std::boolalpha;
    std::cout << "i is odd: " << is_odd(i) << std::endl;
    std::cout << "i is even: " << is_even(i) << std::endl;
    return 0;
}


